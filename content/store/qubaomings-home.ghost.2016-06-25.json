{"db":[{"meta":{"exported_on":1466826197073,"version":"006"},"data":{"posts":[{"id":1,"uuid":"2de288af-1cb9-4d6a-889b-980cb05dec50","title":"Javascript中的括号哲学","slug":"welcome-to-ghost","markdown":"平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。\n\n最近刚好在看ECMAScript262，又遇到这些问题。整理一下：\n\n## 引入\n\n先上一段代码:\n\n```\nalert(foo);\nfunction foo(x) {\n    alert(x);\n}(1);\nfoo(10);\n```\n\n这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.\n\ngoogle了一下Group Operation：\n\n```\na means of controlling precedence(优先级) of evaluation in expressions.\n```\n难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？\n\n## 深入\n\n再看两个表达式：\n```\nfunction () { ... }();\nfunction foo() { ... }();\n```\n\n在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 \n\n在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 \n\n第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 \n\n这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 \n\n最常规例子：\n\n```\n(function(){\n    alert(\"cftea\");\n})();\n```\n\n这个可以理解为：\n```\nfunction foo(){\n    alert(1);\n}\nfoo();\n```\n这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：\n```\n(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){\n    alert(\"cftea\");\n}()\n```\n以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。\n\n## 括号对上下文作用域的影响\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();\n```\n这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n})();\n```\n这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。\n```\nfunction Foo() {\n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n```","mobiledoc":null,"html":"<p>平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。</p>\n\n<p>最近刚好在看ECMAScript262，又遇到这些问题。整理一下：</p>\n\n<h2 id=\"\">引入</h2>\n\n<p>先上一段代码:</p>\n\n<pre><code>alert(foo);  \nfunction foo(x) {  \n    alert(x);\n}(1);\nfoo(10);  \n</code></pre>\n\n<p>这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.</p>\n\n<p>google了一下Group Operation：</p>\n\n<pre><code>a means of controlling precedence(优先级) of evaluation in expressions.  \n</code></pre>\n\n<p>难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>再看两个表达式：</p>\n\n<pre><code>function () { ... }();  \nfunction foo() { ... }();  \n</code></pre>\n\n<p>在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 </p>\n\n<p>在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 </p>\n\n<p>第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 </p>\n\n<p>这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 </p>\n\n<p>最常规例子：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n</code></pre>\n\n<p>这个可以理解为：</p>\n\n<pre><code>function foo(){  \n    alert(1);\n}\nfoo();  \n</code></pre>\n\n<p>这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){  \n    alert(\"cftea\");\n}()\n</code></pre>\n\n<p>以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。</p>\n\n<h2 id=\"\">括号对上下文作用域的影响</h2>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();  \n</code></pre>\n\n<p>这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。</p>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n})();\n</code></pre>\n\n<p>这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。</p>\n\n<pre><code>function Foo() {  \n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-16 15:10:26","updated_by":1,"published_at":"2016-06-13 15:39:49","published_by":1},{"id":2,"uuid":"f6359f78-158b-45f0-bb06-bd365bf27708","title":"关于js修改三种css样式的方法","slug":"test","markdown":"晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。\n\n## 遇到的问题是：\n最开始在.css文件里面设置了图片的`position：absolute；`, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。\n\n之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。\n\n现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。\n\n## 深入\n怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。\n```\nfunction getDefaultStyle(obj,attribute){\n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n```\n或者：\n```\nfunction getDefault(obj){\n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n```\n例子：\n\n使用javascript更改某个css class的属性:\n```\n.orig {\n    display: none;\n}\n```\n你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：\n```\ndocument.styleSheets[0].rules[0].style.display = \"inline\";\n```\n在firefox里：\n```\ndocument.styleSheets[0].cssRules[0].style.display = \"inline\";\n```\n讨论： 可以做一个函数来搜索特定名字的style对象：\n```\nfunction getstyle(sname) {\n    for (var i=0;i< document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j< rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n```\n然后只要：\n```\ngetstyle(\".orig\").display = \"inline\";\n```\n## 总结：\n前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。\n\n在ie和firefox里面确实可以实现，不过我们不提倡。\n\n在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。\n\n所以，最好的方式还是直接修改dom里面的属性。\n\n弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。","mobiledoc":null,"html":"<p>晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。</p>\n\n<h2 id=\"\">遇到的问题是：</h2>\n\n<p>最开始在.css文件里面设置了图片的<code>position：absolute；</code>, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。</p>\n\n<p>之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。</p>\n\n<p>现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。  </p>\n\n<pre><code>function getDefaultStyle(obj,attribute){  \n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n</code></pre>\n\n<p>或者：</p>\n\n<pre><code>function getDefault(obj){  \n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n</code></pre>\n\n<p>例子：</p>\n\n<p>使用javascript更改某个css class的属性:</p>\n\n<pre><code>.orig {\n    display: none;\n}\n</code></pre>\n\n<p>你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：</p>\n\n<pre><code>document.styleSheets[0].rules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>在firefox里：</p>\n\n<pre><code>document.styleSheets[0].cssRules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>讨论： 可以做一个函数来搜索特定名字的style对象：</p>\n\n<pre><code>function getstyle(sname) {  \n    for (var i=0;i&lt; document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j&lt; rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>然后只要：</p>\n\n<pre><code>getstyle(\".orig\").display = \"inline\";  \n</code></pre>\n\n<h2 id=\"\">总结：</h2>\n\n<p>前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。</p>\n\n<p>在ie和firefox里面确实可以实现，不过我们不提倡。</p>\n\n<p>在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。</p>\n\n<p>所以，最好的方式还是直接修改dom里面的属性。</p>\n\n<p>弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-14 15:29:43","created_by":1,"updated_at":"2016-06-16 15:13:41","updated_by":1,"published_at":"2016-06-14 15:30:16","published_by":1},{"id":3,"uuid":"2f69b803-fcce-494d-a7dd-32380a856a75","title":"学会使用chrome的F12","slug":"xue-hui-shi-yong-chromede-f12","markdown":"学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~\n\n用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。\n\n折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）\n\n## Network工具\nchrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。\n \n![](/content/images/2016/06/network1.jpg)\n \n![](/content/images/2016/06/network2.jpg)\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。\n\n## Timeline\n注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：\n\n![](/content/images/2016/06/timeline.jpg)\n在上面点击后再点击红色的圆圈就可以了。\n## Profiles\n\n![](/content/images/2016/06/profile-1.jpg)\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU）\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 \n\n后面的学会了在更新~\n","mobiledoc":null,"html":"<p>学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~</p>\n\n<p>用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。</p>\n\n<p>折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）</p>\n\n<h2 id=\"network\">Network工具</h2>\n\n<p>chrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。</p>\n\n<p><img src=\"/content/images/2016/06/network1.jpg\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2016/06/network2.jpg\" alt=\"\" />\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。</p>\n\n<h2 id=\"timeline\">Timeline</h2>\n\n<p>注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：</p>\n\n<p><img src=\"/content/images/2016/06/timeline.jpg\" alt=\"\" />\n在上面点击后再点击红色的圆圈就可以了。</p>\n\n<h2 id=\"profiles\">Profiles</h2>\n\n<p><img src=\"/content/images/2016/06/profile-1.jpg\" alt=\"\" />\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU） <br />\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 </p>\n\n<p>后面的学会了在更新~</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:14:27","created_by":1,"updated_at":"2016-06-16 15:21:25","updated_by":1,"published_at":"2016-06-16 15:21:25","published_by":1},{"id":4,"uuid":"4d6da924-1e41-4473-bd73-de3078d5da99","title":"淘宝UED的前端招聘测试题","slug":"tao-bao-uedde-qian-duan-zhao-pin-ce-shi-ti","markdown":"## 引言\n\n最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。\n\n中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 \n\n时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。\n\n不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。\n\n小测试是这样的：就是把以前的radio变成图片。\n\n![](/content/images/2016/06/question.jpg)\n\n码代码之前先分析一下：\n\nradio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。\n\n## 实现\n\n下面是具体实现：\n```\n<form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'>\n    <fieldset>\n        <legend>MyValue</legend>\n\n        <div class = 'radioColorParent'>\n            <input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked> 棕色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"> 黄色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"> 紫红色\n        </div>\n\n\n    &lt;div class = 'picColor'&gt; \n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;                  \n          &lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;   \n          &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n          &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n         &lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&gt;          \n         &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;input type=\"submit\" value='submit'&gt;\n&lt;/fieldset&gt;\n\n\n</form>\n```\n \n以上就是实现基本的html代码，把几个为radio的input隐藏了。\n`css：`\n```\n.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{\n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{\n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n```\n把radio的input隐藏了，然后设置点边框。 贴下js代码：\n```\n$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();\nusercolorselect.init($('.picColorImgParent'));\nusercolorselect.changeStyle();\nusercolorselect.updateRadio();\n\n\n});\n```\n上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：\n\n![](/content/images/2016/06/final.jpg)\n\n兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~\n\n最后代码都放在了[github](https://github.com/freestyle21/taobaoUEDTest)上面，欢迎吐槽。","mobiledoc":null,"html":"<h2 id=\"\">引言</h2>\n\n<p>最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。</p>\n\n<p>中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 </p>\n\n<p>时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。</p>\n\n<p>不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。</p>\n\n<p>小测试是这样的：就是把以前的radio变成图片。</p>\n\n<p><img src=\"/content/images/2016/06/question.jpg\" alt=\"\" /></p>\n\n<p>码代码之前先分析一下：</p>\n\n<p>radio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。</p>\n\n<h2 id=\"\">实现</h2>\n\n<p>下面是具体实现：</p>\n\n<pre><code>&lt;form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'&gt;  \n    &lt;fieldset&gt;\n        &lt;legend&gt;MyValue&lt;/legend&gt;\n\n        &lt;div class = 'radioColorParent'&gt;\n            &lt;input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked&gt; 棕色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"&gt; 黄色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"&gt; 紫红色\n        &lt;/div&gt;\n\n\n    &amp;lt;div class = 'picColor'&amp;gt; \n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;                  \n          &amp;lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;   \n          &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n          &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n         &amp;lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&amp;gt;          \n         &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;input type=\"submit\" value='submit'&amp;gt;\n&amp;lt;/fieldset&amp;gt;\n\n\n&lt;/form&gt;  \n</code></pre>\n\n<p>以上就是实现基本的html代码，把几个为radio的input隐藏了。\n<code>css：</code></p>\n\n<pre><code>.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{  \n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{  \n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n</code></pre>\n\n<p>把radio的input隐藏了，然后设置点边框。 贴下js代码：</p>\n\n<pre><code>$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();  \nusercolorselect.init($('.picColorImgParent'));  \nusercolorselect.changeStyle();  \nusercolorselect.updateRadio();\n\n\n});\n</code></pre>\n\n<p>上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：</p>\n\n<p><img src=\"/content/images/2016/06/final.jpg\" alt=\"\" /></p>\n\n<p>兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~</p>\n\n<p>最后代码都放在了<a href=\"https://github.com/freestyle21/taobaoUEDTest\">github</a>上面，欢迎吐槽。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:22:08","created_by":1,"updated_at":"2016-06-16 15:26:43","updated_by":1,"published_at":"2016-06-16 15:26:43","published_by":1},{"id":5,"uuid":"e7a4abc9-8747-45c5-835a-020ab0aba8e2","title":"邂逅Jekyll","slug":"xie-hou-jekyll-2","markdown":"![](/content/images/2016/06/jekyll.png)\n\n### config.yml\n\n保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 \n\n比如里面写:\n```\ndescription:      \"freestyle21\\'s Blog\"\n```\n\n那么我们在源码中就可以通过下面这种方式去访问了：\n```\nsite.description\nincludes\n```\n该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。\n### layouts\n该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。\n\n### posts\n\n该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 `year-month-date-title.markdown`。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。\n\n### site\n\n这里是`Jekyll`用以存放最终代码生成站点的根路径位置。也许把它加到你的`.gitignore`列表中会是个不错的主意。这个文件夹是`Jekyll`自动生成的，所以我们一般不用管。\n\n### 其他文件/目录\n\n除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。\n\n## windows搭建Jekyll本地测试环境\n\n你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。\n\n不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 \n\n于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。\n\n看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：\n\n## 安装Jekyll\n\nJekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。\n\n下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)\n\n下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe\n\nRubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。\n\n解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令\n```\nRuby dk.rb init\nRuby dk.rn install\n```\nDevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。\n\n下面就可以安装Jekyll了：\n```\ngem install Jekyll\n```\n\n等待。。。这个时候不要关闭Git Bash。\n\n最后，我们可以检查一下安装Jekyll成功没有：\n\n```\nJekyll --version\n```\n\n如果输出下面的结果就说明我们成功了。。\n```\nJekyll 0.12.0\n```\n\n接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n`C:\\Users\\Administrator`\n这个目录下面：\n```\ngit clone git://github.com./freestyle21/freestyle21.github.com.git\n```\n然后进入刚才的目录里面：\n```\ncd freestyle21.github.com\n```\n执行：\n```\nJekyll --server --auto\n```\n如下如：\n```\nserverauto\n```\n最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。\n\n一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。\n\n现在记录一下遇到的错误，以后不要在这里耽误时间了。\n\n>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”\n\n编码问题，直接在path里面添加：`LCALL=enUS.UTF-8` 和 `LANG=en_US.UTF-8`然后重启或者注销。\n\n还是不行的话就将 `convertible.rb` 的第29行改为：\n```\nself.content = File.read(File.join(base, name), :encoding => \"utf-8\")\n ```\n>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown\n \n首先可以尝试一下更新`Pygments`， 把python里面的script目录加载path里面，然后就可以直接通过`easy_install Pygments`来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/06/jekyll.png\" alt=\"\" /></p>\n\n<h3 id=\"configyml\">config.yml</h3>\n\n<p>保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 </p>\n\n<p>比如里面写:</p>\n\n<pre><code>description:      \"freestyle21\\'s Blog\"  \n</code></pre>\n\n<p>那么我们在源码中就可以通过下面这种方式去访问了：</p>\n\n<pre><code>site.description  \nincludes  \n</code></pre>\n\n<p>该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。</p>\n\n<h3 id=\"layouts\">layouts</h3>\n\n<p>该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。</p>\n\n<h3 id=\"posts\">posts</h3>\n\n<p>该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 <code>year-month-date-title.markdown</code>。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。</p>\n\n<h3 id=\"site\">site</h3>\n\n<p>这里是<code>Jekyll</code>用以存放最终代码生成站点的根路径位置。也许把它加到你的<code>.gitignore</code>列表中会是个不错的主意。这个文件夹是<code>Jekyll</code>自动生成的，所以我们一般不用管。</p>\n\n<h3 id=\"\">其他文件/目录</h3>\n\n<p>除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。</p>\n\n<h2 id=\"windowsjekyll\">windows搭建Jekyll本地测试环境</h2>\n\n<p>你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。</p>\n\n<p>不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 </p>\n\n<p>于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。</p>\n\n<p>看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：</p>\n\n<h2 id=\"jekyll\">安装Jekyll</h2>\n\n<p>Jekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。</p>\n\n<p>下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)</p>\n\n<p>下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</p>\n\n<p>RubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。</p>\n\n<p>解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令</p>\n\n<pre><code>Ruby dk.rb init  \nRuby dk.rn install  \n</code></pre>\n\n<p>DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。</p>\n\n<p>下面就可以安装Jekyll了：</p>\n\n<pre><code>gem install Jekyll  \n</code></pre>\n\n<p>等待。。。这个时候不要关闭Git Bash。</p>\n\n<p>最后，我们可以检查一下安装Jekyll成功没有：</p>\n\n<pre><code>Jekyll --version  \n</code></pre>\n\n<p>如果输出下面的结果就说明我们成功了。。</p>\n\n<pre><code>Jekyll 0.12.0  \n</code></pre>\n\n<p>接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n<code>C:\\Users\\Administrator</code>\n这个目录下面：</p>\n\n<pre><code>git clone git://github.com./freestyle21/freestyle21.github.com.git  \n</code></pre>\n\n<p>然后进入刚才的目录里面：</p>\n\n<pre><code>cd freestyle21.github.com  \n</code></pre>\n\n<p>执行：</p>\n\n<pre><code>Jekyll --server --auto  \n</code></pre>\n\n<p>如下如：</p>\n\n<pre><code>serverauto  \n</code></pre>\n\n<p>最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。</p>\n\n<p>一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。</p>\n\n<p>现在记录一下遇到的错误，以后不要在这里耽误时间了。</p>\n\n<blockquote>\n  <p>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”</p>\n</blockquote>\n\n<p>编码问题，直接在path里面添加：<code>LCALL=enUS.UTF-8</code> 和 <code>LANG=en_US.UTF-8</code>然后重启或者注销。</p>\n\n<p>还是不行的话就将 <code>convertible.rb</code> 的第29行改为：\n<code>\nself.content = File.read(File.join(base, name), :encoding =&gt; \"utf-8\") <br />\n</code></p>\n\n<blockquote>\n  <p>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown</p>\n</blockquote>\n\n<p>首先可以尝试一下更新<code>Pygments</code>， 把python里面的script目录加载path里面，然后就可以直接通过<code>easy_install Pygments</code>来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:28:19","created_by":1,"updated_at":"2016-06-16 15:34:18","updated_by":1,"published_at":"2016-06-16 15:34:18","published_by":1},{"id":7,"uuid":"7982dcda-2a88-4e36-a91a-3dd60d99c89c","title":"从jQuery学细节","slug":"learn-from-jquery","markdown":"前言\n\n最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。\n\n![](/content/images/2016/06/john.png)\n\n看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~\n\n研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~\n\n现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。\n## jQuery的细节技巧\n\n### 巧用条件运算符\n```\ntrim: trim ?\n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n```\n \n这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：\n\n```\ndata = data === \"true\" ? true :\n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {}\n```\n多用点这种技巧，就不用满屏幕都是if & else 了。代码会变得简洁，轻巧。\n\n### jQuery的循环遍历技巧\n\n下面列出一些自己看出的、常见的、平时代码中常用的循环技巧\n\n1、\n```\n// 简单的for-in（事件） \nfor ( type in events ) { \n}\n```\n\n2、\n```\n// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j < l; j++ ) { \n}\n```\n3、\n```\n// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem; \nfor ( var i = 0; elems[i]; i++ ) { \n    elem = elems[i]; \n    // ... \n}\n```\n4、\n```\n// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j < eventType.length; j++ ) { \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i < results.length; i++ ) { \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n```\n这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！\n\n5、\n```\n// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j < eventType.length; j++ ) { \n}\n```\n6、\n```\n//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) { \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n```\n7、\n```\n// while检查下标i \nvar i = arr.length; \nwhile( i-- ) { \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n```\n通过闭包，返回前一作用域的参数\n```\n// 闭包。返回的函数保持对guid的引用。\nfunction a(){\n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();\n```\n一次实现多种方法\n```\nif ( rfxtypes.test(val) ) {\n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n```\n条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：\n\n```\njQuery.each([\"live\", \"die\"], function( i, name ) {\n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" && !types &&\n                    origSelector && origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n```\n一次性实现两个方法。。\n\n```\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length > 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n```\n通过each方法，实现n多方法。到此，除了惊叹还是惊叹。\n\n### 实例化jQuery对象\n\n先看代码：\n```\njQuery = function( selector, context ) {\n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n```\n这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;\n\n因此可以直接调用jQuery( selector, context )，没有必要使用new关键字\n\n还有一行代码如下：\n\n```\njQuery.fn.init.prototype = jQuery.fn = jQuery.prototype\n```\n\n所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。\n\n这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：\n\n```\n//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {\n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"<a>hello</a>\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError\n```\n在源码中，经常看到这样的代码：\n\n```\nargs = args || [];\n```\n\n这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。\n\n比如我们还可以看到这样的：\n\n```\nisArray: Array.isArray || function( obj ) {\n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;\n```\n \n在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架\n\n```\n(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n```\n \n### 结语\n\n以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~\n\n总之每看一次，都会有很大的收获，成长。\n\n最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。\n\n离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。\n","mobiledoc":null,"html":"<p>前言</p>\n\n<p>最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。</p>\n\n<p><img src=\"/content/images/2016/06/john.png\" alt=\"\" /></p>\n\n<p>看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~</p>\n\n<p>研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~</p>\n\n<p>现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。</p>\n\n<h2 id=\"jquery\">jQuery的细节技巧</h2>\n\n<h3 id=\"\">巧用条件运算符</h3>\n\n<pre><code>trim: trim ?  \n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n</code></pre>\n\n<p>这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：</p>\n\n<pre><code>data = data === \"true\" ? true :  \n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i &lt; max; i++ ) {}  \n</code></pre>\n\n<p>多用点这种技巧，就不用满屏幕都是if &amp; else 了。代码会变得简洁，轻巧。</p>\n\n<h3 id=\"jquery\">jQuery的循环遍历技巧</h3>\n\n<p>下面列出一些自己看出的、常见的、平时代码中常用的循环技巧</p>\n\n<p>1、  </p>\n\n<pre><code>// 简单的for-in（事件） \nfor ( type in events ) {  \n}\n</code></pre>\n\n<p>2、  </p>\n\n<pre><code>// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j &lt; l; j++ ) {  \n}\n</code></pre>\n\n<p>3、  </p>\n\n<pre><code>// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem;  \nfor ( var i = 0; elems[i]; i++ ) {  \n    elem = elems[i]; \n    // ... \n}\n</code></pre>\n\n<p>4、  </p>\n\n<pre><code>// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j &lt; eventType.length; j++ ) {  \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i &lt; results.length; i++ ) {  \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n</code></pre>\n\n<p>这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！</p>\n\n<p>5、  </p>\n\n<pre><code>// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j &lt; eventType.length; j++ ) {  \n}\n</code></pre>\n\n<p>6、  </p>\n\n<pre><code>//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) {  \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n</code></pre>\n\n<p>7、  </p>\n\n<pre><code>// while检查下标i \nvar i = arr.length;  \nwhile( i-- ) {  \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n</code></pre>\n\n<p>通过闭包，返回前一作用域的参数</p>\n\n<pre><code>// 闭包。返回的函数保持对guid的引用。\nfunction a(){  \n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();  \n</code></pre>\n\n<p>一次实现多种方法</p>\n\n<pre><code>if ( rfxtypes.test(val) ) {  \n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n</code></pre>\n\n<p>条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：</p>\n\n<pre><code>jQuery.each([\"live\", \"die\"], function( i, name ) {  \n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" &amp;&amp; !types &amp;&amp;\n                    origSelector &amp;&amp; origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n</code></pre>\n\n<p>一次性实现两个方法。。</p>\n\n<pre><code>jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +  \n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length &gt; 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n</code></pre>\n\n<p>通过each方法，实现n多方法。到此，除了惊叹还是惊叹。</p>\n\n<h3 id=\"jquery\">实例化jQuery对象</h3>\n\n<p>先看代码：</p>\n\n<pre><code>jQuery = function( selector, context ) {  \n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n</code></pre>\n\n<p>这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;</p>\n\n<p>因此可以直接调用jQuery( selector, context )，没有必要使用new关键字</p>\n\n<p>还有一行代码如下：</p>\n\n<pre><code>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype  \n</code></pre>\n\n<p>所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。</p>\n\n<p>这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：</p>\n\n<pre><code>//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {  \n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"&lt;a&gt;hello&lt;/a&gt;\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError  \n</code></pre>\n\n<p>在源码中，经常看到这样的代码：</p>\n\n<pre><code>args = args || [];  \n</code></pre>\n\n<p>这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。</p>\n\n<p>比如我们还可以看到这样的：</p>\n\n<pre><code>isArray: Array.isArray || function( obj ) {  \n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;  \n</code></pre>\n\n<p>在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架</p>\n\n<pre><code>(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n</code></pre>\n\n<h3 id=\"\">结语</h3>\n\n<p>以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~</p>\n\n<p>总之每看一次，都会有很大的收获，成长。</p>\n\n<p>最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。</p>\n\n<p>离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:51:22","created_by":1,"updated_at":"2016-06-22 00:14:20","updated_by":1,"published_at":"2016-06-17 15:26:30","published_by":1},{"id":8,"uuid":"9081bf24-12eb-41ec-becf-28b6ca9902e8","title":"浅谈JavaScript的语言特性","slug":"javascript-feature","markdown":"## 前言\n\n在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。\n\n本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下[权威指南](http://book.douban.com/subject/10549733)~\n\n参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：\n\n[http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/](http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/)\n\n[http://benalman.com/news/2010/11/immediately-invoked-function-expression/](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n[http://dmitrysoshnikov.com/ecmascript/javascript-the-core/](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)\n\n## 语言特性\n\n### 函数表达式\n\n先看代码段：\n\n```\nvar f = function foo(){\n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"\nf(); // \"function\"</pre>\n```\n\n这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。\n\n### json \n\n很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。\n\nJSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。\n\n`{ \"prop\": \"val\" }` 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。\n\n如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。\n\n```\n// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };\n```\n\n还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。\n\n老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。\n\n### 原型 \n\n```\nfunction Animal (){ \n// ...\n}\nfunction cat (){ \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。\ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;\n```\n如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：\n\n```\nfunction A() {}\n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // false!\n```\n\n让我们一起看下MDN上关于constructor的 [解释](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor)\n\n```\nprototype：Returns a reference to the Object function that created the instance's prototype.\n```\n因此，对函数的原型引用需要手工恢复：\n\n```\nfunction A() {}\n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // true\n```\n\n然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。\n\n```\nfunction A() {}\nA.prototype.x = 10;\n\nvar a = new A();\nalert(a.x); // 10\n\nA.prototype = {\n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10\nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20\nalert(b.y) // 30\n\n```\n\n因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。\n\n这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。\n\n### 变量对象 \n\n在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。\n\n活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：\n\n```\nfunction foo(x, y, z) {\n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n```\n\n当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：\n\n1. 函数的所有形参(如果我们是在函数执行上下文中)；\n2. 所有函数声明(FunctionDeclaration, FD)；\n3. 所有变量声明(var, VariableDeclaration)；\n\n另一个经典例子：\n\n```\nalert(x); // function\nvar x = 10;\nalert(x); // 10\nx = 20;\nfunction x() {};\nalert(x); // 20\n```\n\n根据规范函数声明是在当进入上下文时填入的; \n\n在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，**变量声明在顺序上跟在函数声明和形式参数声明之后**，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。\n\n变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。\n\n```\na = 10;\nalert(window.a); // 10\nalert(delete a); // true\nalert(window.a); // undefined\n\nvar b = 20;\nalert(window.b); // 20\nalert(delete b); // false\nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10\nalert(b); // 全局变量 \"b\" 没有声明.\n```\n\n### this\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。\n\n```\n(function () {\n    alert(this); // null =&gt; global\n})();\n```\n\n在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。\n\n```\nvar foo = {\n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&gt; foo\n(foo.bar)(); // Reference, OK =&gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n```\n\n问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。\n\n第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。\n\n在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。\n\n第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。\n\n第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。\n\n正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。\n\n```\nfunction foo() {\n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n```\n\n活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。\n\n这里我们再次回到上面描述的例子，this设置为全局对象。\n\n### 作用域链\n\n通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。\n\n一个重要的例外，它涉及到通过函数构造函数创建的函数。\n```\nvar x = 10;\nfunction foo() {\n\tvar y = 20;\n\tfunction barFD() { // 函数声明\n\t    alert(x);\n\t    alert(y);\n\t}\n\tvar barFn = Function('alert(x); alert(y);');\n\tbarFD(); // 10, 20\n\tbarFn(); // 10, \"y\" is not defined\n}\nfoo();</pre><p>还有：</p><pre class=\"brush:javascript\">var x = 10, y = 10;\nwith ({x: 20}) {\n\tvar x = 30, y = 30;\n\t//这里的 x = 30 覆盖了x = 20；\n\talert(x); // 30\n\talert(y); // 30\n}\n\nalert(x); // 10\nalert(y); // 30\n```\n在进入上下文时发生了什么？\n\n标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：\n```\nx = 10, y = 10;\n```\n对象`{x:20}`添加到作用域的前端;\n\n在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;\n\n在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;\n\n同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;\n\n此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。\n\n在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。\n\n### 函数\n\n关于圆括号的问题\n\n让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。\n\n按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：\n\n```\nfunction () {\n...\n}();\n\n// 即便有名称\n\nfunction foo() {\n...\n}();\n```\n\n我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。\n\n如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。\n\n第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：\n\n```\n// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数\nfunction foo(x) {\n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10\n```\n创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）\n\n```\n(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n```\n上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。\n\n注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。\n```\nvar foo = {\n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'\n```\n就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。\n\n因此，”关于圆括号”问题完整的答案如下：\n\n当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。\n\n由变量：\n```\nfunction testFn() {\n\tvar localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n\tfunction innerFn(innerParam) {\n\t\talert(innerParam + localVar);\n\t}\n\treturn innerFn;\n}\n\n```\n闭包的静态作用域：\n```\nvar z = 10;\n\nfunction foo() {\n    alert(z);\n}</pre><pre class=\"brush:javascript\">foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n\tvar z = 20;\n\tfoo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n\tvar z = 30;\n\tfunArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n```\n**理论**：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。\n\n**从实践角度**：以下函数才算是闭包：\n\n即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n\n在代码中引用了自由变量\n\n## 最后： \n\nECMAScript是一种面向对象语言，支持基于原型的委托式继承。","mobiledoc":null,"html":"<h2 id=\"\">前言</h2>\n\n<p>在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。</p>\n\n<p>本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下<a href=\"http://book.douban.com/subject/10549733\">权威指南</a>~</p>\n\n<p>参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：</p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/\">http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/</a></p>\n\n<p><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\">http://benalman.com/news/2010/11/immediately-invoked-function-expression/</a></p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>\n\n<h2 id=\"\">语言特性</h2>\n\n<h3 id=\"\">函数表达式</h3>\n\n<p>先看代码段：</p>\n\n<pre><code>var f = function foo(){  \n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"  \nf(); // \"function\"&lt;/pre&gt;  \n</code></pre>\n\n<p>这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。</p>\n\n<h3 id=\"json\">json</h3>\n\n<p>很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。</p>\n\n<p>JSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。</p>\n\n<p><code>{ \"prop\": \"val\" }</code> 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。</p>\n\n<p>如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。</p>\n\n<pre><code>// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };  \n</code></pre>\n\n<p>还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。</p>\n\n<p>老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。</p>\n\n<h3 id=\"\">原型</h3>\n\n<pre><code>function Animal (){  \n// ...\n}\nfunction cat (){  \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。  \ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;  \n</code></pre>\n\n<p>如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // false!  \n</code></pre>\n\n<p>让我们一起看下MDN上关于constructor的 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor\">解释</a></p>\n\n<pre><code>prototype：Returns a reference to the Object function that created the instance's prototype.  \n</code></pre>\n\n<p>因此，对函数的原型引用需要手工恢复：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // true  \n</code></pre>\n\n<p>然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。</p>\n\n<pre><code>function A() {}  \nA.prototype.x = 10;\n\nvar a = new A();  \nalert(a.x); // 10\n\nA.prototype = {  \n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10  \nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20  \nalert(b.y) // 30\n</code></pre>\n\n<p>因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。</p>\n\n<p>这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。</p>\n\n<h3 id=\"\">变量对象</h3>\n\n<p>在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。</p>\n\n<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：</p>\n\n<pre><code>function foo(x, y, z) {  \n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n</code></pre>\n\n<p>当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：</p>\n\n<ol>\n<li>函数的所有形参(如果我们是在函数执行上下文中)；  </li>\n<li>所有函数声明(FunctionDeclaration, FD)；  </li>\n<li>所有变量声明(var, VariableDeclaration)；</li>\n</ol>\n\n<p>另一个经典例子：</p>\n\n<pre><code>alert(x); // function  \nvar x = 10;  \nalert(x); // 10  \nx = 20;  \nfunction x() {};  \nalert(x); // 20  \n</code></pre>\n\n<p>根据规范函数声明是在当进入上下文时填入的; </p>\n\n<p>在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，<strong>变量声明在顺序上跟在函数声明和形式参数声明之后</strong>，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。</p>\n\n<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。</p>\n\n<pre><code>a = 10;  \nalert(window.a); // 10  \nalert(delete a); // true  \nalert(window.a); // undefined\n\nvar b = 20;  \nalert(window.b); // 20  \nalert(delete b); // false  \nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10  \nalert(b); // 全局变量 \"b\" 没有声明.  \n</code></pre>\n\n<h3 id=\"this\">this</h3>\n\n<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。</p>\n\n<pre><code>(function () {\n    alert(this); // null =&amp;gt; global\n})();\n</code></pre>\n\n<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。</p>\n\n<pre><code>var foo = {  \n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&amp;gt; foo  \n(foo.bar)(); // Reference, OK =&amp;gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n</code></pre>\n\n<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。</p>\n\n<p>第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。</p>\n\n<p>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。</p>\n\n<p>第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。</p>\n\n<p>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。</p>\n\n<p>正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。</p>\n\n<pre><code>function foo() {  \n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n</code></pre>\n\n<p>活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。</p>\n\n<p>这里我们再次回到上面描述的例子，this设置为全局对象。</p>\n\n<h3 id=\"\">作用域链</h3>\n\n<p>通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。</p>\n\n<p>一个重要的例外，它涉及到通过函数构造函数创建的函数。</p>\n\n<pre><code>var x = 10;  \nfunction foo() {  \n    var y = 20;\n    function barFD() { // 函数声明\n        alert(x);\n        alert(y);\n    }\n    var barFn = Function('alert(x); alert(y);');\n    barFD(); // 10, 20\n    barFn(); // 10, \"y\" is not defined\n}\nfoo();&lt;/pre&gt;&lt;p&gt;还有：&lt;/p&gt;&lt;pre class=\"brush:javascript\"&gt;var x = 10, y = 10;  \nwith ({x: 20}) {  \n    var x = 30, y = 30;\n    //这里的 x = 30 覆盖了x = 20；\n    alert(x); // 30\n    alert(y); // 30\n}\n\nalert(x); // 10  \nalert(y); // 30  \n</code></pre>\n\n<p>在进入上下文时发生了什么？</p>\n\n<p>标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：</p>\n\n<pre><code>x = 10, y = 10;  \n</code></pre>\n\n<p>对象<code>{x:20}</code>添加到作用域的前端;</p>\n\n<p>在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;</p>\n\n<p>在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;</p>\n\n<p>同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;</p>\n\n<p>此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。</p>\n\n<p>在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。</p>\n\n<h3 id=\"\">函数</h3>\n\n<p>关于圆括号的问题</p>\n\n<p>让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。</p>\n\n<p>按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：</p>\n\n<pre><code>function () {  \n...\n}();\n\n// 即便有名称\n\nfunction foo() {  \n...\n}();\n</code></pre>\n\n<p>我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。</p>\n\n<p>如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。</p>\n\n<p>第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：</p>\n\n<pre><code>// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数  \nfunction foo(x) {  \n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10  \n</code></pre>\n\n<p>创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）</p>\n\n<pre><code>(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n</code></pre>\n\n<p>上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。</p>\n\n<p>注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。</p>\n\n<pre><code>var foo = {  \n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'  \n</code></pre>\n\n<p>就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。</p>\n\n<p>因此，”关于圆括号”问题完整的答案如下：</p>\n\n<p>当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。</p>\n\n<p>由变量：</p>\n\n<pre><code>function testFn() {  \n    var localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n    function innerFn(innerParam) {\n        alert(innerParam + localVar);\n    }\n    return innerFn;\n}\n</code></pre>\n\n<p>闭包的静态作用域：</p>\n\n<pre><code>var z = 10;\n\nfunction foo() {  \n    alert(z);\n}&lt;/pre&gt;&lt;pre class=\"brush:javascript\"&gt;foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n    var z = 20;\n    foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n    var z = 30;\n    funArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n</code></pre>\n\n<p><strong>理论</strong>：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。</p>\n\n<p><strong>从实践角度</strong>：以下函数才算是闭包：</p>\n\n<p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>\n\n<p>在代码中引用了自由变量</p>\n\n<h2 id=\"\">最后：</h2>\n\n<p>ECMAScript是一种面向对象语言，支持基于原型的委托式继承。</p>","image":"","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"浅谈JavaScript的语言特性","meta_description":"浅谈JavaScript的语言特性，作用域、上下文、闭包、函数，前端进阶。","author_id":1,"created_at":"2016-06-17 15:40:57","created_by":1,"updated_at":"2016-06-22 00:09:07","updated_by":1,"published_at":"2016-06-17 16:00:00","published_by":1}],"users":[{"id":1,"uuid":"60e11940-1a1a-4cbe-8482-382877112b30","name":"qubaoming","slug":"qubaoming","password":"$2a$10$3zEG9pqoPAEmVF3ffvH8l.rCbFqMIlQA5T2A7wl0rUpPd7QrgPcrC","email":"675861708@qq.com","image":null,"cover":"/content/images/2016/06/4-pic.jpg","bio":null,"website":null,"location":null,"facebook":null,"twitter":null,"accessibility":null,"status":"active","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_login":"2016-06-25 03:42:56","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-25 03:42:56","updated_by":1}],"roles":[{"id":1,"uuid":"e102fbba-b335-4584-8fd2-ec34fdff4ddf","name":"Administrator","description":"Administrators","created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-13 15:39:49","updated_by":1},{"id":2,"uuid":"5ae7b85e-5d5e-4bee-b088-b77f73463958","name":"Editor","description":"Editors","created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-13 15:39:49","updated_by":1},{"id":3,"uuid":"f75d65d5-11cc-437c-a54e-ae89c7cd6c99","name":"Author","description":"Authors","created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-13 15:39:49","updated_by":1},{"id":4,"uuid":"2ce28adf-4d8a-43f5-bbe7-81168e09b8b9","name":"Owner","description":"Blog Owner","created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":1,"uuid":"857e4a82-5c33-4293-8d3a-061388eb16c5","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":2,"uuid":"b0160997-e1cc-45d4-b49f-2d471bc5e4cb","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":3,"uuid":"6a137311-316c-4abb-a2d8-cb5c978fa92a","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":4,"uuid":"0bccc7c9-6987-4c89-b6f6-a542f97cce44","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":5,"uuid":"d76e473b-c088-4b9f-9e63-289987a7e9b2","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":6,"uuid":"b1c134c9-a393-449c-ab71-76f7137aa5c0","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":7,"uuid":"7304d337-ff57-4005-83fc-4c69614f5cdb","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":8,"uuid":"ae47ce96-f265-474c-86c6-35dc2633fcd8","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":9,"uuid":"fc0d1c08-d3e5-4d48-b137-b0335cc86500","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":10,"uuid":"1af02053-f68a-4d72-931a-8816ee2bd1d7","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":11,"uuid":"3513640f-119a-4990-a95e-f042690942cc","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":12,"uuid":"4fc2c1bb-f6b7-4b61-9efc-5306cd9faf71","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":13,"uuid":"af73b021-4817-42e0-a9c8-f39ac3447f17","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":14,"uuid":"47d6ccde-eccf-4b81-b5bc-ba45af20eb7f","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":15,"uuid":"be27c7bb-8ff1-443f-ace8-68db73ed6978","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":16,"uuid":"6715c4e4-44b5-4606-be24-ccf7b1d38db9","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":17,"uuid":"7f801e77-f855-46fd-b467-b0e41c24bf08","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":18,"uuid":"6b62f7e8-425a-4e6a-b7ed-2bd82b588b8e","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":19,"uuid":"fa444908-1f95-423d-910d-b15744f2385c","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":20,"uuid":"3d36d2b7-becd-4b9e-ab6a-81e8dc89a602","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":21,"uuid":"a36ab8d5-2ce6-4280-88a4-1690198c1c40","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":22,"uuid":"e0fccef7-f24a-49fb-abdf-c58d2d27c7bf","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":23,"uuid":"027971fa-f381-4cab-bd3f-d0f95ed0e9b4","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":24,"uuid":"2d8c53bb-893e-4dfa-ba15-8a81b7848456","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":25,"uuid":"6d19e534-1326-401c-aea5-3c3627245e9d","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":26,"uuid":"df61ecab-9f55-4c13-9794-f4df000400d8","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":27,"uuid":"423c98b3-c7d5-4c72-93c8-e63325eed170","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":28,"uuid":"b58818ca-f793-47a8-9844-71a79bd96ab7","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":29,"uuid":"83825023-43bf-4303-bec1-214946bb9659","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":30,"uuid":"e6d39550-ceda-4b02-a171-d8752761a6a7","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":31,"uuid":"72ccf426-fd15-450d-9479-c05efd93d312","name":"Browse clients","object_type":"client","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":32,"uuid":"47dc8e38-4560-4001-9f61-64304098dd32","name":"Read clients","object_type":"client","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":33,"uuid":"1582cb6a-e902-4b7c-9da4-179444fdc2f8","name":"Edit clients","object_type":"client","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":34,"uuid":"a8cce327-9627-4972-8e19-5dc65d000049","name":"Add clients","object_type":"client","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":35,"uuid":"85ade5b7-8325-481f-9797-7dc961232f5c","name":"Delete clients","object_type":"client","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":36,"uuid":"2eac58db-515f-48b3-9ad3-31a0a8858bca","name":"Browse subscribers","object_type":"subscriber","action_type":"browse","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":37,"uuid":"445c2761-664d-4bab-9aa6-404f181fd551","name":"Read subscribers","object_type":"subscriber","action_type":"read","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":38,"uuid":"e0e81af1-879d-4d57-bd50-22fbdcf06b52","name":"Edit subscribers","object_type":"subscriber","action_type":"edit","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":39,"uuid":"ccf046c4-e3cf-43e2-bd9a-960967cd8468","name":"Add subscribers","object_type":"subscriber","action_type":"add","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1},{"id":40,"uuid":"66b0e543-a0f7-4853-b771-5e41bbc3488f","name":"Delete subscribers","object_type":"subscriber","action_type":"destroy","object_id":null,"created_at":"2016-06-13 15:39:50","created_by":1,"updated_at":"2016-06-13 15:39:50","updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":1,"permission_id":31},{"id":32,"role_id":1,"permission_id":32},{"id":33,"role_id":1,"permission_id":33},{"id":34,"role_id":1,"permission_id":34},{"id":35,"role_id":1,"permission_id":35},{"id":36,"role_id":1,"permission_id":36},{"id":37,"role_id":1,"permission_id":37},{"id":38,"role_id":1,"permission_id":38},{"id":39,"role_id":1,"permission_id":39},{"id":40,"role_id":1,"permission_id":40},{"id":41,"role_id":2,"permission_id":8},{"id":42,"role_id":2,"permission_id":9},{"id":43,"role_id":2,"permission_id":10},{"id":44,"role_id":2,"permission_id":11},{"id":45,"role_id":2,"permission_id":12},{"id":46,"role_id":2,"permission_id":13},{"id":47,"role_id":2,"permission_id":14},{"id":48,"role_id":2,"permission_id":16},{"id":49,"role_id":2,"permission_id":17},{"id":50,"role_id":2,"permission_id":18},{"id":51,"role_id":2,"permission_id":19},{"id":52,"role_id":2,"permission_id":20},{"id":53,"role_id":2,"permission_id":21},{"id":54,"role_id":2,"permission_id":24},{"id":55,"role_id":2,"permission_id":25},{"id":56,"role_id":2,"permission_id":26},{"id":57,"role_id":2,"permission_id":27},{"id":58,"role_id":2,"permission_id":28},{"id":59,"role_id":2,"permission_id":29},{"id":60,"role_id":2,"permission_id":30},{"id":61,"role_id":2,"permission_id":31},{"id":62,"role_id":2,"permission_id":32},{"id":63,"role_id":2,"permission_id":33},{"id":64,"role_id":2,"permission_id":34},{"id":65,"role_id":2,"permission_id":35},{"id":66,"role_id":2,"permission_id":39},{"id":67,"role_id":3,"permission_id":8},{"id":68,"role_id":3,"permission_id":9},{"id":69,"role_id":3,"permission_id":11},{"id":70,"role_id":3,"permission_id":13},{"id":71,"role_id":3,"permission_id":14},{"id":72,"role_id":3,"permission_id":16},{"id":73,"role_id":3,"permission_id":17},{"id":74,"role_id":3,"permission_id":18},{"id":75,"role_id":3,"permission_id":20},{"id":76,"role_id":3,"permission_id":24},{"id":77,"role_id":3,"permission_id":25},{"id":78,"role_id":3,"permission_id":30},{"id":79,"role_id":3,"permission_id":31},{"id":80,"role_id":3,"permission_id":32},{"id":81,"role_id":3,"permission_id":33},{"id":82,"role_id":3,"permission_id":34},{"id":83,"role_id":3,"permission_id":35},{"id":84,"role_id":3,"permission_id":39}],"permissions_apps":[],"settings":[{"id":1,"uuid":"dc34682a-7421-4b14-885e-f17c379f1e29","key":"databaseVersion","value":"006","type":"core","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-13 15:39:52","updated_by":1},{"id":2,"uuid":"a5a5422b-9e08-4d7c-8faf-172264a6e37b","key":"dbHash","value":"93aaed65-992f-4b7a-8729-477cb6a7e891","type":"core","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-13 15:39:52","updated_by":1},{"id":3,"uuid":"0eb28659-4181-4888-a5c9-8ad6a95fd56c","key":"nextUpdateCheck","value":"1466912573","type":"core","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-25 03:42:53","updated_by":1},{"id":4,"uuid":"f9366001-db69-4307-a026-237b3323f3a9","key":"displayUpdateNotification","value":"0.5.0","type":"core","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-25 03:42:53","updated_by":1},{"id":5,"uuid":"30ba4926-5aad-4a47-ae1c-a14e53f8ab2e","key":"migrations","value":"{}","type":"core","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-13 15:39:52","updated_by":1},{"id":6,"uuid":"7a7b204b-5afc-480c-9855-8df0c7a2047f","key":"title","value":"qubaoming's home","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":7,"uuid":"1696a30e-f689-45b5-aa20-135771a93df9","key":"description","value":"The Road To Modern F2eer.","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":8,"uuid":"409d0747-8a49-4eb4-abde-09ba93fee449","key":"logo","value":"/content/images/2016/06/1.jpg","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":9,"uuid":"53a8c91a-7256-4e3b-8a90-be1e2cfce682","key":"cover","value":"","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":10,"uuid":"d2a08366-12da-4ff2-acbd-3e108b61693f","key":"defaultLang","value":"en_US","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":11,"uuid":"fcbc9cf0-c05b-4d1e-86d5-565d9eb3a169","key":"postsPerPage","value":"5","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":12,"uuid":"a2136a36-b869-4161-805c-82aa7b9eb2db","key":"activeTimezone","value":"Etc/UTC","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":13,"uuid":"6d6df8e2-f787-4d55-85ef-89cfab57e046","key":"forceI18n","value":"true","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":14,"uuid":"75c4531c-71a5-4293-8daf-4bf2a4b1befe","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":15,"uuid":"900bb096-d5e8-45e5-9b26-d94506d65af5","key":"ghost_head","value":"","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":16,"uuid":"e3225c89-b645-4c20-8066-ec638b6a4dfa","key":"ghost_foot","value":"","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":17,"uuid":"56595894-0461-4c53-a70e-197d28cc2b4f","key":"facebook","value":"","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":18,"uuid":"072038d4-c515-4527-8109-53117575b10f","key":"twitter","value":"","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":19,"uuid":"5563d281-544d-48a5-b714-e92be92831d6","key":"labs","value":"{}","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":20,"uuid":"c12e2d90-44af-4ef0-8cf9-ad3dae46279c","key":"navigation","value":"[{\"label\":\"主页\",\"url\":\"/\"},{\"label\":\"前端\",\"url\":\"/javascript/\"},{\"label\":\"拳击\",\"url\":\"/boxing/\"},{\"label\":\"篮球\",\"url\":\"/basekebal/\"},{\"label\":\"关于\",\"url\":\"/about/\"}]","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":21,"uuid":"0b8d9029-a8d0-4fce-8b18-f1dc60576b04","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":22,"uuid":"190cbbde-9092-4133-bd70-d96ecf4d8125","key":"activeApps","value":"[]","type":"app","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-13 15:39:52","updated_by":1},{"id":23,"uuid":"cf9bdaef-44cd-4a65-a53b-2ab650b9c47c","key":"installedApps","value":"[]","type":"app","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-25 01:52:19","updated_by":1},{"id":24,"uuid":"c0d13749-35f6-4ead-87c0-89a40471bf25","key":"isPrivate","value":"false","type":"private","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":25,"uuid":"30fc7c74-e5f3-42f5-a4f1-23b86399c044","key":"password","value":"","type":"private","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1},{"id":26,"uuid":"2ec2a037-b9ec-413f-a15b-91c54aac3f77","key":"activeTheme","value":"casper","type":"theme","created_at":"2016-06-13 15:39:52","created_by":1,"updated_at":"2016-06-22 00:16:52","updated_by":1}],"tags":[{"id":1,"uuid":"04385e26-bb2c-446c-a140-cb0fc3c54c77","name":"Getting Started","slug":"getting-started","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-13 15:39:49","updated_by":1},{"id":2,"uuid":"02b7b00f-e80b-44c7-ac8b-48583ca53b94","name":"javascript","slug":"javascript","description":"","image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-06-22 00:04:50","created_by":1,"updated_at":"2016-06-22 00:13:15","updated_by":1}],"posts_tags":[{"id":1,"post_id":1,"tag_id":1,"sort_order":0},{"id":2,"post_id":8,"tag_id":2,"sort_order":0},{"id":3,"post_id":7,"tag_id":2,"sort_order":0}],"apps":[],"app_settings":[],"app_fields":[],"subscribers":[]}}]}