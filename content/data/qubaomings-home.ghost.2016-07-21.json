{"meta":{"exported_on":1469108172420,"version":"006"},"data":{"posts":[{"id":38,"uuid":"f6359f78-158b-45f0-bb06-bd365bf27708","title":"关于js修改三种css样式的方法","slug":"test","markdown":"晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。\n\n## 遇到的问题是：\n最开始在.css文件里面设置了图片的`position：absolute；`, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。\n\n之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。\n\n现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。\n\n## 深入\n怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。\n```\nfunction getDefaultStyle(obj,attribute){\n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n```\n或者：\n```\nfunction getDefault(obj){\n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n```\n例子：\n\n使用javascript更改某个css class的属性:\n```\n.orig {\n    display: none;\n}\n```\n你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：\n```\ndocument.styleSheets[0].rules[0].style.display = \"inline\";\n```\n在firefox里：\n```\ndocument.styleSheets[0].cssRules[0].style.display = \"inline\";\n```\n讨论： 可以做一个函数来搜索特定名字的style对象：\n```\nfunction getstyle(sname) {\n    for (var i=0;i< document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j< rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n```\n然后只要：\n```\ngetstyle(\".orig\").display = \"inline\";\n```\n## 总结：\n前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。\n\n在ie和firefox里面确实可以实现，不过我们不提倡。\n\n在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。\n\n所以，最好的方式还是直接修改dom里面的属性。\n\n弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。","mobiledoc":null,"html":"<p>晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。</p>\n\n<h2 id=\"\">遇到的问题是：</h2>\n\n<p>最开始在.css文件里面设置了图片的<code>position：absolute；</code>, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。</p>\n\n<p>之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。</p>\n\n<p>现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。  </p>\n\n<pre><code>function getDefaultStyle(obj,attribute){  \n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n</code></pre>\n\n<p>或者：</p>\n\n<pre><code>function getDefault(obj){  \n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n</code></pre>\n\n<p>例子：</p>\n\n<p>使用javascript更改某个css class的属性:</p>\n\n<pre><code>.orig {\n    display: none;\n}\n</code></pre>\n\n<p>你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：</p>\n\n<pre><code>document.styleSheets[0].rules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>在firefox里：</p>\n\n<pre><code>document.styleSheets[0].cssRules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>讨论： 可以做一个函数来搜索特定名字的style对象：</p>\n\n<pre><code>function getstyle(sname) {  \n    for (var i=0;i&lt; document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j&lt; rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>然后只要：</p>\n\n<pre><code>getstyle(\".orig\").display = \"inline\";  \n</code></pre>\n\n<h2 id=\"\">总结：</h2>\n\n<p>前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。</p>\n\n<p>在ie和firefox里面确实可以实现，不过我们不提倡。</p>\n\n<p>在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。</p>\n\n<p>所以，最好的方式还是直接修改dom里面的属性。</p>\n\n<p>弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-14 15:29:43","created_by":1,"updated_at":"2016-06-29 00:37:40","updated_by":1,"published_at":"2012-10-22 15:30:00","published_by":1},{"id":39,"uuid":"2f69b803-fcce-494d-a7dd-32380a856a75","title":"学会使用chrome的F12","slug":"learn-chrome-f12","markdown":"学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~\n\n用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。\n\n折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）\n\n## Network工具\nchrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。\n \n![](/content/images/2016/06/network1.jpg)\n \n![](/content/images/2016/06/network2.jpg)\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。\n\n## Timeline\n注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：\n\n![](/content/images/2016/06/timeline.jpg)\n在上面点击后再点击红色的圆圈就可以了。\n## Profiles\n\n![](/content/images/2016/06/profile-1.jpg)\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU）\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 \n\n后面的学会了在更新~\n","mobiledoc":null,"html":"<p>学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~</p>\n\n<p>用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。</p>\n\n<p>折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）</p>\n\n<h2 id=\"network\">Network工具</h2>\n\n<p>chrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。</p>\n\n<p><img src=\"/content/images/2016/06/network1.jpg\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2016/06/network2.jpg\" alt=\"\" />\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。</p>\n\n<h2 id=\"timeline\">Timeline</h2>\n\n<p>注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：</p>\n\n<p><img src=\"/content/images/2016/06/timeline.jpg\" alt=\"\" />\n在上面点击后再点击红色的圆圈就可以了。</p>\n\n<h2 id=\"profiles\">Profiles</h2>\n\n<p><img src=\"/content/images/2016/06/profile-1.jpg\" alt=\"\" />\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU） <br />\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 </p>\n\n<p>后面的学会了在更新~</p>","image":"","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"学习chrome的F12","meta_description":"本文介绍在前端学习工作中，使用到的chrome 控制台的一些调试方法，包括Network工具、timeline、Profiles等。","author_id":1,"created_at":"2016-06-16 15:14:27","created_by":1,"updated_at":"2016-06-29 00:35:47","updated_by":1,"published_at":"2012-12-15 15:21:00","published_by":1},{"id":40,"uuid":"4d6da924-1e41-4473-bd73-de3078d5da99","title":"淘宝UED的前端招聘测试题","slug":"taobao-f2e-test","markdown":"## 引言\n\n最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。\n\n中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 \n\n时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。\n\n不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。\n\n小测试是这样的：就是把以前的radio变成图片。\n\n![](/content/images/2016/06/question.jpg)\n\n码代码之前先分析一下：\n\nradio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。\n\n## 实现\n\n下面是具体实现：\n```\n<form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'>\n    <fieldset>\n        <legend>MyValue</legend>\n\n        <div class = 'radioColorParent'>\n            <input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked> 棕色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"> 黄色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"> 紫红色\n        </div>\n\n\n    &lt;div class = 'picColor'&gt; \n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;                  \n          &lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;   \n          &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n          &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n         &lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&gt;          \n         &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;input type=\"submit\" value='submit'&gt;\n&lt;/fieldset&gt;\n\n\n</form>\n```\n \n以上就是实现基本的html代码，把几个为radio的input隐藏了。\n`css：`\n```\n.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{\n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{\n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n```\n把radio的input隐藏了，然后设置点边框。 贴下js代码：\n```\n$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();\nusercolorselect.init($('.picColorImgParent'));\nusercolorselect.changeStyle();\nusercolorselect.updateRadio();\n\n\n});\n```\n上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：\n\n![](/content/images/2016/06/final.jpg)\n\n兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~\n\n最后代码都放在了[github](https://github.com/freestyle21/taobaoUEDTest)上面，欢迎吐槽。","mobiledoc":null,"html":"<h2 id=\"\">引言</h2>\n\n<p>最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。</p>\n\n<p>中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 </p>\n\n<p>时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。</p>\n\n<p>不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。</p>\n\n<p>小测试是这样的：就是把以前的radio变成图片。</p>\n\n<p><img src=\"/content/images/2016/06/question.jpg\" alt=\"\" /></p>\n\n<p>码代码之前先分析一下：</p>\n\n<p>radio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。</p>\n\n<h2 id=\"\">实现</h2>\n\n<p>下面是具体实现：</p>\n\n<pre><code>&lt;form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'&gt;  \n    &lt;fieldset&gt;\n        &lt;legend&gt;MyValue&lt;/legend&gt;\n\n        &lt;div class = 'radioColorParent'&gt;\n            &lt;input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked&gt; 棕色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"&gt; 黄色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"&gt; 紫红色\n        &lt;/div&gt;\n\n\n    &amp;lt;div class = 'picColor'&amp;gt; \n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;                  \n          &amp;lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;   \n          &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n          &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n         &amp;lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&amp;gt;          \n         &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;input type=\"submit\" value='submit'&amp;gt;\n&amp;lt;/fieldset&amp;gt;\n\n\n&lt;/form&gt;  \n</code></pre>\n\n<p>以上就是实现基本的html代码，把几个为radio的input隐藏了。\n<code>css：</code></p>\n\n<pre><code>.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{  \n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{  \n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n</code></pre>\n\n<p>把radio的input隐藏了，然后设置点边框。 贴下js代码：</p>\n\n<pre><code>$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();  \nusercolorselect.init($('.picColorImgParent'));  \nusercolorselect.changeStyle();  \nusercolorselect.updateRadio();\n\n\n});\n</code></pre>\n\n<p>上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：</p>\n\n<p><img src=\"/content/images/2016/06/final.jpg\" alt=\"\" /></p>\n\n<p>兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~</p>\n\n<p>最后代码都放在了<a href=\"https://github.com/freestyle21/taobaoUEDTest\">github</a>上面，欢迎吐槽。</p>","image":"/content/images/2016/06/c.jpeg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:22:08","created_by":1,"updated_at":"2016-06-29 00:33:44","updated_by":1,"published_at":"2013-01-15 15:26:00","published_by":1},{"id":41,"uuid":"e7a4abc9-8747-45c5-835a-020ab0aba8e2","title":"邂逅Jekyll","slug":"learn-jekyll","markdown":"![](/content/images/2016/06/jekyll.png)\n\n### config.yml\n\n保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 \n\n比如里面写:\n```\ndescription:      \"freestyle21\\'s Blog\"\n```\n\n那么我们在源码中就可以通过下面这种方式去访问了：\n```\nsite.description\nincludes\n```\n该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。\n### layouts\n该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。\n\n### posts\n\n该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 `year-month-date-title.markdown`。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。\n\n### site\n\n这里是`Jekyll`用以存放最终代码生成站点的根路径位置。也许把它加到你的`.gitignore`列表中会是个不错的主意。这个文件夹是`Jekyll`自动生成的，所以我们一般不用管。\n\n### 其他文件/目录\n\n除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。\n\n## windows搭建Jekyll本地测试环境\n\n你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。\n\n不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 \n\n于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。\n\n看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：\n\n## 安装Jekyll\n\nJekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。\n\n下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)\n\n下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe\n\nRubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。\n\n解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令\n```\nRuby dk.rb init\nRuby dk.rn install\n```\nDevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。\n\n下面就可以安装Jekyll了：\n```\ngem install Jekyll\n```\n\n等待。。。这个时候不要关闭Git Bash。\n\n最后，我们可以检查一下安装Jekyll成功没有：\n\n```\nJekyll --version\n```\n\n如果输出下面的结果就说明我们成功了。。\n```\nJekyll 0.12.0\n```\n\n接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n`C:\\Users\\Administrator`\n这个目录下面：\n```\ngit clone git://github.com./freestyle21/freestyle21.github.com.git\n```\n然后进入刚才的目录里面：\n```\ncd freestyle21.github.com\n```\n执行：\n```\nJekyll --server --auto\n```\n如下如：\n```\nserverauto\n```\n最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。\n\n一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。\n\n现在记录一下遇到的错误，以后不要在这里耽误时间了。\n\n>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”\n\n编码问题，直接在path里面添加：`LCALL=enUS.UTF-8` 和 `LANG=en_US.UTF-8`然后重启或者注销。\n\n还是不行的话就将 `convertible.rb` 的第29行改为：\n```\nself.content = File.read(File.join(base, name), :encoding => \"utf-8\")\n ```\n>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown\n \n首先可以尝试一下更新`Pygments`， 把python里面的script目录加载path里面，然后就可以直接通过`easy_install Pygments`来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/06/jekyll.png\" alt=\"\" /></p>\n\n<h3 id=\"configyml\">config.yml</h3>\n\n<p>保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 </p>\n\n<p>比如里面写:</p>\n\n<pre><code>description:      \"freestyle21\\'s Blog\"  \n</code></pre>\n\n<p>那么我们在源码中就可以通过下面这种方式去访问了：</p>\n\n<pre><code>site.description  \nincludes  \n</code></pre>\n\n<p>该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。</p>\n\n<h3 id=\"layouts\">layouts</h3>\n\n<p>该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。</p>\n\n<h3 id=\"posts\">posts</h3>\n\n<p>该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 <code>year-month-date-title.markdown</code>。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。</p>\n\n<h3 id=\"site\">site</h3>\n\n<p>这里是<code>Jekyll</code>用以存放最终代码生成站点的根路径位置。也许把它加到你的<code>.gitignore</code>列表中会是个不错的主意。这个文件夹是<code>Jekyll</code>自动生成的，所以我们一般不用管。</p>\n\n<h3 id=\"\">其他文件/目录</h3>\n\n<p>除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。</p>\n\n<h2 id=\"windowsjekyll\">windows搭建Jekyll本地测试环境</h2>\n\n<p>你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。</p>\n\n<p>不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 </p>\n\n<p>于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。</p>\n\n<p>看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：</p>\n\n<h2 id=\"jekyll\">安装Jekyll</h2>\n\n<p>Jekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。</p>\n\n<p>下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)</p>\n\n<p>下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</p>\n\n<p>RubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。</p>\n\n<p>解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令</p>\n\n<pre><code>Ruby dk.rb init  \nRuby dk.rn install  \n</code></pre>\n\n<p>DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。</p>\n\n<p>下面就可以安装Jekyll了：</p>\n\n<pre><code>gem install Jekyll  \n</code></pre>\n\n<p>等待。。。这个时候不要关闭Git Bash。</p>\n\n<p>最后，我们可以检查一下安装Jekyll成功没有：</p>\n\n<pre><code>Jekyll --version  \n</code></pre>\n\n<p>如果输出下面的结果就说明我们成功了。。</p>\n\n<pre><code>Jekyll 0.12.0  \n</code></pre>\n\n<p>接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n<code>C:\\Users\\Administrator</code>\n这个目录下面：</p>\n\n<pre><code>git clone git://github.com./freestyle21/freestyle21.github.com.git  \n</code></pre>\n\n<p>然后进入刚才的目录里面：</p>\n\n<pre><code>cd freestyle21.github.com  \n</code></pre>\n\n<p>执行：</p>\n\n<pre><code>Jekyll --server --auto  \n</code></pre>\n\n<p>如下如：</p>\n\n<pre><code>serverauto  \n</code></pre>\n\n<p>最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。</p>\n\n<p>一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。</p>\n\n<p>现在记录一下遇到的错误，以后不要在这里耽误时间了。</p>\n\n<blockquote>\n  <p>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”</p>\n</blockquote>\n\n<p>编码问题，直接在path里面添加：<code>LCALL=enUS.UTF-8</code> 和 <code>LANG=en_US.UTF-8</code>然后重启或者注销。</p>\n\n<p>还是不行的话就将 <code>convertible.rb</code> 的第29行改为：\n<code>\nself.content = File.read(File.join(base, name), :encoding =&gt; \"utf-8\") <br />\n</code></p>\n\n<blockquote>\n  <p>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown</p>\n</blockquote>\n\n<p>首先可以尝试一下更新<code>Pygments</code>， 把python里面的script目录加载path里面，然后就可以直接通过<code>easy_install Pygments</code>来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。</p>","image":"/content/images/2016/06/cover_2016-6.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"学习jekyll","meta_description":"本文介绍jekyll的配置，用法，和应用。","author_id":1,"created_at":"2016-06-16 15:28:19","created_by":1,"updated_at":"2016-06-29 00:28:23","updated_by":1,"published_at":"2013-03-02 15:34:00","published_by":1},{"id":42,"uuid":"7982dcda-2a88-4e36-a91a-3dd60d99c89c","title":"从jQuery学细节","slug":"learn-from-jquery","markdown":"前言\n\n最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。\n\n![](/content/images/2016/06/john.png)\n\n看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~\n\n研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~\n\n现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。\n## jQuery的细节技巧\n\n### 巧用条件运算符\n```\ntrim: trim ?\n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n```\n \n这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：\n\n```\ndata = data === \"true\" ? true :\n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {}\n```\n多用点这种技巧，就不用满屏幕都是if & else 了。代码会变得简洁，轻巧。\n\n### jQuery的循环遍历技巧\n\n下面列出一些自己看出的、常见的、平时代码中常用的循环技巧\n\n1、\n```\n// 简单的for-in（事件） \nfor ( type in events ) { \n}\n```\n\n2、\n```\n// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j < l; j++ ) { \n}\n```\n3、\n```\n// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem; \nfor ( var i = 0; elems[i]; i++ ) { \n    elem = elems[i]; \n    // ... \n}\n```\n4、\n```\n// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j < eventType.length; j++ ) { \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i < results.length; i++ ) { \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n```\n这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！\n\n5、\n```\n// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j < eventType.length; j++ ) { \n}\n```\n6、\n```\n//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) { \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n```\n7、\n```\n// while检查下标i \nvar i = arr.length; \nwhile( i-- ) { \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n```\n通过闭包，返回前一作用域的参数\n```\n// 闭包。返回的函数保持对guid的引用。\nfunction a(){\n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();\n```\n一次实现多种方法\n```\nif ( rfxtypes.test(val) ) {\n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n```\n条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：\n\n```\njQuery.each([\"live\", \"die\"], function( i, name ) {\n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" && !types &&\n                    origSelector && origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n```\n一次性实现两个方法。。\n\n```\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length > 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n```\n通过each方法，实现n多方法。到此，除了惊叹还是惊叹。\n\n### 实例化jQuery对象\n\n先看代码：\n```\njQuery = function( selector, context ) {\n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n```\n这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;\n\n因此可以直接调用jQuery( selector, context )，没有必要使用new关键字\n\n还有一行代码如下：\n\n```\njQuery.fn.init.prototype = jQuery.fn = jQuery.prototype\n```\n\n所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。\n\n这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：\n\n```\n//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {\n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"<a>hello</a>\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError\n```\n在源码中，经常看到这样的代码：\n\n```\nargs = args || [];\n```\n\n这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。\n\n比如我们还可以看到这样的：\n\n```\nisArray: Array.isArray || function( obj ) {\n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;\n```\n \n在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架\n\n```\n(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n```\n \n### 结语\n\n以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~\n\n总之每看一次，都会有很大的收获，成长。\n\n最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。\n\n离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。\n","mobiledoc":null,"html":"<p>前言</p>\n\n<p>最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。</p>\n\n<p><img src=\"/content/images/2016/06/john.png\" alt=\"\" /></p>\n\n<p>看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~</p>\n\n<p>研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~</p>\n\n<p>现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。</p>\n\n<h2 id=\"jquery\">jQuery的细节技巧</h2>\n\n<h3 id=\"\">巧用条件运算符</h3>\n\n<pre><code>trim: trim ?  \n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n</code></pre>\n\n<p>这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：</p>\n\n<pre><code>data = data === \"true\" ? true :  \n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i &lt; max; i++ ) {}  \n</code></pre>\n\n<p>多用点这种技巧，就不用满屏幕都是if &amp; else 了。代码会变得简洁，轻巧。</p>\n\n<h3 id=\"jquery\">jQuery的循环遍历技巧</h3>\n\n<p>下面列出一些自己看出的、常见的、平时代码中常用的循环技巧</p>\n\n<p>1、  </p>\n\n<pre><code>// 简单的for-in（事件） \nfor ( type in events ) {  \n}\n</code></pre>\n\n<p>2、  </p>\n\n<pre><code>// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j &lt; l; j++ ) {  \n}\n</code></pre>\n\n<p>3、  </p>\n\n<pre><code>// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem;  \nfor ( var i = 0; elems[i]; i++ ) {  \n    elem = elems[i]; \n    // ... \n}\n</code></pre>\n\n<p>4、  </p>\n\n<pre><code>// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j &lt; eventType.length; j++ ) {  \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i &lt; results.length; i++ ) {  \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n</code></pre>\n\n<p>这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！</p>\n\n<p>5、  </p>\n\n<pre><code>// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j &lt; eventType.length; j++ ) {  \n}\n</code></pre>\n\n<p>6、  </p>\n\n<pre><code>//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) {  \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n</code></pre>\n\n<p>7、  </p>\n\n<pre><code>// while检查下标i \nvar i = arr.length;  \nwhile( i-- ) {  \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n</code></pre>\n\n<p>通过闭包，返回前一作用域的参数</p>\n\n<pre><code>// 闭包。返回的函数保持对guid的引用。\nfunction a(){  \n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();  \n</code></pre>\n\n<p>一次实现多种方法</p>\n\n<pre><code>if ( rfxtypes.test(val) ) {  \n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n</code></pre>\n\n<p>条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：</p>\n\n<pre><code>jQuery.each([\"live\", \"die\"], function( i, name ) {  \n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" &amp;&amp; !types &amp;&amp;\n                    origSelector &amp;&amp; origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n</code></pre>\n\n<p>一次性实现两个方法。。</p>\n\n<pre><code>jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +  \n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length &gt; 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n</code></pre>\n\n<p>通过each方法，实现n多方法。到此，除了惊叹还是惊叹。</p>\n\n<h3 id=\"jquery\">实例化jQuery对象</h3>\n\n<p>先看代码：</p>\n\n<pre><code>jQuery = function( selector, context ) {  \n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n</code></pre>\n\n<p>这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;</p>\n\n<p>因此可以直接调用jQuery( selector, context )，没有必要使用new关键字</p>\n\n<p>还有一行代码如下：</p>\n\n<pre><code>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype  \n</code></pre>\n\n<p>所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。</p>\n\n<p>这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：</p>\n\n<pre><code>//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {  \n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"&lt;a&gt;hello&lt;/a&gt;\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError  \n</code></pre>\n\n<p>在源码中，经常看到这样的代码：</p>\n\n<pre><code>args = args || [];  \n</code></pre>\n\n<p>这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。</p>\n\n<p>比如我们还可以看到这样的：</p>\n\n<pre><code>isArray: Array.isArray || function( obj ) {  \n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;  \n</code></pre>\n\n<p>在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架</p>\n\n<pre><code>(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n</code></pre>\n\n<h3 id=\"\">结语</h3>\n\n<p>以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~</p>\n\n<p>总之每看一次，都会有很大的收获，成长。</p>\n\n<p>最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。</p>\n\n<p>离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。</p>","image":"/content/images/2016/06/road-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"从jQuery学习细节","meta_description":"本文从jQuery源码中分析精华部分，学习作者的写作思路，代码风格等。","author_id":1,"created_at":"2016-06-16 15:51:22","created_by":1,"updated_at":"2016-06-29 00:22:48","updated_by":1,"published_at":"2012-10-15 15:26:00","published_by":1},{"id":43,"uuid":"9081bf24-12eb-41ec-becf-28b6ca9902e8","title":"浅谈JavaScript的语言特性","slug":"javascript-feature","markdown":"## 前言\n\n在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。\n\n本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下[权威指南](http://book.douban.com/subject/10549733)~\n\n参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：\n\n[http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/](http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/)\n\n[http://benalman.com/news/2010/11/immediately-invoked-function-expression/](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n[http://dmitrysoshnikov.com/ecmascript/javascript-the-core/](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)\n\n## 语言特性\n\n### 函数表达式\n\n先看代码段：\n\n```\nvar f = function foo(){\n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"\nf(); // \"function\"</pre>\n```\n\n这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。\n\n### json \n\n很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。\n\nJSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。\n\n`{ \"prop\": \"val\" }` 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。\n\n如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。\n\n```\n// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };\n```\n\n还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。\n\n老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。\n\n### 原型 \n\n```\nfunction Animal (){ \n// ...\n}\nfunction cat (){ \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。\ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;\n```\n如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：\n\n```\nfunction A() {}\n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // false!\n```\n\n让我们一起看下MDN上关于constructor的 [解释](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor)\n\n```\nprototype：Returns a reference to the Object function that created the instance's prototype.\n```\n因此，对函数的原型引用需要手工恢复：\n\n```\nfunction A() {}\n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // true\n```\n\n然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。\n\n```\nfunction A() {}\nA.prototype.x = 10;\n\nvar a = new A();\nalert(a.x); // 10\n\nA.prototype = {\n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10\nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20\nalert(b.y) // 30\n\n```\n\n因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。\n\n这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。\n\n### 变量对象 \n\n在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。\n\n活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：\n\n```\nfunction foo(x, y, z) {\n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n```\n\n当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：\n\n1. 函数的所有形参(如果我们是在函数执行上下文中)；\n2. 所有函数声明(FunctionDeclaration, FD)；\n3. 所有变量声明(var, VariableDeclaration)；\n\n另一个经典例子：\n\n```\nalert(x); // function\nvar x = 10;\nalert(x); // 10\nx = 20;\nfunction x() {};\nalert(x); // 20\n```\n\n根据规范函数声明是在当进入上下文时填入的; \n\n在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，**变量声明在顺序上跟在函数声明和形式参数声明之后**，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。\n\n变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。\n\n```\na = 10;\nalert(window.a); // 10\nalert(delete a); // true\nalert(window.a); // undefined\n\nvar b = 20;\nalert(window.b); // 20\nalert(delete b); // false\nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10\nalert(b); // 全局变量 \"b\" 没有声明.\n```\n\n### this\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。\n\n```\n(function () {\n    alert(this); // null =&gt; global\n})();\n```\n\n在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。\n\n```\nvar foo = {\n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&gt; foo\n(foo.bar)(); // Reference, OK =&gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n```\n\n问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。\n\n第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。\n\n在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。\n\n第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。\n\n第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。\n\n正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。\n\n```\nfunction foo() {\n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n```\n\n活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。\n\n这里我们再次回到上面描述的例子，this设置为全局对象。\n\n### 作用域链\n\n通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。\n\n一个重要的例外，它涉及到通过函数构造函数创建的函数。\n```\nvar x = 10;\nfunction foo() {\n\tvar y = 20;\n\tfunction barFD() { // 函数声明\n\t    alert(x);\n\t    alert(y);\n\t}\n\tvar barFn = Function('alert(x); alert(y);');\n\tbarFD(); // 10, 20\n\tbarFn(); // 10, \"y\" is not defined\n}\nfoo();</pre><p>还有：</p><pre class=\"brush:javascript\">var x = 10, y = 10;\nwith ({x: 20}) {\n\tvar x = 30, y = 30;\n\t//这里的 x = 30 覆盖了x = 20；\n\talert(x); // 30\n\talert(y); // 30\n}\n\nalert(x); // 10\nalert(y); // 30\n```\n在进入上下文时发生了什么？\n\n标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：\n```\nx = 10, y = 10;\n```\n对象`{x:20}`添加到作用域的前端;\n\n在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;\n\n在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;\n\n同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;\n\n此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。\n\n在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。\n\n### 函数\n\n关于圆括号的问题\n\n让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。\n\n按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：\n\n```\nfunction () {\n...\n}();\n\n// 即便有名称\n\nfunction foo() {\n...\n}();\n```\n\n我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。\n\n如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。\n\n第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：\n\n```\n// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数\nfunction foo(x) {\n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10\n```\n创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）\n\n```\n(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n```\n上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。\n\n注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。\n```\nvar foo = {\n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'\n```\n就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。\n\n因此，”关于圆括号”问题完整的答案如下：\n\n当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。\n\n由变量：\n```\nfunction testFn() {\n\tvar localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n\tfunction innerFn(innerParam) {\n\t\talert(innerParam + localVar);\n\t}\n\treturn innerFn;\n}\n\n```\n闭包的静态作用域：\n```\nvar z = 10;\n\nfunction foo() {\n    alert(z);\n}</pre><pre class=\"brush:javascript\">foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n\tvar z = 20;\n\tfoo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n\tvar z = 30;\n\tfunArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n```\n**理论**：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。\n\n**从实践角度**：以下函数才算是闭包：\n\n即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n\n在代码中引用了自由变量\n\n## 最后： \n\nECMAScript是一种面向对象语言，支持基于原型的委托式继承。","mobiledoc":null,"html":"<h2 id=\"\">前言</h2>\n\n<p>在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。</p>\n\n<p>本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下<a href=\"http://book.douban.com/subject/10549733\">权威指南</a>~</p>\n\n<p>参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：</p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/\">http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/</a></p>\n\n<p><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\">http://benalman.com/news/2010/11/immediately-invoked-function-expression/</a></p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>\n\n<h2 id=\"\">语言特性</h2>\n\n<h3 id=\"\">函数表达式</h3>\n\n<p>先看代码段：</p>\n\n<pre><code>var f = function foo(){  \n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"  \nf(); // \"function\"&lt;/pre&gt;  \n</code></pre>\n\n<p>这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。</p>\n\n<h3 id=\"json\">json</h3>\n\n<p>很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。</p>\n\n<p>JSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。</p>\n\n<p><code>{ \"prop\": \"val\" }</code> 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。</p>\n\n<p>如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。</p>\n\n<pre><code>// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };  \n</code></pre>\n\n<p>还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。</p>\n\n<p>老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。</p>\n\n<h3 id=\"\">原型</h3>\n\n<pre><code>function Animal (){  \n// ...\n}\nfunction cat (){  \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。  \ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;  \n</code></pre>\n\n<p>如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // false!  \n</code></pre>\n\n<p>让我们一起看下MDN上关于constructor的 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor\">解释</a></p>\n\n<pre><code>prototype：Returns a reference to the Object function that created the instance's prototype.  \n</code></pre>\n\n<p>因此，对函数的原型引用需要手工恢复：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // true  \n</code></pre>\n\n<p>然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。</p>\n\n<pre><code>function A() {}  \nA.prototype.x = 10;\n\nvar a = new A();  \nalert(a.x); // 10\n\nA.prototype = {  \n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10  \nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20  \nalert(b.y) // 30\n</code></pre>\n\n<p>因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。</p>\n\n<p>这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。</p>\n\n<h3 id=\"\">变量对象</h3>\n\n<p>在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。</p>\n\n<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：</p>\n\n<pre><code>function foo(x, y, z) {  \n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n</code></pre>\n\n<p>当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：</p>\n\n<ol>\n<li>函数的所有形参(如果我们是在函数执行上下文中)；  </li>\n<li>所有函数声明(FunctionDeclaration, FD)；  </li>\n<li>所有变量声明(var, VariableDeclaration)；</li>\n</ol>\n\n<p>另一个经典例子：</p>\n\n<pre><code>alert(x); // function  \nvar x = 10;  \nalert(x); // 10  \nx = 20;  \nfunction x() {};  \nalert(x); // 20  \n</code></pre>\n\n<p>根据规范函数声明是在当进入上下文时填入的; </p>\n\n<p>在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，<strong>变量声明在顺序上跟在函数声明和形式参数声明之后</strong>，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。</p>\n\n<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。</p>\n\n<pre><code>a = 10;  \nalert(window.a); // 10  \nalert(delete a); // true  \nalert(window.a); // undefined\n\nvar b = 20;  \nalert(window.b); // 20  \nalert(delete b); // false  \nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10  \nalert(b); // 全局变量 \"b\" 没有声明.  \n</code></pre>\n\n<h3 id=\"this\">this</h3>\n\n<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。</p>\n\n<pre><code>(function () {\n    alert(this); // null =&amp;gt; global\n})();\n</code></pre>\n\n<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。</p>\n\n<pre><code>var foo = {  \n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&amp;gt; foo  \n(foo.bar)(); // Reference, OK =&amp;gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n</code></pre>\n\n<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。</p>\n\n<p>第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。</p>\n\n<p>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。</p>\n\n<p>第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。</p>\n\n<p>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。</p>\n\n<p>正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。</p>\n\n<pre><code>function foo() {  \n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n</code></pre>\n\n<p>活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。</p>\n\n<p>这里我们再次回到上面描述的例子，this设置为全局对象。</p>\n\n<h3 id=\"\">作用域链</h3>\n\n<p>通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。</p>\n\n<p>一个重要的例外，它涉及到通过函数构造函数创建的函数。</p>\n\n<pre><code>var x = 10;  \nfunction foo() {  \n    var y = 20;\n    function barFD() { // 函数声明\n        alert(x);\n        alert(y);\n    }\n    var barFn = Function('alert(x); alert(y);');\n    barFD(); // 10, 20\n    barFn(); // 10, \"y\" is not defined\n}\nfoo();&lt;/pre&gt;&lt;p&gt;还有：&lt;/p&gt;&lt;pre class=\"brush:javascript\"&gt;var x = 10, y = 10;  \nwith ({x: 20}) {  \n    var x = 30, y = 30;\n    //这里的 x = 30 覆盖了x = 20；\n    alert(x); // 30\n    alert(y); // 30\n}\n\nalert(x); // 10  \nalert(y); // 30  \n</code></pre>\n\n<p>在进入上下文时发生了什么？</p>\n\n<p>标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：</p>\n\n<pre><code>x = 10, y = 10;  \n</code></pre>\n\n<p>对象<code>{x:20}</code>添加到作用域的前端;</p>\n\n<p>在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;</p>\n\n<p>在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;</p>\n\n<p>同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;</p>\n\n<p>此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。</p>\n\n<p>在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。</p>\n\n<h3 id=\"\">函数</h3>\n\n<p>关于圆括号的问题</p>\n\n<p>让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。</p>\n\n<p>按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：</p>\n\n<pre><code>function () {  \n...\n}();\n\n// 即便有名称\n\nfunction foo() {  \n...\n}();\n</code></pre>\n\n<p>我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。</p>\n\n<p>如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。</p>\n\n<p>第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：</p>\n\n<pre><code>// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数  \nfunction foo(x) {  \n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10  \n</code></pre>\n\n<p>创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）</p>\n\n<pre><code>(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n</code></pre>\n\n<p>上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。</p>\n\n<p>注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。</p>\n\n<pre><code>var foo = {  \n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'  \n</code></pre>\n\n<p>就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。</p>\n\n<p>因此，”关于圆括号”问题完整的答案如下：</p>\n\n<p>当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。</p>\n\n<p>由变量：</p>\n\n<pre><code>function testFn() {  \n    var localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n    function innerFn(innerParam) {\n        alert(innerParam + localVar);\n    }\n    return innerFn;\n}\n</code></pre>\n\n<p>闭包的静态作用域：</p>\n\n<pre><code>var z = 10;\n\nfunction foo() {  \n    alert(z);\n}&lt;/pre&gt;&lt;pre class=\"brush:javascript\"&gt;foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n    var z = 20;\n    foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n    var z = 30;\n    funArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n</code></pre>\n\n<p><strong>理论</strong>：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。</p>\n\n<p><strong>从实践角度</strong>：以下函数才算是闭包：</p>\n\n<p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>\n\n<p>在代码中引用了自由变量</p>\n\n<h2 id=\"\">最后：</h2>\n\n<p>ECMAScript是一种面向对象语言，支持基于原型的委托式继承。</p>","image":"/content/images/2016/06/g.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"浅谈JavaScript的语言特性","meta_description":"浅谈JavaScript的语言特性，作用域、上下文、闭包、函数，前端进阶。","author_id":1,"created_at":"2016-06-17 15:40:57","created_by":1,"updated_at":"2016-06-27 14:49:33","updated_by":1,"published_at":"2013-03-22 16:00:00","published_by":1},{"id":44,"uuid":"2de288af-1cb9-4d6a-889b-980cb05dec50","title":"Javascript中的括号哲学","slug":"welcome-to-ghost-2","markdown":"平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。\n\n最近刚好在看ECMAScript262，又遇到这些问题。整理一下：\n\n## 引入\n\n先上一段代码:\n\n```\nalert(foo);\nfunction foo(x) {\n    alert(x);\n}(1);\nfoo(10);\n```\n\n这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.\n\ngoogle了一下Group Operation：\n\n```\na means of controlling precedence(优先级) of evaluation in expressions.\n```\n难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？\n\n## 深入\n\n再看两个表达式：\n```\nfunction () { ... }();\nfunction foo() { ... }();\n```\n\n在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 \n\n在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 \n\n第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 \n\n这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 \n\n最常规例子：\n\n```\n(function(){\n    alert(\"cftea\");\n})();\n```\n\n这个可以理解为：\n```\nfunction foo(){\n    alert(1);\n}\nfoo();\n```\n这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：\n```\n(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){\n    alert(\"cftea\");\n}()\n```\n以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。\n\n## 括号对上下文作用域的影响\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();\n```\n这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n})();\n```\n这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。\n```\nfunction Foo() {\n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n```","mobiledoc":null,"html":"<p>平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。</p>\n\n<p>最近刚好在看ECMAScript262，又遇到这些问题。整理一下：</p>\n\n<h2 id=\"\">引入</h2>\n\n<p>先上一段代码:</p>\n\n<pre><code>alert(foo);  \nfunction foo(x) {  \n    alert(x);\n}(1);\nfoo(10);  \n</code></pre>\n\n<p>这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.</p>\n\n<p>google了一下Group Operation：</p>\n\n<pre><code>a means of controlling precedence(优先级) of evaluation in expressions.  \n</code></pre>\n\n<p>难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>再看两个表达式：</p>\n\n<pre><code>function () { ... }();  \nfunction foo() { ... }();  \n</code></pre>\n\n<p>在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 </p>\n\n<p>在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 </p>\n\n<p>第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 </p>\n\n<p>这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 </p>\n\n<p>最常规例子：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n</code></pre>\n\n<p>这个可以理解为：</p>\n\n<pre><code>function foo(){  \n    alert(1);\n}\nfoo();  \n</code></pre>\n\n<p>这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){  \n    alert(\"cftea\");\n}()\n</code></pre>\n\n<p>以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。</p>\n\n<h2 id=\"\">括号对上下文作用域的影响</h2>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();  \n</code></pre>\n\n<p>这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。</p>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n})();\n</code></pre>\n\n<p>这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。</p>\n\n<pre><code>function Foo() {  \n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-06-29 00:38:20","updated_by":1,"published_at":"2012-10-15 15:39:00","published_by":1},{"id":45,"uuid":"97d04f9f-b346-462f-baf2-75a278ad37cc","title":"高效css","slug":"efficient-css","markdown":"## 译言：\n\n原文地址在[这里](http://csswizardry.com/2011/09/writing-efficient-css-selectors)，由于第一次翻译文章，有不准确的地方欢迎留言讨论\n\n## 译文：\n\n高效的CSS已经不是一个新的话题了，也不是我一个非得重拾的话题，但它却是我在Sky公司工作之时，所感兴趣的，关注已久的话题。\n\n有很多人都忘记了，或在简单的说没有意识到，CSS在我们手中，既能很高效，也可以变得很低能。这很容易被忘记，尤其是当你意识到你会的太少，CSS代码效率很低的时候。\n\n下面的规则只真正被应用到那些速度要求很高，有成百上千的DOM元素被绘制在页面上的大型网站。但是，实践出真理，这和你是在创建下一个Facebook，还是写一个本地的展示页面都没有关系，多知道一点总是好的。\n\n### CSS选择器：\n\n对我们大多数人来说，CSS选择器并不陌生。最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。\n\n一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，[class ^= “grid-”].\n\nCSS选择器具有高效的继承性，引用Steve Souders的话， CSS选择器效率从高到低的排序如下：\n```\n<ol>\n\t<li>ID选择器 比如#header</li>\n\t<li>类选择器 比如.promo</li>\n\t<li>元素选择器 比如 div</li>\n\t<li>兄弟选择器 比如 h2 + p</li>\n\t<li>子选择器 比如 li &gt; ul</li>\n\t<li>后代选择器 比如 ul a</li>\n\t<li>通用选择器 比如 \\*</li>\n\t<li>属性选择器 比如 [type = “text”]</li>\n\t<li>伪类/伪元素选择器 比如 a:hover</li>\n</ol>\n```\n以上引用自[Steve Souders](http://stevesouders.com)的Even Faster网站。\n\n我们不得不提的是，纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出ID选择器和类选择器在速度上的差异很小很小。\n\n在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。\n\nID选择器和类选择器在速度上的差异基本上没有关系。\n\n在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了很多。在一个嵌套很深的后代选择器的测试上，显示数据为440左右!\n\n从这里我们可以看出ID/类选择器 和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。\n\n**注意：** 这些数据可能在不同计算机和浏览器中间的差异较大。强烈地建议大家在自己的机子上测试一下。\n\n### 组合选择器\n\n你可以有一个标准的选择器比如 #nav，来选择任何带有ID为\"nav\"的元素，或在你可以有一个组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素\n\n此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。\n\n在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。这些细微的差异对选择器的效率有很大的影响，同时学这些差异也是很有价值的。\n\n如果想要知道更多浏览器这样解析的原因，请看[Stack Overflow](http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left)上的讨论\n\n浏览器从最右边的元素开始（它想要渲染的元素），然后用它的方式回溯DOM树比从DOM树的最高层开始选择向下寻找，甚至可能达不到最右边的选择器—关键的选择器要高效。\n\n这些对CSS选择器的效率有很大的影响。\n\n### 关键选择器\n\n关键选择器，正如前面讨论的一样，是一个复杂的CSS选择器中最右边部分。它是浏览器最先寻找的。\n\n现在我们回到讨论开始的地方，哪类选择器是最高效的？哪个是会影响选择器效率的关键选择器；写CSS代码的时候，关键选择器是能否高效的决定因素。\n一个关键CSS选择器像这样：\n```\n#content .intro {\n}\n```\n是不是高效选择器比如类选择器天生就高效？浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。\n\n但是，下面的选择器就表现的不是那么好了：\n```\n#content * {\n}\n```\n\n这个选择器所做的是选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个 #content 的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。\n\n运用这些知识我们就可以在分类和选择元素的时候做出更好的选择。\n\n假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的 a 标签。它还有一个小的社交链接区域放在一个ID为#social的Ul里面。我们假设它们是Twitter，Facebook，Dribbble还有Google+的链接吧。在这个页面上我们有四个社交链接和成百上千的其他链接。\n下面的这个选择器就自然的不是那么高效和合理了：\n\n```\n#social a {\n}\n```\n\n这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。\n\n为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器 .social-link ,\n但是这好像有点违背我们的认知：当我们能用组合选择器的时候就不要放不必要的类标示在元素上。\n\n这就是为什么我对选择器的性能如此感兴趣的原因了：必须在web 标准最佳实践和速度之间的保持平衡。\n\n通常我们有：\n\n```\n<ul id=\"social\">;\n\t<li><a href=\"#\" class=\"twitter\" >Twitter</a></li>\n\t<li><a href=\"#\" class=\"facebook\">Facebook</a></li>\n\t<li><a href=\"#\" class=\"dribble\">Dribbble</a></li>\n\t<li><a href=\"#\" class=\"gplus\">Google+</a></li>\n</ul>\n```\n\nCSS:\n\n```\n#social a {\n}\n```\n\n我们现在最好有：\n\n```\n<ul id=\"social\">\n\t<li><a href=\"#\" class=\"social-link twitter\">Twitter</a></li>\n\t<li><a href=\"#\" class=\"social-link facebook\">Facebook</a></li>\n\t<li><a href=\"#\" class=\"social-link dribble\">Dribbble</a></li>\n\t<li><a href=\"#\" class=\"social-link gplus\">Google+</a></li>\n</ul>\n```\n\n加上CSS：\n\n```\n#social .social-link {\n}\n```\n\n这个新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式，然后专注于下一件事。\n\n另外，事实上我们可以用.social-link{}更清晰的选择，而不是过分限制它。阅读下一部分你会原因…\n\n简单的重述一次，你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器\n\n### 过度限制选择器\n\n现在我们知道了什么是关键选择器，还有它是大部分工作的来源，但是我们可以更乐观一点。拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器。一个过度限制选择器可能像：\n\n```\n.wrapper #content a {\n}\n```\n\n这里的写的太多了，至少3个选择器是完全不需要的。它可以最多像这个样子：\n\n```\n#content a {\n}\n```\n\n这会发生什么呢？\n\n首先第一个意味着浏览器不得不寻找所有的 a 元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。了解了这个，我们得到一些更现实的例子：\n\n```\n#nav li a{\n}\n```\n\n变成这个：\n\n```\n#nav a {\n}\n```\n\n我们知道如果a在li里面，它也必定在#nav里面，所有我们可以马上把li从选择器组中拿掉。然后，既然我们知道在页面中只有一个ID为nav的元素，那么它依附的元素就是完全没有关系得了，我们也可以拿掉ul\n\n过度限制选择器使浏览器工作比它实际需要的更繁重，花费的时间更多。我们可以删掉不必需的限制，来使我们的选择器更简单和高效。\n\n### 这些真的需要吗？\n\n最短的答案是:或许不是。\n\n最长的答案是：它取决于你正在搭建的站点。如果你正在为你的晋升而努力，那么就好好写出简单、高效的CSS代码吧，因为你可能不会感觉到它给你带来的改变。\n如果你正在搭建下一个每个页面都以毫秒计算的Amazon网站，这样有时速度会很快，但有时可能不是。\n\n浏览器将会在解析CSS的速度上变得更好，甚至在手机端。在一个网站上，你不太可能会觉察到一个低效的CSS选择器，但是….\n\n### 但是\n\n它确实发生了，浏览器还是不得不去做我们讨论的所有工作，无论它们变得多快。即使你不需要或者甚至不想实践任何一个，但是它都是我们值得学习的知识。请记住选择器可能会让你付出很大代价，你应该避免盯着一个看。这意味着如果你发现你自己在写像这样的：\n\n```\ndiv:nth-of-type(3) ul:last-child li:nth-of-type(odd) * { \n    font-weight:bold \n}\n```\n\n这时，你可能就做错了。\n\n现在，在高效选择器的世界我还是一个新人。所以如果我忘记了什么，或者你有需要补充的，请在评论里面留言。\n\n### 更多高效选择器\n\n我还不能完全介绍Steve Souders的网站和书籍，它们是如此之好，以至于值得你花更多时间来阅读和推荐。这个家伙只有他自己才了解自己！","mobiledoc":null,"html":"<h2 id=\"\">译言：</h2>\n\n<p>原文地址在<a href=\"http://csswizardry.com/2011/09/writing-efficient-css-selectors\">这里</a>，由于第一次翻译文章，有不准确的地方欢迎留言讨论</p>\n\n<h2 id=\"\">译文：</h2>\n\n<p>高效的CSS已经不是一个新的话题了，也不是我一个非得重拾的话题，但它却是我在Sky公司工作之时，所感兴趣的，关注已久的话题。</p>\n\n<p>有很多人都忘记了，或在简单的说没有意识到，CSS在我们手中，既能很高效，也可以变得很低能。这很容易被忘记，尤其是当你意识到你会的太少，CSS代码效率很低的时候。</p>\n\n<p>下面的规则只真正被应用到那些速度要求很高，有成百上千的DOM元素被绘制在页面上的大型网站。但是，实践出真理，这和你是在创建下一个Facebook，还是写一个本地的展示页面都没有关系，多知道一点总是好的。</p>\n\n<h3 id=\"css\">CSS选择器：</h3>\n\n<p>对我们大多数人来说，CSS选择器并不陌生。最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。</p>\n\n<p>一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，[class ^= “grid-”].</p>\n\n<p>CSS选择器具有高效的继承性，引用Steve Souders的话， CSS选择器效率从高到低的排序如下：  </p>\n\n<pre><code>&lt;ol&gt;  \n    &lt;li&gt;ID选择器 比如#header&lt;/li&gt;\n    &lt;li&gt;类选择器 比如.promo&lt;/li&gt;\n    &lt;li&gt;元素选择器 比如 div&lt;/li&gt;\n    &lt;li&gt;兄弟选择器 比如 h2 + p&lt;/li&gt;\n    &lt;li&gt;子选择器 比如 li &amp;gt; ul&lt;/li&gt;\n    &lt;li&gt;后代选择器 比如 ul a&lt;/li&gt;\n    &lt;li&gt;通用选择器 比如 \\*&lt;/li&gt;\n    &lt;li&gt;属性选择器 比如 [type = “text”]&lt;/li&gt;\n    &lt;li&gt;伪类/伪元素选择器 比如 a:hover&lt;/li&gt;\n&lt;/ol&gt;  \n</code></pre>\n\n<p>以上引用自<a href=\"http://stevesouders.com\">Steve Souders</a>的Even Faster网站。</p>\n\n<p>我们不得不提的是，纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出ID选择器和类选择器在速度上的差异很小很小。</p>\n\n<p>在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。</p>\n\n<p>ID选择器和类选择器在速度上的差异基本上没有关系。</p>\n\n<p>在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了很多。在一个嵌套很深的后代选择器的测试上，显示数据为440左右!</p>\n\n<p>从这里我们可以看出ID/类选择器 和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。</p>\n\n<p><strong>注意：</strong> 这些数据可能在不同计算机和浏览器中间的差异较大。强烈地建议大家在自己的机子上测试一下。</p>\n\n<h3 id=\"\">组合选择器</h3>\n\n<p>你可以有一个标准的选择器比如 #nav，来选择任何带有ID为\"nav\"的元素，或在你可以有一个组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素</p>\n\n<p>此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。</p>\n\n<p>在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。这些细微的差异对选择器的效率有很大的影响，同时学这些差异也是很有价值的。</p>\n\n<p>如果想要知道更多浏览器这样解析的原因，请看<a href=\"http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left\">Stack Overflow</a>上的讨论</p>\n\n<p>浏览器从最右边的元素开始（它想要渲染的元素），然后用它的方式回溯DOM树比从DOM树的最高层开始选择向下寻找，甚至可能达不到最右边的选择器—关键的选择器要高效。</p>\n\n<p>这些对CSS选择器的效率有很大的影响。</p>\n\n<h3 id=\"\">关键选择器</h3>\n\n<p>关键选择器，正如前面讨论的一样，是一个复杂的CSS选择器中最右边部分。它是浏览器最先寻找的。</p>\n\n<p>现在我们回到讨论开始的地方，哪类选择器是最高效的？哪个是会影响选择器效率的关键选择器；写CSS代码的时候，关键选择器是能否高效的决定因素。\n一个关键CSS选择器像这样：</p>\n\n<pre><code>#content .intro {\n}\n</code></pre>\n\n<p>是不是高效选择器比如类选择器天生就高效？浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。</p>\n\n<p>但是，下面的选择器就表现的不是那么好了：</p>\n\n<pre><code>#content * {\n}\n</code></pre>\n\n<p>这个选择器所做的是选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个 #content 的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。</p>\n\n<p>运用这些知识我们就可以在分类和选择元素的时候做出更好的选择。</p>\n\n<p>假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的 a 标签。它还有一个小的社交链接区域放在一个ID为#social的Ul里面。我们假设它们是Twitter，Facebook，Dribbble还有Google+的链接吧。在这个页面上我们有四个社交链接和成百上千的其他链接。\n下面的这个选择器就自然的不是那么高效和合理了：</p>\n\n<pre><code>#social a {\n}\n</code></pre>\n\n<p>这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。</p>\n\n<p>为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器 .social-link ,\n但是这好像有点违背我们的认知：当我们能用组合选择器的时候就不要放不必要的类标示在元素上。</p>\n\n<p>这就是为什么我对选择器的性能如此感兴趣的原因了：必须在web 标准最佳实践和速度之间的保持平衡。</p>\n\n<p>通常我们有：</p>\n\n<pre><code>&lt;ul id=\"social\"&gt;;  \n    &lt;li&gt;&lt;a href=\"#\" class=\"twitter\" &gt;Twitter&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"facebook\"&gt;Facebook&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"dribble\"&gt;Dribbble&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"gplus\"&gt;Google+&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;  \n</code></pre>\n\n<p>CSS:</p>\n\n<pre><code>#social a {\n}\n</code></pre>\n\n<p>我们现在最好有：</p>\n\n<pre><code>&lt;ul id=\"social\"&gt;  \n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link twitter\"&gt;Twitter&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link facebook\"&gt;Facebook&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link dribble\"&gt;Dribbble&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link gplus\"&gt;Google+&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;  \n</code></pre>\n\n<p>加上CSS：</p>\n\n<pre><code>#social .social-link {\n}\n</code></pre>\n\n<p>这个新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式，然后专注于下一件事。</p>\n\n<p>另外，事实上我们可以用.social-link{}更清晰的选择，而不是过分限制它。阅读下一部分你会原因…</p>\n\n<p>简单的重述一次，你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器</p>\n\n<h3 id=\"\">过度限制选择器</h3>\n\n<p>现在我们知道了什么是关键选择器，还有它是大部分工作的来源，但是我们可以更乐观一点。拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器。一个过度限制选择器可能像：</p>\n\n<pre><code>.wrapper #content a {\n}\n</code></pre>\n\n<p>这里的写的太多了，至少3个选择器是完全不需要的。它可以最多像这个样子：</p>\n\n<pre><code>#content a {\n}\n</code></pre>\n\n<p>这会发生什么呢？</p>\n\n<p>首先第一个意味着浏览器不得不寻找所有的 a 元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。了解了这个，我们得到一些更现实的例子：</p>\n\n<pre><code>#nav li a{\n}\n</code></pre>\n\n<p>变成这个：</p>\n\n<pre><code>#nav a {\n}\n</code></pre>\n\n<p>我们知道如果a在li里面，它也必定在#nav里面，所有我们可以马上把li从选择器组中拿掉。然后，既然我们知道在页面中只有一个ID为nav的元素，那么它依附的元素就是完全没有关系得了，我们也可以拿掉ul</p>\n\n<p>过度限制选择器使浏览器工作比它实际需要的更繁重，花费的时间更多。我们可以删掉不必需的限制，来使我们的选择器更简单和高效。</p>\n\n<h3 id=\"\">这些真的需要吗？</h3>\n\n<p>最短的答案是:或许不是。</p>\n\n<p>最长的答案是：它取决于你正在搭建的站点。如果你正在为你的晋升而努力，那么就好好写出简单、高效的CSS代码吧，因为你可能不会感觉到它给你带来的改变。\n如果你正在搭建下一个每个页面都以毫秒计算的Amazon网站，这样有时速度会很快，但有时可能不是。</p>\n\n<p>浏览器将会在解析CSS的速度上变得更好，甚至在手机端。在一个网站上，你不太可能会觉察到一个低效的CSS选择器，但是….</p>\n\n<h3 id=\"\">但是</h3>\n\n<p>它确实发生了，浏览器还是不得不去做我们讨论的所有工作，无论它们变得多快。即使你不需要或者甚至不想实践任何一个，但是它都是我们值得学习的知识。请记住选择器可能会让你付出很大代价，你应该避免盯着一个看。这意味着如果你发现你自己在写像这样的：</p>\n\n<pre><code>div:nth-of-type(3) ul:last-child li:nth-of-type(odd) * {  \n    font-weight:bold \n}\n</code></pre>\n\n<p>这时，你可能就做错了。</p>\n\n<p>现在，在高效选择器的世界我还是一个新人。所以如果我忘记了什么，或者你有需要补充的，请在评论里面留言。</p>\n\n<h3 id=\"\">更多高效选择器</h3>\n\n<p>我还不能完全介绍Steve Souders的网站和书籍，它们是如此之好，以至于值得你花更多时间来阅读和推荐。这个家伙只有他自己才了解自己！</p>","image":"/content/images/2016/06/css.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"高效css，css技巧，css效率","meta_description":"本文讲解css的效率方面问题，各种css选择器的浏览器实现原理，使用注意等。","author_id":1,"created_at":"2016-06-27 14:13:42","created_by":1,"updated_at":"2016-06-27 14:23:00","updated_by":1,"published_at":"2013-03-08 14:18:00","published_by":1},{"id":46,"uuid":"0225b252-29d3-4373-901a-e53fb214518d","title":"微信开发的一些总结","slug":"weixin-develop","markdown":"最近有机会，尝试了一次微信开发，中间遇到很多比较容易踩得坑，记录一下。\n\n主要功能是\n\n1. 微信网页认证\n2. 转盘抽奖\n3. 微信公共号发红包给当前登录用户\n4. 分享给好友和分享到朋友圈\n\n## 微信限制\n\n涉及到的资源:\n\n微信公众平台： [https://mp.weixin.qq.com/](https://mp.weixin.qq.com/)\n\n微信商户平台： [https://pay.weixin.qq.com/](https://pay.weixin.qq.com/)\n\n微信API：[http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)\n\n微信开发者论坛: [http://qydev.weixin.qq.com/qa/index.php?qa=questions](http://qydev.weixin.qq.com/qa/index.php?qa=questions)\n\n## 过程记录\n\n### 微信网页认证\n\n**条件：**\n\n1. 服务号\n\n2. 通过微信认证\n\n接口文档：[http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html](http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html)\n\n过程是获取用户授权的`code`，通过`code`获取`access_code`，然后通过`access_code`获取用户信息。\n\n#### 其中第一个坑\n\n第一步获取用户授权的`code`，`redirect_uri`经常会报错`redirect_uri参数错误`，可能的原因是：\n\n1. 公众平台后台设置授权回调域名\n2. 回调页面有端口，授权也需端口\n3. redirect_uri urlencode\n4. 绑定已备案域名，主要域名必须是二级或二级以上域名\n\n如果以上问题都注意到后，还是有问题，便可以等几个小时，很可能是微信接口抽风了，我就是用着用着这个接口挂了，等了好几个小时自己好了。\n\n#### 第二个坑\n\n有时候报错”不能访问链接“，原因是微信后台设置的回调域名不对，有时候自己切换host后，域名不对，所以修改回调域名就好了。\n\n#### 第三个坑\n\n`access_token`会过期，用的时候建议每次都通过`refresh_token`去重新获取`access_token`\n\n#### 第四个坑\n\n用户授权后回跳的页面的时候，控制台报错\n\n\t`Resource interpreted as Document but transferred with MIME type application/octet-stream: \"https://open.weixin.qq.com/connect/oauth2/..`\n\n解决办法是，回调页面的url设置为`http://xxx.com`，而不是`xxx.com`\n\n#### 第五个坑\n\n授权回调页面，url会带有`?code=xxx`，不能直接分享这个url，会导致后面的用户授权不了。因为这个问题纠结了很久。\n\n解决方式是，在node端解析code，然后写入cookie，通过`url redirect`到没有code的页面。另一种方式是，通过微信api，定制分享内容和分享的链接。\n\n### 公众号微信发红包给用户\n\n条件：\n\n1. 通过微信认证\n2. 通过微信支付认证\n\n接口地址：[https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1](https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1)\n\n#### 第一个坑\n\n就是有时候会报错`签名错误`，可能原因及解决办法是：\n\n1. 生成签名的密匙过期，重新去后台设置一下即可。\n2. 加密的字符串需要按照ASCII排序\n3. 如果还是没解决，可以去掉中文试试\n4. 还是不正确，可以通过签名工具，把参数都输入后看输出的和自己的哪一步不对。\n5. 最后，post请求传过去的body应该是xml格式，且xml格式需要严格按照xml语法，顺序最好和文档的一样。\n\n\n#### 第二个坑\n\n证书的使用。\n官方下载会下载到三个证书，node用.p12后缀的，使用方式是在请求头设置 agent，然后设置密码。具体见文末的代码链接。\n\n#### 第三个坑\n\n红包的描述和祝福语之类的设置中文会出现红包发送不出去的情况，解决方式是对中文进行unicode编码。\n\n\n### 分享给好友和分享到朋友圈\n\n第一步，在微信后台设置`js接口安全域名`\n\n第二步，引入js文件\n\n第三步，通过config接口注入验证配置\n\t\n **坑**: `signature`签名获取方式是先获取 jsapi_ticket，通过access_token获取jsapi_ticket时总是报错，同一个未过期的access_token获取用户信息是可以的，获取jsapi_ticket就不行。\n\n第四部，配置onMenuShareTimeline方法。可以自定义分享内容和链接。\n\t\n\n---\n\n最后，推荐html5的一些组件库\n\nfrozenUI： [http://frozenui.github.io/](http://frozenui.github.io/)\n\n很出色的h5制作网站：[http://h5.baidu.com/](http://h5.baidu.com/)\n\n源代码仓库链接：[https://github.com/freestyle21/orange-plus](https://github.com/freestyle21/orange-plus)","mobiledoc":null,"html":"<p>最近有机会，尝试了一次微信开发，中间遇到很多比较容易踩得坑，记录一下。</p>\n\n<p>主要功能是</p>\n\n<ol>\n<li>微信网页认证  </li>\n<li>转盘抽奖  </li>\n<li>微信公共号发红包给当前登录用户  </li>\n<li>分享给好友和分享到朋友圈</li>\n</ol>\n\n<h2 id=\"\">微信限制</h2>\n\n<p>涉及到的资源:</p>\n\n<p>微信公众平台： <a href=\"https://mp.weixin.qq.com/\">https://mp.weixin.qq.com/</a></p>\n\n<p>微信商户平台： <a href=\"https://pay.weixin.qq.com/\">https://pay.weixin.qq.com/</a></p>\n\n<p>微信API：<a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\">http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html</a></p>\n\n<p>微信开发者论坛: <a href=\"http://qydev.weixin.qq.com/qa/index.php?qa=questions\">http://qydev.weixin.qq.com/qa/index.php?qa=questions</a></p>\n\n<h2 id=\"\">过程记录</h2>\n\n<h3 id=\"\">微信网页认证</h3>\n\n<p><strong>条件：</strong></p>\n\n<ol>\n<li><p>服务号</p></li>\n<li><p>通过微信认证</p></li>\n</ol>\n\n<p>接口文档：<a href=\"http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html\">http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html</a></p>\n\n<p>过程是获取用户授权的<code>code</code>，通过<code>code</code>获取<code>access_code</code>，然后通过<code>access_code</code>获取用户信息。</p>\n\n<h4 id=\"\">其中第一个坑</h4>\n\n<p>第一步获取用户授权的<code>code</code>，<code>redirect_uri</code>经常会报错<code>redirect_uri参数错误</code>，可能的原因是：</p>\n\n<ol>\n<li>公众平台后台设置授权回调域名  </li>\n<li>回调页面有端口，授权也需端口  </li>\n<li>redirect_uri urlencode  </li>\n<li>绑定已备案域名，主要域名必须是二级或二级以上域名</li>\n</ol>\n\n<p>如果以上问题都注意到后，还是有问题，便可以等几个小时，很可能是微信接口抽风了，我就是用着用着这个接口挂了，等了好几个小时自己好了。</p>\n\n<h4 id=\"\">第二个坑</h4>\n\n<p>有时候报错”不能访问链接“，原因是微信后台设置的回调域名不对，有时候自己切换host后，域名不对，所以修改回调域名就好了。</p>\n\n<h4 id=\"\">第三个坑</h4>\n\n<p><code>access_token</code>会过期，用的时候建议每次都通过<code>refresh_token</code>去重新获取<code>access_token</code></p>\n\n<h4 id=\"\">第四个坑</h4>\n\n<p>用户授权后回跳的页面的时候，控制台报错</p>\n\n<pre><code>`Resource interpreted as Document but transferred with MIME type application/octet-stream: \"https://open.weixin.qq.com/connect/oauth2/..`\n</code></pre>\n\n<p>解决办法是，回调页面的url设置为<code>http://xxx.com</code>，而不是<code>xxx.com</code></p>\n\n<h4 id=\"\">第五个坑</h4>\n\n<p>授权回调页面，url会带有<code>?code=xxx</code>，不能直接分享这个url，会导致后面的用户授权不了。因为这个问题纠结了很久。</p>\n\n<p>解决方式是，在node端解析code，然后写入cookie，通过<code>url redirect</code>到没有code的页面。另一种方式是，通过微信api，定制分享内容和分享的链接。</p>\n\n<h3 id=\"\">公众号微信发红包给用户</h3>\n\n<p>条件：</p>\n\n<ol>\n<li>通过微信认证  </li>\n<li>通过微信支付认证</li>\n</ol>\n\n<p>接口地址：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1\">https://pay.weixin.qq.com/wiki/doc/api/tools/cash<em>coupon.php?chapter=13</em>1</a></p>\n\n<h4 id=\"\">第一个坑</h4>\n\n<p>就是有时候会报错<code>签名错误</code>，可能原因及解决办法是：</p>\n\n<ol>\n<li>生成签名的密匙过期，重新去后台设置一下即可。  </li>\n<li>加密的字符串需要按照ASCII排序  </li>\n<li>如果还是没解决，可以去掉中文试试  </li>\n<li>还是不正确，可以通过签名工具，把参数都输入后看输出的和自己的哪一步不对。  </li>\n<li>最后，post请求传过去的body应该是xml格式，且xml格式需要严格按照xml语法，顺序最好和文档的一样。</li>\n</ol>\n\n<h4 id=\"\">第二个坑</h4>\n\n<p>证书的使用。\n官方下载会下载到三个证书，node用.p12后缀的，使用方式是在请求头设置 agent，然后设置密码。具体见文末的代码链接。</p>\n\n<h4 id=\"\">第三个坑</h4>\n\n<p>红包的描述和祝福语之类的设置中文会出现红包发送不出去的情况，解决方式是对中文进行unicode编码。</p>\n\n<h3 id=\"\">分享给好友和分享到朋友圈</h3>\n\n<p>第一步，在微信后台设置<code>js接口安全域名</code></p>\n\n<p>第二步，引入js文件</p>\n\n<p>第三步，通过config接口注入验证配置</p>\n\n<p><strong>坑</strong>: <code>signature</code>签名获取方式是先获取 jsapi<em>ticket，通过access</em>token获取jsapi<em>ticket时总是报错，同一个未过期的access</em>token获取用户信息是可以的，获取jsapi_ticket就不行。</p>\n\n<p>第四部，配置onMenuShareTimeline方法。可以自定义分享内容和链接。</p>\n\n<hr />\n\n<p>最后，推荐html5的一些组件库</p>\n\n<p>frozenUI： <a href=\"http://frozenui.github.io/\">http://frozenui.github.io/</a></p>\n\n<p>很出色的h5制作网站：<a href=\"http://h5.baidu.com/\">http://h5.baidu.com/</a></p>\n\n<p>源代码仓库链接：<a href=\"https://github.com/freestyle21/orange-plus\">https://github.com/freestyle21/orange-plus</a></p>","image":"/content/images/2016/07/1-16030GQ0241E.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"微信开发的一些总结","meta_description":"本文总结微信支付开发的一些细节，遇到的坑，以及解决方案。","author_id":1,"created_at":"2016-07-05 13:57:07","created_by":1,"updated_at":"2016-07-05 14:04:13","updated_by":1,"published_at":"2016-04-17 14:02:00","published_by":1},{"id":47,"uuid":"251c97f0-ce41-408d-b934-2c601a951e8a","title":"前端性能调优","slug":"f2e-performance-optimization","markdown":"> 前几天，对九霄项目进行了一次大范围的性能优化，效果还不错，<strong>首屏从最开始的899个请求4.98s加载，到最后29个请求998ms加载，提升了79%以上。</strong>这里记录一下优化的过程，方便有需要的朋友。\n\n## 开篇\n新工作已经4个多月，从0开始到现在三个子系统并行，每个子系统负责滴滴业务线的数据分析，业务量和业务逻辑相当复杂。不过随着业务的扩展，性能也随之会成为阻碍系统运转的瓶颈，性能优化势在必行。\n\n## 现状\n目前前端技术架构是:\n     \n[seajs](http://seajs.org) + [arale](http://aralejs.org/docs/about-arale.html) + [koa](http://koajs.com/) + [gulp](http://gulpjs.com/) + [less](http://lesscss.org/)\n\n页面部署是：\n\n     + router.js\n          - entry[入口]\n          - express[快车]\n          - hitch[顺风车]\n          - daijia[代驾]\n\n页面是由路由依次进入四个页面。由于是单页面应用，所以资源文件都是一次加载，导致子系统越多，加载文件越多，网站也越来越慢。\n\n![](/content/images/2016/07/a--1-.png)\n\n## 优化\n\n### 优化一: 按需加载\n\n从上面的架构来看，seajs模块combo在一起，合成一个 `nsky.min.js` 的原始发布方案已经不能满足需求了，需要划分子系统按需加载。\n\n\n按需加载的意思是，进入首页时加载首页必须依赖的模块，不加载其他页面(快车，顺风车，代驾)所需资源。\n\n\nseajs请求资源的原理是正则扫描每个模块中`require`的字符串，从而提取模块的依赖。加载模块时，首先加载其依赖文件，因此我们能够通过 combo 的方式把模块合并到一个文件。另外，seajs中提供 `require.async` 来实现异步加载。\n\n\n因此，我们在router里面转发到不同页面的时候使用 require.async，从而实现分子系统按需加载。\n\n\n优化结果如下：\n\n![](/content/images/2016/07/b.png)\n\n首屏请求数量直接从899个优化到57个，结果还是可喜。\n\n### 优化二：请求合并\n\n观察请求瀑布流，发现请求文件还是太多，比如系统资源加载（class.js/events.js/overlay.js等)，还有业务代码较多，我们可以把这些资源合并在一起，发出combo请求。\n\n比如发出 \n   \n    http://d.kuaidadi.com/path/??class.js,events.js,overlay.js,xxx.js\n\n然后服务端响应此 combo 请求，返回 `class.js`, `events.js`, `overlay.js`, `xxx.js`的合集，这样就可以实现请求合并。\n\n首先，需要浏览器发出类似 `??a.js,b.js,c.js` 的combo请求。seajs发出combo请求很简单，通过[seajs combo插件](https://github.com/seajs/seajs-combo/issues/3)就可以了:\n\n     seajs.config({\n        preload: \"seajs-combo\"\n     });\n\n其次，需要服务器端响应类似 `??a.js,b.js,c.js` 的combo请求。\n\n[seajs combo插件中文文档](https://github.com/seajs/seajs-combo/issues/3)中提到，服务端实现combo请求是通过[Nginx-Http-Concat](https://github.com/taobao/nginx-http-concat)实现。\n\n但是由于线上服务器是通过 Nginx 来实现数台生产机器间负载均衡，通过 `Nginx Proxy Pass`实现非80端转发到80端口。经过试验发现，Nginx的 `Proxy Pass` 和 `Nginx-Http-Concat`不能同时使用，其作者也说过[暂时不支持。](https://www.zhihu.com/question/21313870/answer/17853844)，所以此路不通。\n\n因此，只能自己实现Node Combo。于是又找了不少node-combo项目(比如[node-combo](https://github.com/xuexb/node-combo))，研究其实现思路，准备自己写koa-node-combo插件了。\n\n后来搜索npm仓库，发现有多个这样的插件，尝试发现[koa-combo-parse](https://www.npmjs.com/package/koa-combo-parse)可行：\n\n    app.use(comboParse({\n        base: path.resolve(__dirname, '../client/')\n    }));\n\n\n但是，问题又来了。combo到一起后系统仍然不能运行，因为文件之间没有识别的id。需要寻找工具来对每个模版补全id和依赖(deps)，combo后就能互相识别了。即需要从：\n\n    define(function(require, exports, module){\n        var a = require('a'),\n            b = require('b'); \n        module.exports = {};\n    });\n\n变成：\n \n\n    define('moduleId', ['a', 'b'], function(require, exports, module){\n        var a = require('a'),\n            b = require('b');\n        module.exports = {};\n    });\n\n\n在此过程中调研了 [spm](https://github.com/spmjs/spm)、[gulp-seajs-combo](https://github.com/chenmnkken/gulp-seajs-combo)等，发现都不满足需求。\n\n于是自己实现了node小工具 [iddeps](https://www.npmjs.com/package/iddeps)，并写成了gulp插件[gulp-ids-deps](https://www.npmjs.com/package/gulp-ids-deps)。\n\n最终，前端发出combo请求后，后端响应combo请求，效果如下：\n\n![](/content/images/2016/07/c-2.png)\n\n请求数量从57减少到37，请求时间从1.4s减少到了1.18s。\n\n### 优化三：模版文件预编译\n\n从上面的瀑布流能看出，tpl文件既大又多，占用不少请求时间。\n\n在handlebars中，有预编译的思想，可以在运行前把模版文件预编译成为 js 文件。\n\n业界没有相应的工具，于是自己写了一个node小工具[tpl-2-js](https://www.npmjs.com/package/tpl-2-js)，并改写成gulp插件[gulp-tpl-2-js](https://www.npmjs.com/package/gulp-tpl-2-js)。\n\nHandlebars预编译的过程是：\n       \n       //  node\n       var preCompileData = handlebars.precompile(data);\n\n\n       // web \n       var Handlebars = require('handlebars'),\n        template = Handlebars.template;\n    \n       template(preCompileData)({data});\n   \n预编译的过程，是`Handlebars precompile`创建了一个函数，把每个template存储在 Handlebars.templates里面。\n\n更多详细请看：[gulp-tpl-2-js](https://github.com/freestyle21/gulp-tpl-2-js)\n    \n\n经过模版预编译后、Combo后，效果如下：\n\n![](/content/images/2016/07/d.png)\n\n可以看到，请求结果从上次的37减少到29，请求时间从1.18s减少到998ms\n\n## 后续\n\n整体结果优化的效果差不多了，请求数变到最小，时间首屏时间也符合期望。\n\n后续的优化，可以考虑通过 html5 的 appcache 缓存不经常的更新资源文件，把 200 的资源文件变成 302。\n\n本文是记录自己优化系统的心路历程，有不同意见或者有所收获的可以留言讨论。","mobiledoc":null,"html":"<blockquote>\n  <p>前几天，对九霄项目进行了一次大范围的性能优化，效果还不错，<strong>首屏从最开始的899个请求4.98s加载，到最后29个请求998ms加载，提升了79%以上。</strong>这里记录一下优化的过程，方便有需要的朋友。</p>\n</blockquote>\n\n<h2 id=\"\">开篇</h2>\n\n<p>新工作已经4个多月，从0开始到现在三个子系统并行，每个子系统负责滴滴业务线的数据分析，业务量和业务逻辑相当复杂。不过随着业务的扩展，性能也随之会成为阻碍系统运转的瓶颈，性能优化势在必行。</p>\n\n<h2 id=\"\">现状</h2>\n\n<p>目前前端技术架构是:</p>\n\n<p><a href=\"http://seajs.org\">seajs</a> + <a href=\"http://aralejs.org/docs/about-arale.html\">arale</a> + <a href=\"http://koajs.com/\">koa</a> + <a href=\"http://gulpjs.com/\">gulp</a> + <a href=\"http://lesscss.org/\">less</a></p>\n\n<p>页面部署是：</p>\n\n<pre><code> + router.js\n      - entry[入口]\n      - express[快车]\n      - hitch[顺风车]\n      - daijia[代驾]\n</code></pre>\n\n<p>页面是由路由依次进入四个页面。由于是单页面应用，所以资源文件都是一次加载，导致子系统越多，加载文件越多，网站也越来越慢。</p>\n\n<p><img src=\"/content/images/2016/07/a--1-.png\" alt=\"\" /></p>\n\n<h2 id=\"\">优化</h2>\n\n<h3 id=\"\">优化一: 按需加载</h3>\n\n<p>从上面的架构来看，seajs模块combo在一起，合成一个 <code>nsky.min.js</code> 的原始发布方案已经不能满足需求了，需要划分子系统按需加载。</p>\n\n<p>按需加载的意思是，进入首页时加载首页必须依赖的模块，不加载其他页面(快车，顺风车，代驾)所需资源。</p>\n\n<p>seajs请求资源的原理是正则扫描每个模块中<code>require</code>的字符串，从而提取模块的依赖。加载模块时，首先加载其依赖文件，因此我们能够通过 combo 的方式把模块合并到一个文件。另外，seajs中提供 <code>require.async</code> 来实现异步加载。</p>\n\n<p>因此，我们在router里面转发到不同页面的时候使用 require.async，从而实现分子系统按需加载。</p>\n\n<p>优化结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/b.png\" alt=\"\" /></p>\n\n<p>首屏请求数量直接从899个优化到57个，结果还是可喜。</p>\n\n<h3 id=\"\">优化二：请求合并</h3>\n\n<p>观察请求瀑布流，发现请求文件还是太多，比如系统资源加载（class.js/events.js/overlay.js等)，还有业务代码较多，我们可以把这些资源合并在一起，发出combo请求。</p>\n\n<p>比如发出 </p>\n\n<pre><code>http://d.kuaidadi.com/path/??class.js,events.js,overlay.js,xxx.js\n</code></pre>\n\n<p>然后服务端响应此 combo 请求，返回 <code>class.js</code>, <code>events.js</code>, <code>overlay.js</code>, <code>xxx.js</code>的合集，这样就可以实现请求合并。</p>\n\n<p>首先，需要浏览器发出类似 <code>??a.js,b.js,c.js</code> 的combo请求。seajs发出combo请求很简单，通过<a href=\"https://github.com/seajs/seajs-combo/issues/3\">seajs combo插件</a>就可以了:</p>\n\n<pre><code> seajs.config({\n    preload: \"seajs-combo\"\n });\n</code></pre>\n\n<p>其次，需要服务器端响应类似 <code>??a.js,b.js,c.js</code> 的combo请求。</p>\n\n<p><a href=\"https://github.com/seajs/seajs-combo/issues/3\">seajs combo插件中文文档</a>中提到，服务端实现combo请求是通过<a href=\"https://github.com/taobao/nginx-http-concat\">Nginx-Http-Concat</a>实现。</p>\n\n<p>但是由于线上服务器是通过 Nginx 来实现数台生产机器间负载均衡，通过 <code>Nginx Proxy Pass</code>实现非80端转发到80端口。经过试验发现，Nginx的 <code>Proxy Pass</code> 和 <code>Nginx-Http-Concat</code>不能同时使用，其作者也说过<a href=\"https://www.zhihu.com/question/21313870/answer/17853844\">暂时不支持。</a>，所以此路不通。</p>\n\n<p>因此，只能自己实现Node Combo。于是又找了不少node-combo项目(比如<a href=\"https://github.com/xuexb/node-combo\">node-combo</a>)，研究其实现思路，准备自己写koa-node-combo插件了。</p>\n\n<p>后来搜索npm仓库，发现有多个这样的插件，尝试发现<a href=\"https://www.npmjs.com/package/koa-combo-parse\">koa-combo-parse</a>可行：</p>\n\n<pre><code>app.use(comboParse({\n    base: path.resolve(__dirname, '../client/')\n}));\n</code></pre>\n\n<p>但是，问题又来了。combo到一起后系统仍然不能运行，因为文件之间没有识别的id。需要寻找工具来对每个模版补全id和依赖(deps)，combo后就能互相识别了。即需要从：</p>\n\n<pre><code>define(function(require, exports, module){\n    var a = require('a'),\n        b = require('b'); \n    module.exports = {};\n});\n</code></pre>\n\n<p>变成：</p>\n\n<pre><code>define('moduleId', ['a', 'b'], function(require, exports, module){\n    var a = require('a'),\n        b = require('b');\n    module.exports = {};\n});\n</code></pre>\n\n<p>在此过程中调研了 <a href=\"https://github.com/spmjs/spm\">spm</a>、<a href=\"https://github.com/chenmnkken/gulp-seajs-combo\">gulp-seajs-combo</a>等，发现都不满足需求。</p>\n\n<p>于是自己实现了node小工具 <a href=\"https://www.npmjs.com/package/iddeps\">iddeps</a>，并写成了gulp插件<a href=\"https://www.npmjs.com/package/gulp-ids-deps\">gulp-ids-deps</a>。</p>\n\n<p>最终，前端发出combo请求后，后端响应combo请求，效果如下：</p>\n\n<p><img src=\"/content/images/2016/07/c-2.png\" alt=\"\" /></p>\n\n<p>请求数量从57减少到37，请求时间从1.4s减少到了1.18s。</p>\n\n<h3 id=\"\">优化三：模版文件预编译</h3>\n\n<p>从上面的瀑布流能看出，tpl文件既大又多，占用不少请求时间。</p>\n\n<p>在handlebars中，有预编译的思想，可以在运行前把模版文件预编译成为 js 文件。</p>\n\n<p>业界没有相应的工具，于是自己写了一个node小工具<a href=\"https://www.npmjs.com/package/tpl-2-js\">tpl-2-js</a>，并改写成gulp插件<a href=\"https://www.npmjs.com/package/gulp-tpl-2-js\">gulp-tpl-2-js</a>。</p>\n\n<p>Handlebars预编译的过程是：</p>\n\n<pre><code>   //  node\n   var preCompileData = handlebars.precompile(data);\n\n\n   // web \n   var Handlebars = require('handlebars'),\n    template = Handlebars.template;\n\n   template(preCompileData)({data});\n</code></pre>\n\n<p>预编译的过程，是<code>Handlebars precompile</code>创建了一个函数，把每个template存储在 Handlebars.templates里面。</p>\n\n<p>更多详细请看：<a href=\"https://github.com/freestyle21/gulp-tpl-2-js\">gulp-tpl-2-js</a></p>\n\n<p>经过模版预编译后、Combo后，效果如下：</p>\n\n<p><img src=\"/content/images/2016/07/d.png\" alt=\"\" /></p>\n\n<p>可以看到，请求结果从上次的37减少到29，请求时间从1.18s减少到998ms</p>\n\n<h2 id=\"\">后续</h2>\n\n<p>整体结果优化的效果差不多了，请求数变到最小，时间首屏时间也符合期望。</p>\n\n<p>后续的优化，可以考虑通过 html5 的 appcache 缓存不经常的更新资源文件，把 200 的资源文件变成 302。</p>\n\n<p>本文是记录自己优化系统的心路历程，有不同意见或者有所收获的可以留言讨论。</p>","image":"/content/images/2016/07/aa.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:35:25","created_by":1,"updated_at":"2016-07-05 23:43:59","updated_by":1,"published_at":"2015-12-29 23:35:00","published_by":1},{"id":48,"uuid":"61b6396b-b06e-42bc-8548-0091e467df91","title":"怎样选择前端框架","slug":"how-to-choose-f2e-framework","markdown":"## 怎样选择前端框架 \n>怎样选择适合自己的前端框架，并在高产但良莠不齐的前端社区中保持理性\n\n>翻译自：[http://fse.guru/](http://fse.guru/)\n\n\n## 介绍\n\nHello，开发朋友们！\n\n下面你将看到一些比较主观的工具和框架。\n\n但不要害怕！\n\n你可以选择任何你所熟悉的，或者忽略他们直接用你自己喜欢的就好了。\n\n本文希望帮助你了解前端社区中海量的工具。\n\n当然，这些只是一些可选的列表，当你需要做出选择的时候帮助你抉择。 \n\n## 我自己使用它吗？\n\n是的，当我需要开始项目的时候，我用它来作为提醒。\n\n同时，每当有人问“我该使用什么框架呢？”的时候，我就会把这篇文章给他看。\n\n因为，正如你明白的，事情没有绝对的对与错，但是有一些优质的框架能够帮助做出我们更好的选择。\n\n另外，我也会不时的更新本文，因为有时候当我学习更多后也会改变当初的想法。\n\n## 我应该怎样开始?\n\n如果你的项目不是很小，你应该需要下面几件事：\n\n1. 项目模块化 我个人比较喜欢 [Component-based architecture](http://benmccormick.org/2014/08/07/component-based-development/)，因为他适用于 [various-frameworks](http://derickbailey.com/2015/08/26/building-a-component-based-web-ui-with-modern-javascript-frameworks/)\n\n   同时，考虑一些其他的例子，比如 [BOT](http://www.chris-granger.com/2013/01/24/the-ide-as-data/) 、 [Elm Architecture](https://github.com/evancz/elm-architecture-tutorial/) 或者 [re-frame](https://github.com/Day8/re-frame) 或者 [CycleJS](http://cycle.js.org/)\n   \n2. 模块加载器([RequireJS](http://requirejs.org/)，[Browserify](http://requirejs.org/), [Webpack](https://webpack.github.io/), [ComponentJS](http://componentjs.com/), [SystemJS](https://github.com/systemjs/systemjs))\n\n   这些东西能够帮助我们保持Javascript(或者components)彼此独立和可维护。\n   \n3. 包管理器([npm](http://www.fse.guru/npmjs.org), [jspm](http://jspm.io/), [bower](http://bower.io/))\n   \n   我个人一直比较喜欢 npm ，似乎他是javascript和nodejs真正的标准。另外我会考虑bower来做补足，因为他是一个很好的下载静态资源的工具，但它在管理组件和依赖又不如npm强大。 \n\n4. 自动部署/编译/构建流水线([grunt](http://gruntjs.com/)/[gulp](http://gulpjs.com/)/[brunch](http://brunch.io/)/[broccoli](http://broccolijs.com/))\n   \n   因为，如果一直做重复的事情的话生命是很短暂的。\n\n5. CSS预处理([jss](https://github.com/kof/jss)/[stylus](http://learnboost.github.io/stylus/)/[sass](http://sass-lang.com/)/[css-modules](https://github.com/css-modules/css-modules))和 postprocessors([css0](http://css.github.io/csso/), [autoprefixer](https://github.com/postcss/autoprefixer), [postcss](https://github.com/postcss/postcss))\n  \n   这些工具使css更美好，去除了一些浏览器兼容的问题。是的，我是从2015知道这些的，但是不论如何，它在过去[确实是痛点](http://caniuse.com/#search=svg)。\n   \n6. 构建框架([Bootstrap](http://getbootstrap.com/), [Zurb Foundation](http://foundation.zurb.com/), [Elemental UI](http://elemental-ui.com/), [Material Lite](http://www.getmdl.io/))\n   \n   这些框架让很多web开发者合作，它们会帮助你处理基本的布局和样式。\n   \n   尽管，你可以考虑构建你自己的[解决方案](http://styleguides.io/)，如果你感觉构建很厉害或者希望成为前端专家，或者你需要为你的公司构建基本的[视觉元素](https://uxmag.com/articles/anchoring-your-design-language-in-a-live-style-guide)。\n   \n   如果是这样的话，建议你尽快使用方法论([BEM](https://en.bem.info/), [OOCSS](http://oocss.org/))，它们可以帮助你节约时间。\n   \n   我个人比较喜欢 BEM 命名方式和基本工作流，你能够从 [styleguide for Brainly.com](https://github.com/brainly/style-guide#methodology)找到一些可以帮助你的灵感。\n   \n   如果你不构建基本的组成，建议看一看 [HTML5 Boilerplate](https://html5boilerplate.com/)\n   \n\n7. 测试工具([jasmine](http://jasmine.github.io/), [karma](http://karma-runner.github.io/0.13/index.html), [mocha](https://mochajs.org/), [tape](https://github.com/substack/tape), [itern](https://theintern.github.io/))\n \n    任何人都需要测试，没有例外的。\n\n8. 代码质量监控工具([eslint](http://eslint.org/), [husky](https://medium.com/software-and-beyond), [editorconfig](http://editorconfig.org/))  \n\n9. 可以获取帮助的社区([chats](https://github.com/mr-mig/ru-it-chats), IRC, meetups, twitter)\n\n\n## 好了，下一步呢？\n\n在选择你的工具前有一些值得思考的问题需要解决。\n\n准备好了吗？\n\n\n1. 我需要和其他人合作吗？他们是谁？他们想要什么？\n   \n   这个问题会帮助你选择语言和工作流，这对你和你的伙伴都有帮助。\n   \n2. 我最关注什么？质量，开发速度，还是可维护性？\n\n   这样你可以决定是否试验一些新工具，以及是否能承担失败的风险。\n  \n3. 是否需要开放给第三方？\n   \n   面向的团队不同可能会限制我们语言的选择。\n \n4. 我是否在处理核心的项目  \n   \n   如果你处理核心项目，请最好选择高稳定性的语言和框架，这更安全，让你睡得更好。\n   \n5. 是一个可交互的app还是基本的文档页面。 \n\n   结果很可能是你仅仅需要基本的HTML ＋CSS ＋ tools，或者静态网站生成器或者CMS。\n\n6. 这是一个单一的项目还是其他项目的相关项目？\n   \n   即使你有一系列项目，你也应该用一些组件和样式引导，这些有不错的文档。\n   \n  直接减少代码重用，保持一致性。\n  \n  另外，考虑SEO，和服务端渲染。\n  \n\n## 语言列表\n\n当你回答完上面这些问题后，就可以和你的队友聊聊，然后选择一个语言了。\n\n因为这里有很多的东西，而不是[糟糕的Javascript](https://www.destroyallsoftware.com/talks/wat)，你可以选择\n\n1. 是否有js开发团队\n   \n   考虑[ES6](https://gist.github.com/getify/7ae82fdc2e86bf66bcba#file-gistfile1-md)([babel](https://babeljs.io/)兼容)\n   \n   这会让你的生活简单一些。\n   \n2. 你是否偏爱typed语言？开发typed是否可以？ \n   \n   考虑 [typescript](http://www.typescriptlang.org/)\n   \n3. 函数式编程是否接受？\n   \n   你可以从简单ES6库开始，比如 [lo-dash](https://lodash.com/) 或者 [ramda](http://ramdajs.com/docs/)。\n   \n   这里有一些[教程](http://reactivex.io/learnrx/)和[书](https://leanpub.com/javascript-allonge)来[帮助你](https://github.com/MostlyAdequate/mostly-adequate-guide)开始美好的旅行。\n \n4. 你是否尝试过函数式编程，想要更好的东西？\n   \n   试试 [elm](http://elm-lang.org/) ，很酷的！\n   \n5. 你是否能够全栈？\n  \n   试试 [clojurescript](https://github.com/clojure/clojurescript)，很酷很酷的\n  \n  \n6. 你喜欢沙拉吗？\n\n   试试[scalaJS](http://www.scala-js.org/)\n   \n   \n7. 你知道Haskell吗?\n   \n   试试 [purescript](http://www.purescript.org/)，真的很酷\n   \n8. 想要更多疯狂的？\n   \n   这里有一个可以编译成javascript的语言列表，选一个然后享受吧。\n   \n   \n## 框架列表\n\n1. 你仅仅需要基本的可运行的app？\n   \n   没有时间做更复杂的工作？\n   \n   试试 [angular](https://angularjs.org/). [start looking for help imediately](http://www.fse.guru/2-years-with-angular)\n   \n2. 你是否经常需要快速的原型开发？\n   \n     是否能在未来修复一些问题？\n     \n     试试 [angular](https://angularjs.org/). 一些[问题](http://www.fse.guru/2-years-with-angular)\n     \n3. 你是尝试前端开发的后端？\n   \n   试试 [angular](https://angularjs.org/). 寻找一些[前端开发者](http://www.fse.guru/2-years-with-angular)\n   \n4. 你是否需要很快的进行开发和构建，但是同时会丢失一些特点？\n   \n   试试  [ampersand](http://ampersandjs.com/)/[backbone](http://backbonejs.org/+)\n \n5. 同样的技术选型，怎样从中型到大型？\n\n   把 [marionette](http://marionettejs.com/)/[chaplin](http://chaplinjs.org/)添加到你的backbone里面去，另外可以考虑 [Reackjs](https://facebook.github.io/react/)\n   \n6. 你是否有一些时间来实验，同时得到很大的性能提升？\n   \n   试试[mithril](http://mithril.js.org/)/[knockout](http://knockoutjs.com/)/[aurelia](http://aurelia.io/)+\n   \n7. 你是否有不错的前端实验精神，对函数式编程熟悉？\n\n   试试 [ReactJS](https://facebook.github.io/react/)＋[Redux](https://github.com/rackt/redux)＋[ImmutableJS](https://facebook.github.io/immutable-js/)+\n   \n8. 更多函数式编程技巧？或者偏好交互性强的应用？ \n\n   使用 reactive streams([bacon](https://baconjs.github.io/), [rxJS](http://reactivex.io/)) 或者试试 [Cycle.js](http://cycle.js.org/)(实验性) \n   \n   注意1:  [add streams](http://www.felienne.com/archives/3724) any会是很好的选择，可以推荐别人使用。\n   \n   注意2: 请不要[拒绝使用 FRP的reactive streams ](https://youtu.be/Agu6jipKfYw?list=PLZlJZzHmx31XvgT96DfbXQ4IMb1ryztbp)\n   \n9. 你想要使用严格的验证和通用处理方式？\n\n   你的应用会越来越大？\n   \n   你计划扩充你的团队？\n   \n   你有时间学习新东西？\n   \n   建议花时间学习 [EmberJS](http://emberjs.com/)，他将会是很好的投资!\n   \n\n10. 你是否需要“类桌面应用”？\n \n     你的应用有表格，图例，或者其他分析功能？你在构建企业应用？\n     \n     试试 [ExtJS](http://emberjs.com/)\n     \n11. 你们是一个为其他开发者提供服务的工作室？\n \n     你最好有一个不错的工具集，另外，同事之间最好有一些公共用例。\n     \n     \n12. 你是一个为他人提供工具的自由开发者？\n \n     适应他们的选择。\n \n     尝试angular，这将不会造成多大麻烦，让其他人得到他们想要的。\n     \n     注意：如果别人付费，请不要改变客户的需求\n     \n13. 你正在构建一个有吸引力的产品，它将会很多人使用？\n\n    有了明确的需求后我们就从上面的列表中选择一个合适的框架。\n    \n14. 关于开发什么样的应用你有明确的需求（比如10屏的移动应用) \n\n    花两周时间来试验特定的需求（[ionic](http://ionicframework.com/), [famous](http://famous.org/), [Sencha Touch](https://www.sencha.com/products/touch/))\n    \n    \n## 怎样开始编码？\n\n1. 花一些时间阅读你所选择框架或者工具的文档。\n2. 在社区里面询问一些经验开发者怎样算是优秀项目的开端。\n3. 准备所有的工具。\n4. 极客精神。但是我建议更加[工程化](http://www.fse.guru/software-engineering-101-preface)一点。\n5. ...\n6. 成功。\n\n#### 不知道怎么用我介绍的一些不常见框架？\n\n看看 [TodoMVC Examples](https://github.com/tastejs/todomvc)，找到你选择的框架。\n\n但是记住，这些项目只是示例，大多数情况下他们不适合大中型项目。\n\n## 我不想做决定，告诉我怎么办？\n\n好，好，冷静下来。\n\n如果你不想做决定，你可以选择 EmberJS。或者你胆大，可以尝试 ReactJS + Redux + ES6 + webpack + npm + jss + autoprefixer + eslint + Elemental UI + karma，读[这篇文章](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html)。\n\n\n## 我看到了很多关于ReactJS的讨论，为什么？\n\n这是web开发的未来。\n\n这里有一片很好的[文章](http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome)，来解释这个现象。\n\n\n同时，很多优秀的开发者在使用它，你可以找出一些好的项目，这一定很棒，我保证！\n\n如果不是，你可以任何时候回到这篇文章，在评论里面留下你的话。\n\n\n如果你对怎样成为一名前端开发师感兴趣，可以看看[这里](https://news.ycombinator.com/item?id=10392731)","mobiledoc":null,"html":"<h2 id=\"\">怎样选择前端框架</h2>\n\n<blockquote>\n  <p>怎样选择适合自己的前端框架，并在高产但良莠不齐的前端社区中保持理性</p>\n  \n  <p>翻译自：<a href=\"http://fse.guru/\">http://fse.guru/</a></p>\n</blockquote>\n\n<h2 id=\"\">介绍</h2>\n\n<p>Hello，开发朋友们！</p>\n\n<p>下面你将看到一些比较主观的工具和框架。</p>\n\n<p>但不要害怕！</p>\n\n<p>你可以选择任何你所熟悉的，或者忽略他们直接用你自己喜欢的就好了。</p>\n\n<p>本文希望帮助你了解前端社区中海量的工具。</p>\n\n<p>当然，这些只是一些可选的列表，当你需要做出选择的时候帮助你抉择。 </p>\n\n<h2 id=\"\">我自己使用它吗？</h2>\n\n<p>是的，当我需要开始项目的时候，我用它来作为提醒。</p>\n\n<p>同时，每当有人问“我该使用什么框架呢？”的时候，我就会把这篇文章给他看。</p>\n\n<p>因为，正如你明白的，事情没有绝对的对与错，但是有一些优质的框架能够帮助做出我们更好的选择。</p>\n\n<p>另外，我也会不时的更新本文，因为有时候当我学习更多后也会改变当初的想法。</p>\n\n<h2 id=\"\">我应该怎样开始?</h2>\n\n<p>如果你的项目不是很小，你应该需要下面几件事：</p>\n\n<ol>\n<li><p>项目模块化 我个人比较喜欢 <a href=\"http://benmccormick.org/2014/08/07/component-based-development/\">Component-based architecture</a>，因为他适用于 <a href=\"http://derickbailey.com/2015/08/26/building-a-component-based-web-ui-with-modern-javascript-frameworks/\">various-frameworks</a></p>\n\n<p>同时，考虑一些其他的例子，比如 <a href=\"http://www.chris-granger.com/2013/01/24/the-ide-as-data/\">BOT</a> 、 <a href=\"https://github.com/evancz/elm-architecture-tutorial/\">Elm Architecture</a> 或者 <a href=\"https://github.com/Day8/re-frame\">re-frame</a> 或者 <a href=\"http://cycle.js.org/\">CycleJS</a></p></li>\n<li><p>模块加载器(<a href=\"http://requirejs.org/\">RequireJS</a>，<a href=\"http://requirejs.org/\">Browserify</a>, <a href=\"https://webpack.github.io/\">Webpack</a>, <a href=\"http://componentjs.com/\">ComponentJS</a>, <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>)</p>\n\n<p>这些东西能够帮助我们保持Javascript(或者components)彼此独立和可维护。</p></li>\n<li><p>包管理器(<a href=\"http://www.fse.guru/npmjs.org\">npm</a>, <a href=\"http://jspm.io/\">jspm</a>, <a href=\"http://bower.io/\">bower</a>)</p>\n\n<p>我个人一直比较喜欢 npm ，似乎他是javascript和nodejs真正的标准。另外我会考虑bower来做补足，因为他是一个很好的下载静态资源的工具，但它在管理组件和依赖又不如npm强大。 </p></li>\n<li><p>自动部署/编译/构建流水线(<a href=\"http://gruntjs.com/\">grunt</a>/<a href=\"http://gulpjs.com/\">gulp</a>/<a href=\"http://brunch.io/\">brunch</a>/<a href=\"http://broccolijs.com/\">broccoli</a>)</p>\n\n<p>因为，如果一直做重复的事情的话生命是很短暂的。</p></li>\n<li><p>CSS预处理(<a href=\"https://github.com/kof/jss\">jss</a>/<a href=\"http://learnboost.github.io/stylus/\">stylus</a>/<a href=\"http://sass-lang.com/\">sass</a>/<a href=\"https://github.com/css-modules/css-modules\">css-modules</a>)和 postprocessors(<a href=\"http://css.github.io/csso/\">css0</a>, <a href=\"https://github.com/postcss/autoprefixer\">autoprefixer</a>, <a href=\"https://github.com/postcss/postcss\">postcss</a>)</p>\n\n<p>这些工具使css更美好，去除了一些浏览器兼容的问题。是的，我是从2015知道这些的，但是不论如何，它在过去<a href=\"http://caniuse.com/#search=svg\">确实是痛点</a>。</p></li>\n<li><p>构建框架(<a href=\"http://getbootstrap.com/\">Bootstrap</a>, <a href=\"http://foundation.zurb.com/\">Zurb Foundation</a>, <a href=\"http://elemental-ui.com/\">Elemental UI</a>, <a href=\"http://www.getmdl.io/\">Material Lite</a>)</p>\n\n<p>这些框架让很多web开发者合作，它们会帮助你处理基本的布局和样式。</p>\n\n<p>尽管，你可以考虑构建你自己的<a href=\"http://styleguides.io/\">解决方案</a>，如果你感觉构建很厉害或者希望成为前端专家，或者你需要为你的公司构建基本的<a href=\"https://uxmag.com/articles/anchoring-your-design-language-in-a-live-style-guide\">视觉元素</a>。</p>\n\n<p>如果是这样的话，建议你尽快使用方法论(<a href=\"https://en.bem.info/\">BEM</a>, <a href=\"http://oocss.org/\">OOCSS</a>)，它们可以帮助你节约时间。</p>\n\n<p>我个人比较喜欢 BEM 命名方式和基本工作流，你能够从 <a href=\"https://github.com/brainly/style-guide#methodology\">styleguide for Brainly.com</a>找到一些可以帮助你的灵感。</p>\n\n<p>如果你不构建基本的组成，建议看一看 <a href=\"https://html5boilerplate.com/\">HTML5 Boilerplate</a></p></li>\n<li><p>测试工具(<a href=\"http://jasmine.github.io/\">jasmine</a>, <a href=\"http://karma-runner.github.io/0.13/index.html\">karma</a>, <a href=\"https://mochajs.org/\">mocha</a>, <a href=\"https://github.com/substack/tape\">tape</a>, <a href=\"https://theintern.github.io/\">itern</a>)</p>\n\n<p>任何人都需要测试，没有例外的。</p></li>\n<li><p>代码质量监控工具(<a href=\"http://eslint.org/\">eslint</a>, <a href=\"https://medium.com/software-and-beyond\">husky</a>, <a href=\"http://editorconfig.org/\">editorconfig</a>)  </p></li>\n<li><p>可以获取帮助的社区(<a href=\"https://github.com/mr-mig/ru-it-chats\">chats</a>, IRC, meetups, twitter)</p></li>\n</ol>\n\n<h2 id=\"\">好了，下一步呢？</h2>\n\n<p>在选择你的工具前有一些值得思考的问题需要解决。</p>\n\n<p>准备好了吗？</p>\n\n<ol>\n<li><p>我需要和其他人合作吗？他们是谁？他们想要什么？</p>\n\n<p>这个问题会帮助你选择语言和工作流，这对你和你的伙伴都有帮助。</p></li>\n<li><p>我最关注什么？质量，开发速度，还是可维护性？</p>\n\n<p>这样你可以决定是否试验一些新工具，以及是否能承担失败的风险。</p></li>\n<li><p>是否需要开放给第三方？</p>\n\n<p>面向的团队不同可能会限制我们语言的选择。</p></li>\n<li><p>我是否在处理核心的项目  </p>\n\n<p>如果你处理核心项目，请最好选择高稳定性的语言和框架，这更安全，让你睡得更好。</p></li>\n<li><p>是一个可交互的app还是基本的文档页面。 </p>\n\n<p>结果很可能是你仅仅需要基本的HTML ＋CSS ＋ tools，或者静态网站生成器或者CMS。</p></li>\n<li><p>这是一个单一的项目还是其他项目的相关项目？</p>\n\n<p>即使你有一系列项目，你也应该用一些组件和样式引导，这些有不错的文档。</p>\n\n<p>直接减少代码重用，保持一致性。</p>\n\n<p>另外，考虑SEO，和服务端渲染。</p></li>\n</ol>\n\n<h2 id=\"\">语言列表</h2>\n\n<p>当你回答完上面这些问题后，就可以和你的队友聊聊，然后选择一个语言了。</p>\n\n<p>因为这里有很多的东西，而不是<a href=\"https://www.destroyallsoftware.com/talks/wat\">糟糕的Javascript</a>，你可以选择</p>\n\n<ol>\n<li><p>是否有js开发团队</p>\n\n<p>考虑<a href=\"https://gist.github.com/getify/7ae82fdc2e86bf66bcba#file-gistfile1-md\">ES6</a>(<a href=\"https://babeljs.io/\">babel</a>兼容)</p>\n\n<p>这会让你的生活简单一些。</p></li>\n<li><p>你是否偏爱typed语言？开发typed是否可以？ </p>\n\n<p>考虑 <a href=\"http://www.typescriptlang.org/\">typescript</a></p></li>\n<li><p>函数式编程是否接受？</p>\n\n<p>你可以从简单ES6库开始，比如 <a href=\"https://lodash.com/\">lo-dash</a> 或者 <a href=\"http://ramdajs.com/docs/\">ramda</a>。</p>\n\n<p>这里有一些<a href=\"http://reactivex.io/learnrx/\">教程</a>和<a href=\"https://leanpub.com/javascript-allonge\">书</a>来<a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\">帮助你</a>开始美好的旅行。</p></li>\n<li><p>你是否尝试过函数式编程，想要更好的东西？</p>\n\n<p>试试 <a href=\"http://elm-lang.org/\">elm</a> ，很酷的！</p></li>\n<li><p>你是否能够全栈？</p>\n\n<p>试试 <a href=\"https://github.com/clojure/clojurescript\">clojurescript</a>，很酷很酷的</p></li>\n<li><p>你喜欢沙拉吗？</p>\n\n<p>试试<a href=\"http://www.scala-js.org/\">scalaJS</a></p></li>\n<li><p>你知道Haskell吗?</p>\n\n<p>试试 <a href=\"http://www.purescript.org/\">purescript</a>，真的很酷</p></li>\n<li><p>想要更多疯狂的？</p>\n\n<p>这里有一个可以编译成javascript的语言列表，选一个然后享受吧。</p></li>\n</ol>\n\n<h2 id=\"\">框架列表</h2>\n\n<ol>\n<li><p>你仅仅需要基本的可运行的app？</p>\n\n<p>没有时间做更复杂的工作？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. <a href=\"http://www.fse.guru/2-years-with-angular\">start looking for help imediately</a></p></li>\n<li><p>你是否经常需要快速的原型开发？</p>\n\n<p>是否能在未来修复一些问题？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. 一些<a href=\"http://www.fse.guru/2-years-with-angular\">问题</a></p></li>\n<li><p>你是尝试前端开发的后端？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. 寻找一些<a href=\"http://www.fse.guru/2-years-with-angular\">前端开发者</a></p></li>\n<li><p>你是否需要很快的进行开发和构建，但是同时会丢失一些特点？</p>\n\n<p>试试  <a href=\"http://ampersandjs.com/\">ampersand</a>/<a href=\"http://backbonejs.org/+\">backbone</a></p></li>\n<li><p>同样的技术选型，怎样从中型到大型？</p>\n\n<p>把 <a href=\"http://marionettejs.com/\">marionette</a>/<a href=\"http://chaplinjs.org/\">chaplin</a>添加到你的backbone里面去，另外可以考虑 <a href=\"https://facebook.github.io/react/\">Reackjs</a></p></li>\n<li><p>你是否有一些时间来实验，同时得到很大的性能提升？</p>\n\n<p>试试<a href=\"http://mithril.js.org/\">mithril</a>/<a href=\"http://knockoutjs.com/\">knockout</a>/<a href=\"http://aurelia.io/\">aurelia</a>+</p></li>\n<li><p>你是否有不错的前端实验精神，对函数式编程熟悉？</p>\n\n<p>试试 <a href=\"https://facebook.github.io/react/\">ReactJS</a>＋<a href=\"https://github.com/rackt/redux\">Redux</a>＋<a href=\"https://facebook.github.io/immutable-js/\">ImmutableJS</a>+</p></li>\n<li><p>更多函数式编程技巧？或者偏好交互性强的应用？ </p>\n\n<p>使用 reactive streams(<a href=\"https://baconjs.github.io/\">bacon</a>, <a href=\"http://reactivex.io/\">rxJS</a>) 或者试试 <a href=\"http://cycle.js.org/\">Cycle.js</a>(实验性) </p>\n\n<p>注意1:  <a href=\"http://www.felienne.com/archives/3724\">add streams</a> any会是很好的选择，可以推荐别人使用。</p>\n\n<p>注意2: 请不要<a href=\"https://youtu.be/Agu6jipKfYw?list=PLZlJZzHmx31XvgT96DfbXQ4IMb1ryztbp\">拒绝使用 FRP的reactive streams </a></p></li>\n<li><p>你想要使用严格的验证和通用处理方式？</p>\n\n<p>你的应用会越来越大？</p>\n\n<p>你计划扩充你的团队？</p>\n\n<p>你有时间学习新东西？</p>\n\n<p>建议花时间学习 <a href=\"http://emberjs.com/\">EmberJS</a>，他将会是很好的投资!</p></li>\n<li><p>你是否需要“类桌面应用”？</p>\n\n<p>你的应用有表格，图例，或者其他分析功能？你在构建企业应用？</p>\n\n<p>试试 <a href=\"http://emberjs.com/\">ExtJS</a></p></li>\n<li><p>你们是一个为其他开发者提供服务的工作室？</p>\n\n<p>你最好有一个不错的工具集，另外，同事之间最好有一些公共用例。</p></li>\n<li><p>你是一个为他人提供工具的自由开发者？</p>\n\n<p>适应他们的选择。</p>\n\n<p>尝试angular，这将不会造成多大麻烦，让其他人得到他们想要的。</p>\n\n<p>注意：如果别人付费，请不要改变客户的需求</p></li>\n<li><p>你正在构建一个有吸引力的产品，它将会很多人使用？</p>\n\n<p>有了明确的需求后我们就从上面的列表中选择一个合适的框架。</p></li>\n<li><p>关于开发什么样的应用你有明确的需求（比如10屏的移动应用) </p>\n\n<p>花两周时间来试验特定的需求（<a href=\"http://ionicframework.com/\">ionic</a>, <a href=\"http://famous.org/\">famous</a>, <a href=\"https://www.sencha.com/products/touch/\">Sencha Touch</a>)</p></li>\n</ol>\n\n<h2 id=\"\">怎样开始编码？</h2>\n\n<ol>\n<li>花一些时间阅读你所选择框架或者工具的文档。  </li>\n<li>在社区里面询问一些经验开发者怎样算是优秀项目的开端。  </li>\n<li>准备所有的工具。  </li>\n<li>极客精神。但是我建议更加<a href=\"http://www.fse.guru/software-engineering-101-preface\">工程化</a>一点。  </li>\n<li>...  </li>\n<li>成功。</li>\n</ol>\n\n<h4 id=\"\">不知道怎么用我介绍的一些不常见框架？</h4>\n\n<p>看看 <a href=\"https://github.com/tastejs/todomvc\">TodoMVC Examples</a>，找到你选择的框架。</p>\n\n<p>但是记住，这些项目只是示例，大多数情况下他们不适合大中型项目。</p>\n\n<h2 id=\"\">我不想做决定，告诉我怎么办？</h2>\n\n<p>好，好，冷静下来。</p>\n\n<p>如果你不想做决定，你可以选择 EmberJS。或者你胆大，可以尝试 ReactJS + Redux + ES6 + webpack + npm + jss + autoprefixer + eslint + Elemental UI + karma，读<a href=\"http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html\">这篇文章</a>。</p>\n\n<h2 id=\"reactjs\">我看到了很多关于ReactJS的讨论，为什么？</h2>\n\n<p>这是web开发的未来。</p>\n\n<p>这里有一片很好的<a href=\"http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome\">文章</a>，来解释这个现象。</p>\n\n<p>同时，很多优秀的开发者在使用它，你可以找出一些好的项目，这一定很棒，我保证！</p>\n\n<p>如果不是，你可以任何时候回到这篇文章，在评论里面留下你的话。</p>\n\n<p>如果你对怎样成为一名前端开发师感兴趣，可以看看<a href=\"https://news.ycombinator.com/item?id=10392731\">这里</a></p>","image":"/content/images/2016/07/intro-bg.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:44:50","created_by":1,"updated_at":"2016-07-05 23:45:55","updated_by":1,"published_at":"2015-12-21 23:44:00","published_by":1},{"id":49,"uuid":"f9118686-14ec-4c44-aa36-48c31ca25b4b","title":"前端地图截屏方案","slug":"map-screenshot","markdown":"截屏一直以来，都是客户端的专利，对于浏览器端可谓无能为力。\n\n不过，自从canvas出来以后，就不一样了。\n\nHTML5中canvas的方法，`toDataURL()` 可将canvas的内容保存为图片。\n\n简单保存canvas图片的代码如下：\n\n    function convertCanvasToImage(canvas) {\n        var image = new Image();\n        image.src = canvas.toDataURL(\"image/png\");\n        return image;\n    }\n\n对于普通canvas截图没有问题，甚至对于整个DOM树也可以先转换成canvas，然后转换成截图。业界有成熟的类似的类库 <a href=\"http://html2canvas.hertzen.com/\" title=\"http://html2canvas.hertzen.com/\" target=\"_blank\">html2canvas</a> 。\n\n### 问题\n\n工作中，需要对地图截图，遇到不少问题，折腾了很久，在此记录。\n\n原图：\n\n![](/content/images/2016/07/canvas_a.png)\n\n最后的截图代码：\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/jevisixezi/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n\n### 问题一 跨域\n\n截图失败，浏览器提示：`Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.`\n\n为什么会出现跨域问题呢？仔细一想，地图上有一些图片，存储在地图服务商的服务器，当我们toDataURL的时候取不到图片数据，跨域也就能够想通了。\n\n解决方式，暂时不获取跨域图片，直接try catch掉。暂时能够截图，看到的效果:\n \n\n![](/content/images/2016/07/canvas_b.png)\n\n### 问题二 圆角模糊\n\n如上图中，圆形中间多了一个叉，暂时不知道原因，解决方式是在截图前去除圆角。\n\n![](/content/images/2016/07/canvas_c.png)\n\n### 问题三 图片不显示\n\n其实是问题一留下的问题，截图左下角，有个高德的图片没有显示，问题一解决方式是绕过，但问题还是要解决。\n\n在服务器端，是不存在跨域。所以，问题三的解决方式，我们可以在本地起一个代理服务器，代理通过获取图片，然后设置setHeader('Access-Control-Allow-Headers', '*’); 然后给本地浏览器使用。\n\n代理服务器代码：\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fakizitulu/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n通过服务器跨域，然后允许所有访问图片，就可以跨域了。\n\n### 问题四 地理名称不显示\n\n通过上图可以看到，地图截图所有的地理位置名称都没有。打开log后可以看到，问题还是出在跨域上。地图所有的地理位置名称也是通过图片实现，图片存在地图服务商的服务器上，通过canvas渲染，和问题三的单纯的图片不太一样。\n\n要解决这个问题，必须地图服务器设置Header为”Access-Control-Allow-Headers: *”。通过公司关系，和高德产品经理、开发联系过，对方回答没办法设置这个，处于安全考虑。于是，这个问题无解。\n\n最后效果：\n\n![](/content/images/2016/07/canvas_e.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","mobiledoc":null,"html":"<p>截屏一直以来，都是客户端的专利，对于浏览器端可谓无能为力。</p>\n\n<p>不过，自从canvas出来以后，就不一样了。</p>\n\n<p>HTML5中canvas的方法，<code>toDataURL()</code> 可将canvas的内容保存为图片。</p>\n\n<p>简单保存canvas图片的代码如下：</p>\n\n<pre><code>function convertCanvasToImage(canvas) {\n    var image = new Image();\n    image.src = canvas.toDataURL(\"image/png\");\n    return image;\n}\n</code></pre>\n\n<p>对于普通canvas截图没有问题，甚至对于整个DOM树也可以先转换成canvas，然后转换成截图。业界有成熟的类似的类库 <a href=\"http://html2canvas.hertzen.com/\" title=\"http://html2canvas.hertzen.com/\" target=\"_blank\">html2canvas</a> 。</p>\n\n<h3 id=\"\">问题</h3>\n\n<p>工作中，需要对地图截图，遇到不少问题，折腾了很久，在此记录。</p>\n\n<p>原图：</p>\n\n<p><img src=\"/content/images/2016/07/canvas_a.png\" alt=\"\" /></p>\n\n<p>最后的截图代码：</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/jevisixezi/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<h3 id=\"\">问题一 跨域</h3>\n\n<p>截图失败，浏览器提示：<code>Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.</code></p>\n\n<p>为什么会出现跨域问题呢？仔细一想，地图上有一些图片，存储在地图服务商的服务器，当我们toDataURL的时候取不到图片数据，跨域也就能够想通了。</p>\n\n<p>解决方式，暂时不获取跨域图片，直接try catch掉。暂时能够截图，看到的效果:</p>\n\n<p><img src=\"/content/images/2016/07/canvas_b.png\" alt=\"\" /></p>\n\n<h3 id=\"\">问题二 圆角模糊</h3>\n\n<p>如上图中，圆形中间多了一个叉，暂时不知道原因，解决方式是在截图前去除圆角。</p>\n\n<p><img src=\"/content/images/2016/07/canvas_c.png\" alt=\"\" /></p>\n\n<h3 id=\"\">问题三 图片不显示</h3>\n\n<p>其实是问题一留下的问题，截图左下角，有个高德的图片没有显示，问题一解决方式是绕过，但问题还是要解决。</p>\n\n<p>在服务器端，是不存在跨域。所以，问题三的解决方式，我们可以在本地起一个代理服务器，代理通过获取图片，然后设置setHeader('Access-Control-Allow-Headers', '*’); 然后给本地浏览器使用。</p>\n\n<p>代理服务器代码：</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/fakizitulu/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<p>通过服务器跨域，然后允许所有访问图片，就可以跨域了。</p>\n\n<h3 id=\"\">问题四 地理名称不显示</h3>\n\n<p>通过上图可以看到，地图截图所有的地理位置名称都没有。打开log后可以看到，问题还是出在跨域上。地图所有的地理位置名称也是通过图片实现，图片存在地图服务商的服务器上，通过canvas渲染，和问题三的单纯的图片不太一样。</p>\n\n<p>要解决这个问题，必须地图服务器设置Header为”Access-Control-Allow-Headers: *”。通过公司关系，和高德产品经理、开发联系过，对方回答没办法设置这个，处于安全考虑。于是，这个问题无解。</p>\n\n<p>最后效果：</p>\n\n<p><img src=\"/content/images/2016/07/canvas_e.png\" alt=\"\" /></p>","image":"/content/images/2016/07/g.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:47:29","created_by":1,"updated_at":"2016-07-05 23:51:19","updated_by":1,"published_at":"2015-10-08 23:47:00","published_by":1},{"id":50,"uuid":"ecc110e1-fa76-4b4c-a1af-f9d1d1e4b02e","title":"不一样的山顶角","slug":"san-ding-jiao","markdown":"说到“山顶角”，相信大多数前端人都能够在几秒内想到实现方式、兼容方式。\n\n如果不清楚山顶角的同学，请点这里: [https://css-tricks.com/snippets/css/css-triangle](https://css-tricks.com/snippets/css/css-triangle)\n\n但是，如果要实现下面这样的带阴影的山顶角，border的实现方式就无能为力了。\n\n![](/content/images/2016/07/sanjiao1.png)\n\n上图中的小三角，其阴影和整个弹窗的阴影大小要一样。\n\n实现\n--------\n\n###方案一 图片\n\n最省力，最直接，但是最不优雅。\n\n### 方案二 Unicode\n\n使用unicode生成一个三角，然后text-shadow实现阴影\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/jiromanopo/embed?html,css,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n可以通过 scaleX实现大小，通过text-shadow实现阴影范围。\n\n\n### 方案三 Rotate\n\n小矩形定位到需要的位置\n\n![](/content/images/2016/07/sanjiao3.png)\n\n然后旋转45度:  \n\n```\n-webkit-transform: translateY(-15px) rotate(45deg);\n```\n\n![](/content/images/2016/07/sanjiao4.png)\n\n缺点就是，兼容浏览器比较麻烦，ie里面还要动用 滤镜。\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/nexeqaxula/embed?html,css,output\">带阴影的山顶角 on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n","mobiledoc":null,"html":"<p>说到“山顶角”，相信大多数前端人都能够在几秒内想到实现方式、兼容方式。</p>\n\n<p>如果不清楚山顶角的同学，请点这里: <a href=\"https://css-tricks.com/snippets/css/css-triangle\">https://css-tricks.com/snippets/css/css-triangle</a></p>\n\n<p>但是，如果要实现下面这样的带阴影的山顶角，border的实现方式就无能为力了。</p>\n\n<p><img src=\"/content/images/2016/07/sanjiao1.png\" alt=\"\" /></p>\n\n<p>上图中的小三角，其阴影和整个弹窗的阴影大小要一样。</p>\n\n<h2 id=\"\">实现</h2>\n\n<h3 id=\"\">方案一 图片</h3>\n\n<p>最省力，最直接，但是最不优雅。</p>\n\n<h3 id=\"unicode\">方案二 Unicode</h3>\n\n<p>使用unicode生成一个三角，然后text-shadow实现阴影</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/jiromanopo/embed?html,css,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<p>可以通过 scaleX实现大小，通过text-shadow实现阴影范围。</p>\n\n<h3 id=\"rotate\">方案三 Rotate</h3>\n\n<p>小矩形定位到需要的位置</p>\n\n<p><img src=\"/content/images/2016/07/sanjiao3.png\" alt=\"\" /></p>\n\n<p>然后旋转45度:  </p>\n\n<pre><code>-webkit-transform: translateY(-15px) rotate(45deg);\n</code></pre>\n\n<p><img src=\"/content/images/2016/07/sanjiao4.png\" alt=\"\" /></p>\n\n<p>缺点就是，兼容浏览器比较麻烦，ie里面还要动用 滤镜。</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/nexeqaxula/embed?html,css,output\">带阴影的山顶角 on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>","image":"/content/images/2016/07/a.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:54:52","created_by":1,"updated_at":"2016-07-06 00:13:14","updated_by":1,"published_at":"2015-10-07 23:54:00","published_by":1},{"id":51,"uuid":"e52962a4-ceab-48b3-bc72-0a47966298d5","title":"前后端分离场景下的另类登录认证方案","slug":"f2e-another-auth","markdown":"在我们日常开发中，通常会接入第三方的登录，比如QQ、微信、微博等。在公司内部，也会介入公司的内网登录。通常情况下，我们的方案是：\n\n![](/content/images/2016/07/a.png)\n\n当应用检测到没有用户信息时，就会跳转到(302)第三方服务，用户在第三方服务登录后返回应用时会带上用户的信息(Session)，这就是一般情况下我们的登录认证过程。\n\n<hr>\n\n在前后端分离的场景下，一般做法是中间层(Node)检查用户请求的Header中是否存在用户信息，如果不存在则向第三方服务请求认证(302)，认证成功后返回当前的登录用户的信息，再进行其他业务逻辑的处理。\n\n既然标题有另类一词，我们肯定不能局限于“一般做法”。在我们的前后端分离场景中，由Node充当中间层，Java提供HTTP Restful接口，我们场景不同点在于**第三方服务（通常是集团登录认证服务）不支持Node接口**，只提供Java接口。所以我们必须通过 Node去请求Java，由Java去请求认证服务然后返回Node。方案如下：\n\n![](/content/images/2016/07/b--1-.png)\n\n看上面流程图，我们的方案不过是在Node和Auth Server中增加了Java Server，并没有其他异处。只因这个方案和一般前后端分离场景的认证不太一样，里面的需要注意的细节较多，可以记录一下。\n\n首先是用户通过url的输入，访问页面的过程，流程如下：\n\n![](/content/images/2016/07/c--1-.png)\n\n**讲解之前注意：**\n\n>在我们的场景中：\n\n>Node与Java Web的Ajax要么带有效cookie，要么带tickets(一次有效)。\n\n>我们的页面是 http://localhost\n\n浏览器通过url访问Node服务器(即页面请求)，Node会检测用户的请求里面是否带有用户信息的Cookie。如果没有，则向Java Web发出用户信息的请求，由于没有有效cookie，Java Web判定当前用户未登录，返回 `{code:302, url: xxx}`。Node接收到302后，直接 redirect 到刚才的url上。这个url通常是: `http://www.xxx.com?redirect=http://localhost`\n\n用户在Home(第三方登录认证服务)完成登录过程后，会返回我们的localhost，并且带有tickets: `http://localhost?tickets=asdfasdfasdfasdf。`\n\n第二次，我们又回到了页面请求的步骤，同理Node检测不到用户请求中的用户信息有效Cookie，会向Java Web出用户信息的请求，不同之处在于会带上刚才Home返回的url上的tickets。Java Web发现请求中没有cookie但是有tickets，于是拿着tickets去向Home认证，此tickets是否有效，有效Home会返回用户信息，Java Web存储此用户信息并且返回给Node。Node拿到用户信息后，立即往response里面写入用户cookie，同时redirect到/(作用是，去掉url上的tickets)。\n\n第三次浏览器向Node发出页面请求，由于Node检测到请求中有cookie，就会直接返回页面给浏览器。之后用户的所有行为操作的ajax请求，都会带上cookie，所以都是合法的。\n\n---\n\n**思考：**\n\n上面认证方案中，其实只需要发出两次页面请求，也就是访问两次 localhost。我们第三次redirect的原因是，去掉url的tickets。如果不去掉也没有影响，但是会出现用户手动去刷新页面的情况，手动刷新页面的tickets是不可用的，java会返回403，影响用户使用。\n\n**总结：**\n\n我们的认证登录方案，和传统的方案并无差别，不过多了中间Node和Java的交互而已。需要注意的就是cookie的写入时机和tickets的去除。","mobiledoc":null,"html":"<p>在我们日常开发中，通常会接入第三方的登录，比如QQ、微信、微博等。在公司内部，也会介入公司的内网登录。通常情况下，我们的方案是：</p>\n\n<p><img src=\"/content/images/2016/07/a.png\" alt=\"\" /></p>\n\n<p>当应用检测到没有用户信息时，就会跳转到(302)第三方服务，用户在第三方服务登录后返回应用时会带上用户的信息(Session)，这就是一般情况下我们的登录认证过程。</p>\n\n<hr>\n\n<p>在前后端分离的场景下，一般做法是中间层(Node)检查用户请求的Header中是否存在用户信息，如果不存在则向第三方服务请求认证(302)，认证成功后返回当前的登录用户的信息，再进行其他业务逻辑的处理。</p>\n\n<p>既然标题有另类一词，我们肯定不能局限于“一般做法”。在我们的前后端分离场景中，由Node充当中间层，Java提供HTTP Restful接口，我们场景不同点在于<strong>第三方服务（通常是集团登录认证服务）不支持Node接口</strong>，只提供Java接口。所以我们必须通过 Node去请求Java，由Java去请求认证服务然后返回Node。方案如下：</p>\n\n<p><img src=\"/content/images/2016/07/b--1-.png\" alt=\"\" /></p>\n\n<p>看上面流程图，我们的方案不过是在Node和Auth Server中增加了Java Server，并没有其他异处。只因这个方案和一般前后端分离场景的认证不太一样，里面的需要注意的细节较多，可以记录一下。</p>\n\n<p>首先是用户通过url的输入，访问页面的过程，流程如下：</p>\n\n<p><img src=\"/content/images/2016/07/c--1-.png\" alt=\"\" /></p>\n\n<p><strong>讲解之前注意：</strong></p>\n\n<blockquote>\n  <p>在我们的场景中：</p>\n  \n  <p>Node与Java Web的Ajax要么带有效cookie，要么带tickets(一次有效)。</p>\n  \n  <p>我们的页面是 <a href=\"http://localhost\">http://localhost</a></p>\n</blockquote>\n\n<p>浏览器通过url访问Node服务器(即页面请求)，Node会检测用户的请求里面是否带有用户信息的Cookie。如果没有，则向Java Web发出用户信息的请求，由于没有有效cookie，Java Web判定当前用户未登录，返回 <code>{code:302, url: xxx}</code>。Node接收到302后，直接 redirect 到刚才的url上。这个url通常是: <code>http://www.xxx.com?redirect=http://localhost</code></p>\n\n<p>用户在Home(第三方登录认证服务)完成登录过程后，会返回我们的localhost，并且带有tickets: <code>http://localhost?tickets=asdfasdfasdfasdf。</code></p>\n\n<p>第二次，我们又回到了页面请求的步骤，同理Node检测不到用户请求中的用户信息有效Cookie，会向Java Web出用户信息的请求，不同之处在于会带上刚才Home返回的url上的tickets。Java Web发现请求中没有cookie但是有tickets，于是拿着tickets去向Home认证，此tickets是否有效，有效Home会返回用户信息，Java Web存储此用户信息并且返回给Node。Node拿到用户信息后，立即往response里面写入用户cookie，同时redirect到/(作用是，去掉url上的tickets)。</p>\n\n<p>第三次浏览器向Node发出页面请求，由于Node检测到请求中有cookie，就会直接返回页面给浏览器。之后用户的所有行为操作的ajax请求，都会带上cookie，所以都是合法的。</p>\n\n<hr />\n\n<p><strong>思考：</strong></p>\n\n<p>上面认证方案中，其实只需要发出两次页面请求，也就是访问两次 localhost。我们第三次redirect的原因是，去掉url的tickets。如果不去掉也没有影响，但是会出现用户手动去刷新页面的情况，手动刷新页面的tickets是不可用的，java会返回403，影响用户使用。</p>\n\n<p><strong>总结：</strong></p>\n\n<p>我们的认证登录方案，和传统的方案并无差别，不过多了中间Node和Java的交互而已。需要注意的就是cookie的写入时机和tickets的去除。</p>","image":"/content/images/2016/07/c--1--1.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-06 00:13:57","created_by":1,"updated_at":"2016-07-06 00:16:43","updated_by":1,"published_at":"2015-10-07 00:13:00","published_by":1},{"id":52,"uuid":"fed36067-13f7-493f-9540-6c06f40914f4","title":"React Diff 算法","slug":"react-diff","markdown":"## React介绍\n\nReact是Facebook开发的一款JS库，用于构建用户界面的类库。\n\n它采用声明式范例，可以传递声明代码，最大限度地减少与DOM的交互。\n\n特点：\n\n1. 声明式设计：React采用声明范式，你可以轻松描述你的应用\n2. 高效：React通过对DOM的模拟表现，最大限度地较少与DOM的交互。\n3. 灵活：React可以与你所知道的库或框架很好地工作。\n\n在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而**复杂或频繁的DOM操作通常是性能瓶颈产生的原因**。\n\n\nReact为此引入了虚拟DOM（Virtual DOM）的机制：\n\n**在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的虚拟DOM树进行对比，得到虚拟DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。**\n\n## React Diff 算法\n\n虚拟DOM作为React的一大核心技术，了解其实现原理对于灵活应用有着很大帮助。\n\n#### Javascript 虚拟DOM对象\n\n在我们项目中申明一个组件是这样的：\n\n    \n    react.createElement('div', null, [\n        // 创建一个img\n        react.createElement('img', { src: \"avatar.png\", class: \"profile\" }),\n        // 或者\n        react.createElement('h1', null, [[user.firstName, user.lastName].join(' ')])\n    ]);\n\n最后，React都会转换成类似这样的基本对象：\n    \n    {\n        tagName: 'div',\n        // 节点包含的属性\n        properties: {\n            style: {\n                color: '#fff'\n            }\n        },\n        // 子节点\n        children: [],\n        // 节点的唯一标识\n        key: 1\n    }\n\n#### Javascript DOM节点树\n然后，React把Javascript DOM模对象 转换成 Javascript DOM节点树：\n    \n    function create(vds, parent) {\n      !Array.isArray(vds) && (vds = [vds]);\n      // 如果没有父元素则创建个fragment来当父元素\n      parent = parent || document.createDocumentFragment();\n      var node;\n      vds.forEach(function (vd) {\n        // 如果是文字节点\n        if (isText(vd)) {\n          // 创建文字节点\n          node = document.createTextNode(vd.text);\n        } else {\n          // 创建元素\n          node = document.createElement(vd.tag);\n        }\n        // 将元素塞入父容器\n        parent.appendChild(node);\n        // 看看有没有子VNode，有孩子则处理孩子VNode\n        vd.children && vd.children.length &&\n          create(vd.children, node);\n        // 看看有没有属性，有则处理属性\n        vd.properties &&\n          setProps({ style: {} }, vd.properties, node);\n      });\n      return parent;\n    }\n\n#### Diff\n\n现在我们得到的是Javascript 实现的虚拟DOM树，在一个事件循环中，当state或者preps变化时，React会创建一个新的虚拟DOM树，最后进行差异渲染。\n\ndiff(previous:VTree, current:VTree) -> PatchObject\n\nReact分三种情景：\n\n<br>\n\n**1. 分层对比**\n\n![](/content/images/2016/07/layer.png)\n\nReact 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。\n\n**2. 基于key匹配**\n\n![](/content/images/2016/07/key.png)\n\nKeys是一个VNode的唯一识别，用于对两个不同的VTree中的VNode做匹配的。通过key锁定某个组件后，React就可以直接对比这两个差异DOM节点树，复杂度为O(n)。\n\n\n所以这里有个性能优化的技巧。假设你有一个key组件，他的key属性为foo，后续又将它改为bar，那么React就会掉过DOM diff，同时完全弃置div所有自元素，从头渲染。在渲染大型子树以避免diff计算时，这样的设计很有用，因为我们知道这种计算就是在浪费时间。\n\n**3. 基于自定义元素做优化**\n\n![](/content/images/2016/07/component.png)\n\nReact提供自定义元素，所以匹配很简单。React 只会匹配相同 class 的 component。\n\n比如, 如果有个`<Header>`被`<ExampleBlock>`替换掉了,\nReact 会删除掉 header 再创建一个`example block`。我们不需要化宝贵的时间去匹配两个不大可能有相似之处的 component。\n\n## 结束\n\nReact在你调用 component 的 setState 方法的时候, 将其标记为 dirty，到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。每次调用 setState 会重新计算整个子树.如果你想要提高性能, 尽量少调用 setState。\n\n\n最后, 你还有可能去掉一些子树的重新渲染，如果你在 component 上实现function shouldComponentUpdate(nextProps, nextState) 的话，你根据 component 的前一个和下一个 props/state，告诉 React 这个 component 没有更新, 也不需要重新绘制。\n\n","mobiledoc":null,"html":"<h2 id=\"react\">React介绍</h2>\n\n<p>React是Facebook开发的一款JS库，用于构建用户界面的类库。</p>\n\n<p>它采用声明式范例，可以传递声明代码，最大限度地减少与DOM的交互。</p>\n\n<p>特点：</p>\n\n<ol>\n<li>声明式设计：React采用声明范式，你可以轻松描述你的应用  </li>\n<li>高效：React通过对DOM的模拟表现，最大限度地较少与DOM的交互。  </li>\n<li>灵活：React可以与你所知道的库或框架很好地工作。</li>\n</ol>\n\n<p>在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而<strong>复杂或频繁的DOM操作通常是性能瓶颈产生的原因</strong>。</p>\n\n<p>React为此引入了虚拟DOM（Virtual DOM）的机制：</p>\n\n<p><strong>在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的虚拟DOM树进行对比，得到虚拟DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。</strong></p>\n\n<h2 id=\"reactdiff\">React Diff 算法</h2>\n\n<p>虚拟DOM作为React的一大核心技术，了解其实现原理对于灵活应用有着很大帮助。</p>\n\n<h4 id=\"javascriptdom\">Javascript 虚拟DOM对象</h4>\n\n<p>在我们项目中申明一个组件是这样的：</p>\n\n<pre><code>react.createElement('div', null, [\n    // 创建一个img\n    react.createElement('img', { src: \"avatar.png\", class: \"profile\" }),\n    // 或者\n    react.createElement('h1', null, [[user.firstName, user.lastName].join(' ')])\n]);\n</code></pre>\n\n<p>最后，React都会转换成类似这样的基本对象：</p>\n\n<pre><code>{\n    tagName: 'div',\n    // 节点包含的属性\n    properties: {\n        style: {\n            color: '#fff'\n        }\n    },\n    // 子节点\n    children: [],\n    // 节点的唯一标识\n    key: 1\n}\n</code></pre>\n\n<h4 id=\"javascriptdom\">Javascript DOM节点树</h4>\n\n<p>然后，React把Javascript DOM模对象 转换成 Javascript DOM节点树：</p>\n\n<pre><code>function create(vds, parent) {\n  !Array.isArray(vds) &amp;&amp; (vds = [vds]);\n  // 如果没有父元素则创建个fragment来当父元素\n  parent = parent || document.createDocumentFragment();\n  var node;\n  vds.forEach(function (vd) {\n    // 如果是文字节点\n    if (isText(vd)) {\n      // 创建文字节点\n      node = document.createTextNode(vd.text);\n    } else {\n      // 创建元素\n      node = document.createElement(vd.tag);\n    }\n    // 将元素塞入父容器\n    parent.appendChild(node);\n    // 看看有没有子VNode，有孩子则处理孩子VNode\n    vd.children &amp;&amp; vd.children.length &amp;&amp;\n      create(vd.children, node);\n    // 看看有没有属性，有则处理属性\n    vd.properties &amp;&amp;\n      setProps({ style: {} }, vd.properties, node);\n  });\n  return parent;\n}\n</code></pre>\n\n<h4 id=\"diff\">Diff</h4>\n\n<p>现在我们得到的是Javascript 实现的虚拟DOM树，在一个事件循环中，当state或者preps变化时，React会创建一个新的虚拟DOM树，最后进行差异渲染。</p>\n\n<p>diff(previous:VTree, current:VTree) -> PatchObject</p>\n\n<p>React分三种情景：</p>\n\n<p><br></p>\n\n<p><strong>1. 分层对比</strong></p>\n\n<p><img src=\"/content/images/2016/07/layer.png\" alt=\"\" /></p>\n\n<p>React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。</p>\n\n<p><strong>2. 基于key匹配</strong></p>\n\n<p><img src=\"/content/images/2016/07/key.png\" alt=\"\" /></p>\n\n<p>Keys是一个VNode的唯一识别，用于对两个不同的VTree中的VNode做匹配的。通过key锁定某个组件后，React就可以直接对比这两个差异DOM节点树，复杂度为O(n)。</p>\n\n<p>所以这里有个性能优化的技巧。假设你有一个key组件，他的key属性为foo，后续又将它改为bar，那么React就会掉过DOM diff，同时完全弃置div所有自元素，从头渲染。在渲染大型子树以避免diff计算时，这样的设计很有用，因为我们知道这种计算就是在浪费时间。</p>\n\n<p><strong>3. 基于自定义元素做优化</strong></p>\n\n<p><img src=\"/content/images/2016/07/component.png\" alt=\"\" /></p>\n\n<p>React提供自定义元素，所以匹配很简单。React 只会匹配相同 class 的 component。</p>\n\n<p>比如, 如果有个<code>&lt;Header&gt;</code>被<code>&lt;ExampleBlock&gt;</code>替换掉了,\nReact 会删除掉 header 再创建一个<code>example block</code>。我们不需要化宝贵的时间去匹配两个不大可能有相似之处的 component。</p>\n\n<h2 id=\"\">结束</h2>\n\n<p>React在你调用 component 的 setState 方法的时候, 将其标记为 dirty，到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。每次调用 setState 会重新计算整个子树.如果你想要提高性能, 尽量少调用 setState。</p>\n\n<p>最后, 你还有可能去掉一些子树的重新渲染，如果你在 component 上实现function shouldComponentUpdate(nextProps, nextState) 的话，你根据 component 的前一个和下一个 props/state，告诉 React 这个 component 没有更新, 也不需要重新绘制。</p>","image":"/content/images/2016/07/download.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:20:52","created_by":1,"updated_at":"2016-07-07 13:42:26","updated_by":1,"published_at":"2015-06-21 13:20:00","published_by":1},{"id":53,"uuid":"232ca5e3-dffc-469b-8325-82a6131e3bab","title":"纯css实现Magicline Navigation(下划线动画导航菜单)","slug":"magicline-navigation","markdown":"![](/content/images/2016/07/a1.jpg)\n\n看别人网站的时候，看到一种导航菜单的动画，觉得很有意思，就仔细研究起来。\n\n目前见过的动画有三种：水平下划线动画导航、水平背景动画导航、垂直动画导航，他们实现思路都是一样的，都是依赖 css3的同级通用选择器 \"~\" 。\n\n自己实现了一遍，本文简要记录实现的思想。\n\n大家可以先看看最后实现的效果：<a href=\"http://output.jsbin.com/legipibayi\" target=\"_blank\">Demo点我</a>\n\n## 实现思路\n\n#### HTML 结构\n\nHTML结构没有特殊，就是 ul -> li:\n\n    <ul class=\"a\">\n      <li class=\"n1\"><a href=\"#\">Navigator A</a></li>\n      <li class=\"n2\"><a href=\"#\">Navigator B</a></li>\n      <li class=\"n3 selected\"><a href=\"#\">Navigator C</a></li>\n      <li class=\"n4\"><a href=\"#\">Navigator D</a></li>\n      <li class=\"quebec\">&nbsp;</li>\n    </ul>\n\n最后一个li空着，留着后面有用。\n\n\n#### CSS 布局\n\n实现基本样式，不多解释：\n        \n            \n      ul {\n        position: relative;\n        overflow: hidden;\n        padding-left: 0px;\n      }\n      li {\n            list-style: none outside;\n            position: relative;\n            z-index: 1;\n            float: left;\n            padding: 0 0 0 0;\n            margin-right: 10px;\n        }\n        li a {\n            position: relative;\n            width: 100px;\n            color:#333 ;\n            display: block;\n            margin: 0 0;\n            border-bottom: 5px solid transparent;\n            padding: 10px 0;\n            text-align: center;\n            text-decoration: none;\n        }\n        .selected a {\n            border-bottom: 5px solid #cfd0d0;\n            color: #511d7f;\n        }\n\n#### 实现导航下划线\n\n下面实现动画部分。\n\n下方紫色滚动条是通过，刚才留着的最后一个li元素实现。\n\n     .quebec {\n          position: absolute;\n          bottom: 0px;\n          left: -100px;\n          z-index: 3;\n          margin: 0;\n          border: 0;\n          width: 5px;\n          height: 5px;\n          padding: 0;\n          overflow: hidden;\n          background: #511d7f;\n\n         -webkit-transition-property: left, width;\n         -moz-transition-property: left, width;\n         -ms-transition-property: left, width;\n         -o-transition-property: left, width;\n         transition-property: left, width;\n\n         -webkit-transition-duration: .5s;\n         -moz-transition-duration: .5s;\n         -ms-transition-duration: .5s;\n         -o-transition-duration: .5s;\n         transition-duration: .5s;\n      }\n\n通过绝对定位，把最后一个 li.quebec 定位到导航下方，设置宽度高度。设置 transition，当我们改变 left, width的时候就能实现动画。\n\n#### 动起来\n\n当hover到导航上面的时候，li.quebec 就定位left到其下面。实现这个效果的是css3的同级通用选择器 “～”\n\n比如 A ~ B 匹配的是 **任何在A元素之后的同级B元素**。\n\n          \n      .n1:hover ~ li.quebec { left: 5px; width: 110px; }\n      .n2:hover ~ li.quebec { left: 115px; width: 110px; }\n      .n3:hover ~ li.quebec { left: 225px; width: 110px; }\n      .n4:hover ~ li.quebec { left: 335px; width: 110px; }\n\n这里就完成了一个 纯css的下划线动画导航。 \n\n## 扩展\n\n当我们会实现水平的下划线动画导航后，实现 背景移动动画导航 思路也是一样，不过是li.quebec高度宽度的变化，背景透明度的变化。\n\n\n垂直的动画导航 亦是如此，改变 li.quebec 的高度宽度，通过 translateY 控制其在垂直方向的位置。\n\n\n为了效果更炫一点，我们还可以在hover不同li的时候，改变li.quebec的颜色、背景、透明度等。\n\n\n","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/07/a1.jpg\" alt=\"\" /></p>\n\n<p>看别人网站的时候，看到一种导航菜单的动画，觉得很有意思，就仔细研究起来。</p>\n\n<p>目前见过的动画有三种：水平下划线动画导航、水平背景动画导航、垂直动画导航，他们实现思路都是一样的，都是依赖 css3的同级通用选择器 \"~\" 。</p>\n\n<p>自己实现了一遍，本文简要记录实现的思想。</p>\n\n<p>大家可以先看看最后实现的效果：<a href=\"http://output.jsbin.com/legipibayi\" target=\"_blank\">Demo点我</a></p>\n\n<h2 id=\"\">实现思路</h2>\n\n<h4 id=\"html\">HTML 结构</h4>\n\n<p>HTML结构没有特殊，就是 ul -> li:</p>\n\n<pre><code>&lt;ul class=\"a\"&gt;\n  &lt;li class=\"n1\"&gt;&lt;a href=\"#\"&gt;Navigator A&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n2\"&gt;&lt;a href=\"#\"&gt;Navigator B&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n3 selected\"&gt;&lt;a href=\"#\"&gt;Navigator C&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n4\"&gt;&lt;a href=\"#\"&gt;Navigator D&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"quebec\"&gt;&amp;nbsp;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>最后一个li空着，留着后面有用。</p>\n\n<h4 id=\"css\">CSS 布局</h4>\n\n<p>实现基本样式，不多解释：</p>\n\n<pre><code>  ul {\n    position: relative;\n    overflow: hidden;\n    padding-left: 0px;\n  }\n  li {\n        list-style: none outside;\n        position: relative;\n        z-index: 1;\n        float: left;\n        padding: 0 0 0 0;\n        margin-right: 10px;\n    }\n    li a {\n        position: relative;\n        width: 100px;\n        color:#333 ;\n        display: block;\n        margin: 0 0;\n        border-bottom: 5px solid transparent;\n        padding: 10px 0;\n        text-align: center;\n        text-decoration: none;\n    }\n    .selected a {\n        border-bottom: 5px solid #cfd0d0;\n        color: #511d7f;\n    }\n</code></pre>\n\n<h4 id=\"\">实现导航下划线</h4>\n\n<p>下面实现动画部分。</p>\n\n<p>下方紫色滚动条是通过，刚才留着的最后一个li元素实现。</p>\n\n<pre><code> .quebec {\n      position: absolute;\n      bottom: 0px;\n      left: -100px;\n      z-index: 3;\n      margin: 0;\n      border: 0;\n      width: 5px;\n      height: 5px;\n      padding: 0;\n      overflow: hidden;\n      background: #511d7f;\n\n     -webkit-transition-property: left, width;\n     -moz-transition-property: left, width;\n     -ms-transition-property: left, width;\n     -o-transition-property: left, width;\n     transition-property: left, width;\n\n     -webkit-transition-duration: .5s;\n     -moz-transition-duration: .5s;\n     -ms-transition-duration: .5s;\n     -o-transition-duration: .5s;\n     transition-duration: .5s;\n  }\n</code></pre>\n\n<p>通过绝对定位，把最后一个 li.quebec 定位到导航下方，设置宽度高度。设置 transition，当我们改变 left, width的时候就能实现动画。</p>\n\n<h4 id=\"\">动起来</h4>\n\n<p>当hover到导航上面的时候，li.quebec 就定位left到其下面。实现这个效果的是css3的同级通用选择器 “～”</p>\n\n<p>比如 A ~ B 匹配的是 <strong>任何在A元素之后的同级B元素</strong>。</p>\n\n<pre><code>  .n1:hover ~ li.quebec { left: 5px; width: 110px; }\n  .n2:hover ~ li.quebec { left: 115px; width: 110px; }\n  .n3:hover ~ li.quebec { left: 225px; width: 110px; }\n  .n4:hover ~ li.quebec { left: 335px; width: 110px; }\n</code></pre>\n\n<p>这里就完成了一个 纯css的下划线动画导航。 </p>\n\n<h2 id=\"\">扩展</h2>\n\n<p>当我们会实现水平的下划线动画导航后，实现 背景移动动画导航 思路也是一样，不过是li.quebec高度宽度的变化，背景透明度的变化。</p>\n\n<p>垂直的动画导航 亦是如此，改变 li.quebec 的高度宽度，通过 translateY 控制其在垂直方向的位置。</p>\n\n<p>为了效果更炫一点，我们还可以在hover不同li的时候，改变li.quebec的颜色、背景、透明度等。</p>","image":"/content/images/2016/07/a1-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:44:39","created_by":1,"updated_at":"2016-07-07 13:47:18","updated_by":1,"published_at":"2015-04-29 13:44:00","published_by":1},{"id":54,"uuid":"50a044b7-de16-4bcb-ac5e-0bd1841bebae","title":"Tinymce  Group Plugin","slug":"tinymce-group-plugin","markdown":"\n本文介绍一个tinymce插件，用来组合显示下拉的按钮。\n\n>本文tinymce基于4.x，不兼容3.x。\n\n## 以前\n\n### 配置toolbar功能按钮\n\n需要\n\n    toolbar1: \"code undo redo fullscreen\"\n    plugins: \"code, fullscreen\"\n\n页面就能显示\n\n![](/content/images/2016/07/a-1.png)\n\n### 配置 toolbar下拉的功能按钮集合，需要新写一个插件\n\n插件核心源码：\n\n    editor.addButton('undoRedo', {\n        type: 'menubutton',\n        icon: 'mceIcon mce-i-undo',\n\t     menu: [\n            {\n                text: ed.getLang('Undo'),\n                icon: 'mceIcon mce-i-bold',\n                onclick: function() {\n                    ed.execCommand('Undo');\n                }\n            },\n            {\n                text: ed.getLang('Redo'),\n                icon: 'mceIcon mce-i-redo',\n                onclick: function() {\n                    ed.execCommand('Redo');\n                }\n            }\n        ]\n    });\n\n就能看到\n\n![](/content/images/2016/07/e.png)\n\n## 现在\n\n现在我们想要实现这类下拉功能菜单：\n\n![](/content/images/2016/07/c-3.png)\n\n当然作为备选方案，可以使用使用上面提到的add menuButton的方式。不过这样的缺点是，我们如果需要5个下拉功能菜单，就不得不写五个插件，而都是重复的工作。\n\n当一件事开始重复的时候，就一定有方法可以让其变的简单。\n\n我们的解决办法是，通过一个插件，来配置多个下拉功能菜单。\n\ntalk is chip, show you the code:\n\n####使用配置：\n    \n    toolbar1: 'undo redo | group group group group group | fullscreen',\n    group_set: [{\n        icon: 'alignleft',\n        buttons: 'alignleft,aligncenter,alignright',\n        title: 'Align center'\n    }, {\n        icon: 'bullist',\n        buttons: 'bullist,numlist',\n        title: 'advanced.bullist_desc'\n    }, {\n        icon: 'indent',\n        buttons: 'indent,outdent',\n        title: 'advanced.indent_desc'\n    }, {\n        icon: 'subscript',\n        buttons: 'superscript,subscript',\n        title: 'advanced.sup_desc'\n    },{\n        icon: 'image',\n        buttons: 'alitophotobank,image, aliphotobank',\n        title: 'advanced.sup_desc'\n    }]\n\n效果:\n\n![](/content/images/2016/07/c-4.png)\n\n### plugin group实现\n\n#### 修改 toolbar 配置\ntoolbar1配置了5个group占位符，但是addButton的第一个参数name一定要和toolbar上的占位配置一致，所以第一步是修改  settings.toolbar上的group占位符。\n   \n    // 修改 setting中toolbar上的group，group为group1，group2\n    modifySettingToolbar: function(ed) {\n        var index = 1;\n        var settings = ed.settings;\n        if(!settings.toolbar1 && !settings.toolbar2 && !settings.toolbar3) return false;\n\n        var toolbar1 = settings.toolbar1.split(' '),\n            toolbar2 = settings.toolbar2.split(' '),\n            toolbar3 = settings.toolbar3.split(' ');\n\n        [toolbar1, toolbar2, toolbar3].forEach(function(item) {\n            for (var i = 0; i < item.length; i++) {\n                if(item[i] == 'group') {\n                    item[i] = 'group' + index;\n                    index ++;\n                }\n            };\n        });\n        this.toolbarNum = index;\n        settings.toolbar1 = toolbar1.join(' ');\n        settings.toolbar2 = toolbar2.join(' ');\n        settings.toolbar3 = toolbar3.join(' ');\n    },\n\n#### 插件核心代码\n\n    //编辑器初始化后将初始化一个插件实例\n    init: function(ed, url) {\n        //在这个实例中我们保存一些编辑器的公用信息\n        this.ed = ed;\n        //保留配置信息\n        this.settings = ed.settings;\n        // 注意 4.x 没有3.x的 ed.onInit 方法\n        ed.on('init', function() {\n            this.createControl(ed);\n        }.bind(this));\n    },\n    // 创建 group button\n    createControl: function(ed) {\n        var _set = this.settings;\n\n        this.modifySettingToolbar(ed);\n        for (var i = 1; i < this.toolbarNum; i++) {\n\n            var _item = _set.group_set[i-1]; //获取多组信息\n            if(!_item) return false;\n            var _buttons = _item ? _item.buttons.split(',') : [],\n                subItem = [];\n\n            for (var j = 0, l = _buttons.length; j < l; j++) {\n\n                btn  = _buttons[j] && _buttons[j].trim();\n\n                subItem.push({\n                    //配置标题信息则需要考虑到语言和主题\n                    text: ed.getLang(BUTTONS_MAP[btn] && BUTTONS_MAP[btn][0]),\n                    //图标类自己创建的话则需要注意格式\n                    icon: 'mceIcon mce-i-' + btn,\n                    //执行的命令 闭包传入当前btn\n                    onclick: (function(btn) {\n                       var cmd = BUTTONS_MAP[btn] && BUTTONS_MAP[btn][1];\n                       return function(e) {\n                          ed.execCommand(cmd);\n                       }\n                   })(btn)\n                });\n            }\n            ed.addButton('group' + i, {\n                type: 'menubutton',\n                icon: _item.icon || '',\n                menu: subItem\n            });\n        }\n        return false;\n    },\n\n\n注释已经很详细了，就不讲解代码了。\n\n其中的BUTTONS_MAP是我配置的一个title&cmd的map：\n\n    // 目前 plugin group支持的一些功能map\n    var BUTTONS_MAP = {\n      bold : ['Bold', 'Bold'],\n      italic : ['Italic', 'Italic'],\n      underline : ['Underline', 'Underline'],\n      strikethrough : ['Strikethrough', 'Strikethrough'],\n      alignleft : ['Align left', 'JustifyLeft'],\n      aligncenter : ['Align center', 'JustifyCenter'],\n      alignright : ['Align right', 'JustifyRight'],\n      alignjustify : ['Alignment', 'JustifyFull'],\n      bullist : ['Bullet list', 'InsertUnorderedList'],\n      numlist : ['Numbered list', 'InsertOrderedList'],\n      outdent : ['Decrease indent', 'Outdent'],\n      indent : ['Increase indent', 'Indent'],\n      cut : ['Cut', 'Cut'],\n      copy : ['Copy', 'Copy'],\n      paste : ['Paste', 'Paste'],\n      undo : ['Undo', 'Undo'],\n      redo : ['Redo', 'Redo'],\n      link : ['Insert link', 'mceLink'],\n      unlink : ['Remove link', 'unlink'],\n      image : ['Insert image', 'mceImage'],\n      removeformat : ['Clear formatting', 'mceCleanup'],\n      help : ['help', 'mceHelp'],\n      code : ['Source code', 'mceCodeEditor'],\n      hr : ['Horizontal line', 'InsertHorizontalRule'],\n      superscript : ['Subscript', 'subscript'],\n      subscript : ['Superscript', 'superscript'],\n      newdocument : ['New document', 'mceNewDocument'],\n      blockquote : ['Blockquote', 'mceBlockQuote']\n     };\n\n\n以上就是group的使用方式和源码解释，希望能帮到你。\n\n源码托管在github:  <a href=\"https://github.com/freestyle21/tinymce_plugin_group\" target=\"_blank\"><code>点我下载</code></a>\n","mobiledoc":null,"html":"<p>本文介绍一个tinymce插件，用来组合显示下拉的按钮。</p>\n\n<blockquote>\n  <p>本文tinymce基于4.x，不兼容3.x。</p>\n</blockquote>\n\n<h2 id=\"\">以前</h2>\n\n<h3 id=\"toolbar\">配置toolbar功能按钮</h3>\n\n<p>需要</p>\n\n<pre><code>toolbar1: \"code undo redo fullscreen\"\nplugins: \"code, fullscreen\"\n</code></pre>\n\n<p>页面就能显示</p>\n\n<p><img src=\"/content/images/2016/07/a-1.png\" alt=\"\" /></p>\n\n<h3 id=\"toolbar\">配置 toolbar下拉的功能按钮集合，需要新写一个插件</h3>\n\n<p>插件核心源码：</p>\n\n<pre><code>editor.addButton('undoRedo', {\n    type: 'menubutton',\n    icon: 'mceIcon mce-i-undo',\n     menu: [\n        {\n            text: ed.getLang('Undo'),\n            icon: 'mceIcon mce-i-bold',\n            onclick: function() {\n                ed.execCommand('Undo');\n            }\n        },\n        {\n            text: ed.getLang('Redo'),\n            icon: 'mceIcon mce-i-redo',\n            onclick: function() {\n                ed.execCommand('Redo');\n            }\n        }\n    ]\n});\n</code></pre>\n\n<p>就能看到</p>\n\n<p><img src=\"/content/images/2016/07/e.png\" alt=\"\" /></p>\n\n<h2 id=\"\">现在</h2>\n\n<p>现在我们想要实现这类下拉功能菜单：</p>\n\n<p><img src=\"/content/images/2016/07/c-3.png\" alt=\"\" /></p>\n\n<p>当然作为备选方案，可以使用使用上面提到的add menuButton的方式。不过这样的缺点是，我们如果需要5个下拉功能菜单，就不得不写五个插件，而都是重复的工作。</p>\n\n<p>当一件事开始重复的时候，就一定有方法可以让其变的简单。</p>\n\n<p>我们的解决办法是，通过一个插件，来配置多个下拉功能菜单。</p>\n\n<p>talk is chip, show you the code:</p>\n\n<h4 id=\"\">使用配置：</h4>\n\n<pre><code>toolbar1: 'undo redo | group group group group group | fullscreen',\ngroup_set: [{\n    icon: 'alignleft',\n    buttons: 'alignleft,aligncenter,alignright',\n    title: 'Align center'\n}, {\n    icon: 'bullist',\n    buttons: 'bullist,numlist',\n    title: 'advanced.bullist_desc'\n}, {\n    icon: 'indent',\n    buttons: 'indent,outdent',\n    title: 'advanced.indent_desc'\n}, {\n    icon: 'subscript',\n    buttons: 'superscript,subscript',\n    title: 'advanced.sup_desc'\n},{\n    icon: 'image',\n    buttons: 'alitophotobank,image, aliphotobank',\n    title: 'advanced.sup_desc'\n}]\n</code></pre>\n\n<p>效果:</p>\n\n<p><img src=\"/content/images/2016/07/c-4.png\" alt=\"\" /></p>\n\n<h3 id=\"plugingroup\">plugin group实现</h3>\n\n<h4 id=\"toolbar\">修改 toolbar 配置</h4>\n\n<p>toolbar1配置了5个group占位符，但是addButton的第一个参数name一定要和toolbar上的占位配置一致，所以第一步是修改  settings.toolbar上的group占位符。</p>\n\n<pre><code>// 修改 setting中toolbar上的group，group为group1，group2\nmodifySettingToolbar: function(ed) {\n    var index = 1;\n    var settings = ed.settings;\n    if(!settings.toolbar1 &amp;&amp; !settings.toolbar2 &amp;&amp; !settings.toolbar3) return false;\n\n    var toolbar1 = settings.toolbar1.split(' '),\n        toolbar2 = settings.toolbar2.split(' '),\n        toolbar3 = settings.toolbar3.split(' ');\n\n    [toolbar1, toolbar2, toolbar3].forEach(function(item) {\n        for (var i = 0; i &lt; item.length; i++) {\n            if(item[i] == 'group') {\n                item[i] = 'group' + index;\n                index ++;\n            }\n        };\n    });\n    this.toolbarNum = index;\n    settings.toolbar1 = toolbar1.join(' ');\n    settings.toolbar2 = toolbar2.join(' ');\n    settings.toolbar3 = toolbar3.join(' ');\n},\n</code></pre>\n\n<h4 id=\"\">插件核心代码</h4>\n\n<pre><code>//编辑器初始化后将初始化一个插件实例\ninit: function(ed, url) {\n    //在这个实例中我们保存一些编辑器的公用信息\n    this.ed = ed;\n    //保留配置信息\n    this.settings = ed.settings;\n    // 注意 4.x 没有3.x的 ed.onInit 方法\n    ed.on('init', function() {\n        this.createControl(ed);\n    }.bind(this));\n},\n// 创建 group button\ncreateControl: function(ed) {\n    var _set = this.settings;\n\n    this.modifySettingToolbar(ed);\n    for (var i = 1; i &lt; this.toolbarNum; i++) {\n\n        var _item = _set.group_set[i-1]; //获取多组信息\n        if(!_item) return false;\n        var _buttons = _item ? _item.buttons.split(',') : [],\n            subItem = [];\n\n        for (var j = 0, l = _buttons.length; j &lt; l; j++) {\n\n            btn  = _buttons[j] &amp;&amp; _buttons[j].trim();\n\n            subItem.push({\n                //配置标题信息则需要考虑到语言和主题\n                text: ed.getLang(BUTTONS_MAP[btn] &amp;&amp; BUTTONS_MAP[btn][0]),\n                //图标类自己创建的话则需要注意格式\n                icon: 'mceIcon mce-i-' + btn,\n                //执行的命令 闭包传入当前btn\n                onclick: (function(btn) {\n                   var cmd = BUTTONS_MAP[btn] &amp;&amp; BUTTONS_MAP[btn][1];\n                   return function(e) {\n                      ed.execCommand(cmd);\n                   }\n               })(btn)\n            });\n        }\n        ed.addButton('group' + i, {\n            type: 'menubutton',\n            icon: _item.icon || '',\n            menu: subItem\n        });\n    }\n    return false;\n},\n</code></pre>\n\n<p>注释已经很详细了，就不讲解代码了。</p>\n\n<p>其中的BUTTONS_MAP是我配置的一个title&amp;cmd的map：</p>\n\n<pre><code>// 目前 plugin group支持的一些功能map\nvar BUTTONS_MAP = {\n  bold : ['Bold', 'Bold'],\n  italic : ['Italic', 'Italic'],\n  underline : ['Underline', 'Underline'],\n  strikethrough : ['Strikethrough', 'Strikethrough'],\n  alignleft : ['Align left', 'JustifyLeft'],\n  aligncenter : ['Align center', 'JustifyCenter'],\n  alignright : ['Align right', 'JustifyRight'],\n  alignjustify : ['Alignment', 'JustifyFull'],\n  bullist : ['Bullet list', 'InsertUnorderedList'],\n  numlist : ['Numbered list', 'InsertOrderedList'],\n  outdent : ['Decrease indent', 'Outdent'],\n  indent : ['Increase indent', 'Indent'],\n  cut : ['Cut', 'Cut'],\n  copy : ['Copy', 'Copy'],\n  paste : ['Paste', 'Paste'],\n  undo : ['Undo', 'Undo'],\n  redo : ['Redo', 'Redo'],\n  link : ['Insert link', 'mceLink'],\n  unlink : ['Remove link', 'unlink'],\n  image : ['Insert image', 'mceImage'],\n  removeformat : ['Clear formatting', 'mceCleanup'],\n  help : ['help', 'mceHelp'],\n  code : ['Source code', 'mceCodeEditor'],\n  hr : ['Horizontal line', 'InsertHorizontalRule'],\n  superscript : ['Subscript', 'subscript'],\n  subscript : ['Superscript', 'superscript'],\n  newdocument : ['New document', 'mceNewDocument'],\n  blockquote : ['Blockquote', 'mceBlockQuote']\n };\n</code></pre>\n\n<p>以上就是group的使用方式和源码解释，希望能帮到你。</p>\n\n<p>源码托管在github:  <a href=\"https://github.com/freestyle21/tinymce_plugin_group\" target=\"_blank\"><code>点我下载</code></a></p>","image":"/content/images/2016/07/c-5.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:47:58","created_by":1,"updated_at":"2016-07-07 13:50:50","updated_by":1,"published_at":"2015-04-18 13:47:00","published_by":1},{"id":55,"uuid":"d57c8753-4baa-4f3e-8509-738ed8cc93bd","title":"自适应process组件","slug":"process-component","markdown":"很久没有写博客了，自从工作忙了就忘了学习新东西，真是越大越懒。\n\n做项目中，需要一个process流程的UI组件，翻遍公司组件和业界框架，都没有满足自适应要求的现成的process组件，只能自己实现。实现的过程中，发现有两个有意思的地方，特此分享出来。\n\n首先看看最后需要的效果：<a href=\"http://qubaoming.me/demo/process/process.html\">点我查看demo</a>。\n\n## 实现\n\n流程组件中，两个hr构成圆点之间的连接线。\n\n圆点用span 通过 border-raduis: 50%实现。\n\n接下来，第一个难点来了，如何实现 居中 并且 自适应。\n\n自适应的意思是，拉伸浏览器的时候，流程组件也跟着变化长度，并且不变型。那么，我们自然的想到了用百分数设置宽度。\n\n第一张方案：\n\n![](/content/images/2016/07/aaa.png)\n\n用 outer 居中， inner平分内部，即每个inner占用 1/7 = 14.2%。内部原点span和文字通过每个inner的text-align:center;居中。\n\n接下来就连接线hr的宽度的计算就成了问题。比如连接线hr的起始位置怎么计算？inner的1/2，也就是1/14=0.071？\n\n第一次inner的1/7就有省略小数点的误差，再一半肯定更有误差，hr的宽度会再乘以2，乘以3，误差会更大，很有可能出现下面的情况:\n\n![](/content/images/2016/07/bbb.png)\n\n第二种方案：\n\n要解决节点span长度计算的问题，就必须让其乘以的倍数是精确可计算的。于是：\n\n![](/content/images/2016/07/tttt.png)\n\n通过外层outer实现居中，inner＋左侧等宽的空白 平分内部宽度，即 1/8=12.5%。\n\n这里又来了另一个问题：如何使下方文字左移自身宽度一半？\n\n父元素设置 text-align: center; ？？ 不行，我们的圆点span只能从最左边开始。\n\n自身position: absolute; left: 50%; margin-left: -宽度？不行，自身宽度不知道，变化的。\n\nposition: relative; left: -50%？不行，left 百分比是以最近已定位父元素的宽度为参照。\n\n\n最后解决办法是，增加一层父元素，使父元素宽度为自身宽度。这样left百分比就可以相当于以自身宽度。\n\n\n最后的效果：\n\n![](/content/images/2016/07/ccc.png)\n\n\n02.06更新\n-----\n\n由于是跨部门合作，对方返回的流程状态总是在变，从7个变到5个，从5个变到6个。\n\n\n7个状态有8个span，这样 1/8 = 12.5\n\n5个是加3个变8，也是12.5。通过margin-left微调。\n\n6个同理，加2变8，通过margin-left微调。\n\n07.24 更新\n----\n\n升级组件，可以适应后端的数据5-7个。\n\ngithub地址: https://github.com/freestyle21/step","mobiledoc":null,"html":"<p>很久没有写博客了，自从工作忙了就忘了学习新东西，真是越大越懒。</p>\n\n<p>做项目中，需要一个process流程的UI组件，翻遍公司组件和业界框架，都没有满足自适应要求的现成的process组件，只能自己实现。实现的过程中，发现有两个有意思的地方，特此分享出来。</p>\n\n<p>首先看看最后需要的效果：<a href=\"http://qubaoming.me/demo/process/process.html\">点我查看demo</a>。</p>\n\n<h2 id=\"\">实现</h2>\n\n<p>流程组件中，两个hr构成圆点之间的连接线。</p>\n\n<p>圆点用span 通过 border-raduis: 50%实现。</p>\n\n<p>接下来，第一个难点来了，如何实现 居中 并且 自适应。</p>\n\n<p>自适应的意思是，拉伸浏览器的时候，流程组件也跟着变化长度，并且不变型。那么，我们自然的想到了用百分数设置宽度。</p>\n\n<p>第一张方案：</p>\n\n<p><img src=\"/content/images/2016/07/aaa.png\" alt=\"\" /></p>\n\n<p>用 outer 居中， inner平分内部，即每个inner占用 1/7 = 14.2%。内部原点span和文字通过每个inner的text-align:center;居中。</p>\n\n<p>接下来就连接线hr的宽度的计算就成了问题。比如连接线hr的起始位置怎么计算？inner的1/2，也就是1/14=0.071？</p>\n\n<p>第一次inner的1/7就有省略小数点的误差，再一半肯定更有误差，hr的宽度会再乘以2，乘以3，误差会更大，很有可能出现下面的情况:</p>\n\n<p><img src=\"/content/images/2016/07/bbb.png\" alt=\"\" /></p>\n\n<p>第二种方案：</p>\n\n<p>要解决节点span长度计算的问题，就必须让其乘以的倍数是精确可计算的。于是：</p>\n\n<p><img src=\"/content/images/2016/07/tttt.png\" alt=\"\" /></p>\n\n<p>通过外层outer实现居中，inner＋左侧等宽的空白 平分内部宽度，即 1/8=12.5%。</p>\n\n<p>这里又来了另一个问题：如何使下方文字左移自身宽度一半？</p>\n\n<p>父元素设置 text-align: center; ？？ 不行，我们的圆点span只能从最左边开始。</p>\n\n<p>自身position: absolute; left: 50%; margin-left: -宽度？不行，自身宽度不知道，变化的。</p>\n\n<p>position: relative; left: -50%？不行，left 百分比是以最近已定位父元素的宽度为参照。</p>\n\n<p>最后解决办法是，增加一层父元素，使父元素宽度为自身宽度。这样left百分比就可以相当于以自身宽度。</p>\n\n<p>最后的效果：</p>\n\n<p><img src=\"/content/images/2016/07/ccc.png\" alt=\"\" /></p>\n\n<h2 id=\"0206\">02.06更新  </h2>\n\n<p>由于是跨部门合作，对方返回的流程状态总是在变，从7个变到5个，从5个变到6个。</p>\n\n<p>7个状态有8个span，这样 1/8 = 12.5</p>\n\n<p>5个是加3个变8，也是12.5。通过margin-left微调。</p>\n\n<p>6个同理，加2变8，通过margin-left微调。</p>\n\n<h2 id=\"0724\">07.24 更新  </h2>\n\n<p>升级组件，可以适应后端的数据5-7个。</p>\n\n<p>github地址: <a href=\"https://github.com/freestyle21/step\">https://github.com/freestyle21/step</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:51:08","created_by":1,"updated_at":"2016-07-08 00:07:46","updated_by":1,"published_at":"2015-01-15 13:51:00","published_by":1},{"id":56,"uuid":"83cb1eac-adf0-4604-b2d7-6141a66cc88d","title":"寻找节点d＝n的节点算法","slug":"path-shortest-algorithm","markdown":">这里的算法是毕设过程中，自己想到的，也不知道有不有人提出过。这里就记录下发现的过程的具体的算法，以后会用到。\n\n## 背景描述\n毕设做的是「社交网络中病毒传播的预测」，前期过程主要是模拟几个网络的数据，然后从一个节点开始传播，研究传播过程的预测性。\n\n其中一步，需要研究距离桥节点（两个网络的俩连接点）距离为n的节点为病毒源的传播过程。这里产生一个需求：**寻找与节点A距离为n的节点们。**\n\n毕设过程基本是重复博士生姐姐已发表的论文，不过由于年轻气盛给导师说要自己做，只是博士生姐姐提供主线思路。每次都是自己做出来后，给博士生姐姐讲，然后给我讲他的。发现，寻找离节点A距离n的节点们，博士生姐姐都是用`Dijkstra`算法先把整个网络的节点距离算出来，再找需要的节点。\n\n但是，这样做的缺点是浪费不必要的时间和空间，因为我们的需求中只需要计算距离特定点A长度d＝n的节点们，而不需要计算所有节点的所有距离长度节点。\n\n## 算法内容\n算法思路是根据最直接的想法进行的，即\n寻找与节点A距离d＝n的节点算法：\n\n1.   寻找与节点A距离d＝n－1的的邻居节点\n2.   第一步的节点中减去d＝n－2，n－3，。。。，1，0的邻居节点\n\njs写的伪代码(直接用的毕设时的数据结构)\n\n\n       /*\n            寻找网络Net中距离节点node距离distance的节点们\n            Net = {\n                '1': {\n                    'status': 1, // 节点编号1的节点状态是已感染。\n                    'connect': [2,3,4,5] // 节点编号1的节点的邻居节点。\n                },\n                ...\n            }\n        */\n        function findDistanceNodes(Net, node, distance) {\n            var findNodes = [];\n            if(distance == 0) {\n                findNodes.push(node);\n            } else {\n                // 寻找距离  distance - 1 的节点们的邻居们\n                var lastDistanceNodes = findDistanceNodes(Net, node, distance - 1);\n                for(var i =0; i < lastDistanceNodes.length; i++) {\n                    findNodes = array_merge(Net[lastDistanceNodes[i]].connect, findNodes);\n                }\n                // 去重\n                findNodes = rmSameArr(findNodes);\n\n                // 从刚才的邻居们中排除 距离node d＝0,1,2,3,4,...distance-1的节点\n                for(var i = 0; i < distance; i++) {\n                    findNodes = minArrFromArr(findNodes, findDistanceNodes(Net, node, i));\n                }\n            }\n            return findNodes;\n        }\n\n\n## 结尾\n以上算法经过毕设结果验证，和博士生姐姐的结果一致，整体运行速度也比其快。\n这里粗略记录下研究过程，希望也能感受到毕设中的苦与甜。","mobiledoc":null,"html":"<blockquote>\n  <p>这里的算法是毕设过程中，自己想到的，也不知道有不有人提出过。这里就记录下发现的过程的具体的算法，以后会用到。</p>\n</blockquote>\n\n<h2 id=\"\">背景描述</h2>\n\n<p>毕设做的是「社交网络中病毒传播的预测」，前期过程主要是模拟几个网络的数据，然后从一个节点开始传播，研究传播过程的预测性。</p>\n\n<p>其中一步，需要研究距离桥节点（两个网络的俩连接点）距离为n的节点为病毒源的传播过程。这里产生一个需求：<strong>寻找与节点A距离为n的节点们。</strong></p>\n\n<p>毕设过程基本是重复博士生姐姐已发表的论文，不过由于年轻气盛给导师说要自己做，只是博士生姐姐提供主线思路。每次都是自己做出来后，给博士生姐姐讲，然后给我讲他的。发现，寻找离节点A距离n的节点们，博士生姐姐都是用<code>Dijkstra</code>算法先把整个网络的节点距离算出来，再找需要的节点。</p>\n\n<p>但是，这样做的缺点是浪费不必要的时间和空间，因为我们的需求中只需要计算距离特定点A长度d＝n的节点们，而不需要计算所有节点的所有距离长度节点。</p>\n\n<h2 id=\"\">算法内容</h2>\n\n<p>算法思路是根据最直接的想法进行的，即\n寻找与节点A距离d＝n的节点算法：</p>\n\n<ol>\n<li>寻找与节点A距离d＝n－1的的邻居节点  </li>\n<li>第一步的节点中减去d＝n－2，n－3，。。。，1，0的邻居节点</li>\n</ol>\n\n<p>js写的伪代码(直接用的毕设时的数据结构)</p>\n\n<pre><code>   /*\n        寻找网络Net中距离节点node距离distance的节点们\n        Net = {\n            '1': {\n                'status': 1, // 节点编号1的节点状态是已感染。\n                'connect': [2,3,4,5] // 节点编号1的节点的邻居节点。\n            },\n            ...\n        }\n    */\n    function findDistanceNodes(Net, node, distance) {\n        var findNodes = [];\n        if(distance == 0) {\n            findNodes.push(node);\n        } else {\n            // 寻找距离  distance - 1 的节点们的邻居们\n            var lastDistanceNodes = findDistanceNodes(Net, node, distance - 1);\n            for(var i =0; i &lt; lastDistanceNodes.length; i++) {\n                findNodes = array_merge(Net[lastDistanceNodes[i]].connect, findNodes);\n            }\n            // 去重\n            findNodes = rmSameArr(findNodes);\n\n            // 从刚才的邻居们中排除 距离node d＝0,1,2,3,4,...distance-1的节点\n            for(var i = 0; i &lt; distance; i++) {\n                findNodes = minArrFromArr(findNodes, findDistanceNodes(Net, node, i));\n            }\n        }\n        return findNodes;\n    }\n</code></pre>\n\n<h2 id=\"\">结尾</h2>\n\n<p>以上算法经过毕设结果验证，和博士生姐姐的结果一致，整体运行速度也比其快。\n这里粗略记录下研究过程，希望也能感受到毕设中的苦与甜。</p>","image":"/content/images/2016/07/c9e42240.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:09:05","created_by":1,"updated_at":"2016-07-08 00:11:29","updated_by":1,"published_at":"2014-06-15 00:09:00","published_by":1},{"id":57,"uuid":"6c289b1d-ab76-4383-81bd-ebec3b5203d7","title":"mac os x 从入门到顺手","slug":"mac-os-learn","markdown":"## 惯例\n文章开头，惯例前戏。\nmac入手一周，越用越顺手，记录下使用习惯。\n\n文章会持续更新，朋友如果有更舒服得方式可以留言交流。\n\n## 常用基本手势\n\n左右切换屏幕： 四指左右滑动（习惯除去大拇指）\n\n上下滚动浏览： 两手指上下\n\n鼠标左键和右键： 一个手指单击和两个手指单击（默认是按下，修改了）\n\n查看当前打开程序： 四指向上或向下（查看当当前焦点程序得其他窗口）\n\n移动当前焦点窗口： 三指在title部分。\n\n## iTerm\n默认终端还不错，不过用过iTerm才知道什么叫好。\niTerm界面：\n\n![](/content/images/2016/07/QQ20140418-1-2x.png)\n\n下载：[http://iterm.sourceforge.net/downloads.shtml](http://iterm.sourceforge.net/downloads.shtml)\n\n快捷键：\n\ncommand+d：垂直分割；\n\ncommand+shift+d：水平分割\n\ncommand+f 查找。之后按tab会继续选中并复制右边一个单词，shift+tab继续选中并复制左边一个单词。\n\ncommand+shift+h 自动列出剪切板的历史记录\n\ncommand+enter进入与返回全屏模式\n\n## VIM \n一直见身边得人用这个神器，定位太叼了，可惜每次决心要用的时候，发现很痛苦后又换回sublime了。\n这次重新学习。\n\n#### 常用配置\n创建一个文件 \n\n      sudo touch ~/.vimrc\n\n这是一个配置文件，内容在：[这里](https://github.com/freestyle21/tools/blob/master/.vimrc)\n\n创建文件夹 \n\n      sudo mkdir ~/vim/plugin\n      sudo mkdir ~/vim/colors\n\n下载得插件都放在plugin，主题放colors，在.vimrc里面配置主题即可。\n\n#### 常用命令：\ngt     切换到下一个标签页  \n\ngT     切换到上一个标签页\n\nctrl+w s     水平分割窗口\n\nctrl+w v     垂直分割窗口\n\nctrl+w w     切换窗口\n\nctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)\n\n/pattern     向后搜索字符串pattern\n\n?pattern     向前搜索字符串pattern\n\nn     下一个匹配(如果是/搜\n\ndd     删除光标所在行\n\ndw     删除一个字(word)\n\nx     删除当前字符\n\nX     删除前一个字符\n\nD     删除到行末\n\nyy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行\n\nyw     复制一个字\n\ny$     复制到行末\n\np     粘贴粘贴板的内容到当前行的下面\n\nP     粘贴粘贴板的内容到当前行的上面\n\nh,j,k,l     上，下，左，右\n\nctrl-f     上翻一页\n\nctrl-b     下翻一页\n\n\n%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处\n\nw     跳到下一个字首，按标点或单词分割\n\nW     跳到下一个字首，长跳，如end-of-line被认为是一个字\n\ne     跳到下一个字尾\n\nE     跳到下一个字尾，长跳\n\nb     跳到上一个字\n\nB     跳到上一个字，长跳\n\n0     跳至行首，不管有无缩进，就是跳到第0个字符\n\n^     跳至行首的第一个字符\n\n$     跳至行尾\n\ngg     跳至文件的第一行\n\ngd     跳至当前光标所在的变量的声明处\n\n[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行\n\nfx     在当前行中找x字符，找到了就跳转至\n\ntx     与fx类似，但是只是跳转到x的前一个字符处\n\nFx     跟fx的方向相反\n\n),(     跳转到上/下一个语句\n\nH     移动光标到当前屏幕上最上边的一行\n\nM     移动光标到当前屏幕上中间的一行\n\nL     移动光标到当前屏幕上最下边的一行\n\ncc     删除当前行并进入编辑模式\n\ncw     删除当前字，并进入编辑模式\n\nc$     擦除从当前位置至行末的内容，并进入编辑模式\n\ns     删除当前字符并进入编辑模式\n\nS     删除光标所在行并进入编辑模式\n\nu     撤销\n\nctrl+r     重做\n\ni     从当前光标处进入插入模式\n\nI     进入插入模式，并置光标于行首\n\na     追加模式，置光标于当前光标之后\n\nA     追加模式，置光标于行末\n\no     在当前行之下新加一行，并进入插入模式\n\nO     在当前行之上新加一行，并进入插入模式\n\n\n#### 常用插件\n\ncsExplorer.vim  normal模式输入ColorSchemeExplorer： 可以列出所有的配色文件，然后一个个选择就行啦~\n\nNERD_tree.vim 输入NERD_tree 就能看到目录结构\no  打开关闭文件或者目录\n\np  到上层目录\n\nP  到根目录\n\nr  刷新选中目录 \n\nK  到第一个节点\n\nJ  到最后一个节点 \n\n## Alfred\n全局呼出任何程序，必备。自带得spotlight不好用\n\n安装后option＋space，可以加载任何想要的程序。\n\n## 配置命令行别名\nmac 中命令行打开chrome：\n\n      open -a Google\\ Chrome\n\n在iterm中：\n\n      vi /etc/profile\n      alias chrome=\"open -a Google\\ Chrome\"\n\n然后使之生效：\n\n      source /etc/profile \n\n这样得好处是，在命令行导航到某个文件夹得时候，可以直接使用chrome或者sublime打开这个文件。\n\n## brew\nbrew相当于ubuntu里面得apt-get.方便在mac中安装或者卸载软件。\n\n不过遇到得问题是，按照官方得安装方式：\n\n        ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n\n在iterm中不能使用brew。也是想着吧brew得安装目录仍系统路径中。 但是，总是找不到安装没有。\n\nfind全局发现在 .npm 里面。\n\n删除了原来的，重新安装就好了。\n\n        rm -rf /usr/local/Cellar /usr/local/.git && brew cleanup\n\n\n\n\n","mobiledoc":null,"html":"<h2 id=\"\">惯例</h2>\n\n<p>文章开头，惯例前戏。\nmac入手一周，越用越顺手，记录下使用习惯。</p>\n\n<p>文章会持续更新，朋友如果有更舒服得方式可以留言交流。</p>\n\n<h2 id=\"\">常用基本手势</h2>\n\n<p>左右切换屏幕： 四指左右滑动（习惯除去大拇指）</p>\n\n<p>上下滚动浏览： 两手指上下</p>\n\n<p>鼠标左键和右键： 一个手指单击和两个手指单击（默认是按下，修改了）</p>\n\n<p>查看当前打开程序： 四指向上或向下（查看当当前焦点程序得其他窗口）</p>\n\n<p>移动当前焦点窗口： 三指在title部分。</p>\n\n<h2 id=\"iterm\">iTerm</h2>\n\n<p>默认终端还不错，不过用过iTerm才知道什么叫好。\niTerm界面：</p>\n\n<p><img src=\"/content/images/2016/07/QQ20140418-1-2x.png\" alt=\"\" /></p>\n\n<p>下载：<a href=\"http://iterm.sourceforge.net/downloads.shtml\">http://iterm.sourceforge.net/downloads.shtml</a></p>\n\n<p>快捷键：</p>\n\n<p>command+d：垂直分割；</p>\n\n<p>command+shift+d：水平分割</p>\n\n<p>command+f 查找。之后按tab会继续选中并复制右边一个单词，shift+tab继续选中并复制左边一个单词。</p>\n\n<p>command+shift+h 自动列出剪切板的历史记录</p>\n\n<p>command+enter进入与返回全屏模式</p>\n\n<h2 id=\"vim\">VIM</h2>\n\n<p>一直见身边得人用这个神器，定位太叼了，可惜每次决心要用的时候，发现很痛苦后又换回sublime了。\n这次重新学习。</p>\n\n<h4 id=\"\">常用配置</h4>\n\n<p>创建一个文件 </p>\n\n<pre><code>  sudo touch ~/.vimrc\n</code></pre>\n\n<p>这是一个配置文件，内容在：<a href=\"https://github.com/freestyle21/tools/blob/master/.vimrc\">这里</a></p>\n\n<p>创建文件夹 </p>\n\n<pre><code>  sudo mkdir ~/vim/plugin\n  sudo mkdir ~/vim/colors\n</code></pre>\n\n<p>下载得插件都放在plugin，主题放colors，在.vimrc里面配置主题即可。</p>\n\n<h4 id=\"\">常用命令：</h4>\n\n<p>gt     切换到下一个标签页  </p>\n\n<p>gT     切换到上一个标签页</p>\n\n<p>ctrl+w s     水平分割窗口</p>\n\n<p>ctrl+w v     垂直分割窗口</p>\n\n<p>ctrl+w w     切换窗口</p>\n\n<p>ctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)</p>\n\n<p>/pattern     向后搜索字符串pattern</p>\n\n<p>?pattern     向前搜索字符串pattern</p>\n\n<p>n     下一个匹配(如果是/搜</p>\n\n<p>dd     删除光标所在行</p>\n\n<p>dw     删除一个字(word)</p>\n\n<p>x     删除当前字符</p>\n\n<p>X     删除前一个字符</p>\n\n<p>D     删除到行末</p>\n\n<p>yy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行</p>\n\n<p>yw     复制一个字</p>\n\n<p>y$     复制到行末</p>\n\n<p>p     粘贴粘贴板的内容到当前行的下面</p>\n\n<p>P     粘贴粘贴板的内容到当前行的上面</p>\n\n<p>h,j,k,l     上，下，左，右</p>\n\n<p>ctrl-f     上翻一页</p>\n\n<p>ctrl-b     下翻一页</p>\n\n<p>%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处</p>\n\n<p>w     跳到下一个字首，按标点或单词分割</p>\n\n<p>W     跳到下一个字首，长跳，如end-of-line被认为是一个字</p>\n\n<p>e     跳到下一个字尾</p>\n\n<p>E     跳到下一个字尾，长跳</p>\n\n<p>b     跳到上一个字</p>\n\n<p>B     跳到上一个字，长跳</p>\n\n<p>0     跳至行首，不管有无缩进，就是跳到第0个字符</p>\n\n<p>^     跳至行首的第一个字符</p>\n\n<p>$     跳至行尾</p>\n\n<p>gg     跳至文件的第一行</p>\n\n<p>gd     跳至当前光标所在的变量的声明处</p>\n\n<p>[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行</p>\n\n<p>fx     在当前行中找x字符，找到了就跳转至</p>\n\n<p>tx     与fx类似，但是只是跳转到x的前一个字符处</p>\n\n<p>Fx     跟fx的方向相反</p>\n\n<p>),(     跳转到上/下一个语句</p>\n\n<p>H     移动光标到当前屏幕上最上边的一行</p>\n\n<p>M     移动光标到当前屏幕上中间的一行</p>\n\n<p>L     移动光标到当前屏幕上最下边的一行</p>\n\n<p>cc     删除当前行并进入编辑模式</p>\n\n<p>cw     删除当前字，并进入编辑模式</p>\n\n<p>c$     擦除从当前位置至行末的内容，并进入编辑模式</p>\n\n<p>s     删除当前字符并进入编辑模式</p>\n\n<p>S     删除光标所在行并进入编辑模式</p>\n\n<p>u     撤销</p>\n\n<p>ctrl+r     重做</p>\n\n<p>i     从当前光标处进入插入模式</p>\n\n<p>I     进入插入模式，并置光标于行首</p>\n\n<p>a     追加模式，置光标于当前光标之后</p>\n\n<p>A     追加模式，置光标于行末</p>\n\n<p>o     在当前行之下新加一行，并进入插入模式</p>\n\n<p>O     在当前行之上新加一行，并进入插入模式</p>\n\n<h4 id=\"\">常用插件</h4>\n\n<p>csExplorer.vim  normal模式输入ColorSchemeExplorer： 可以列出所有的配色文件，然后一个个选择就行啦~</p>\n\n<p>NERD<em>tree.vim 输入NERD</em>tree 就能看到目录结构 <br />\no  打开关闭文件或者目录</p>\n\n<p>p  到上层目录</p>\n\n<p>P  到根目录</p>\n\n<p>r  刷新选中目录 </p>\n\n<p>K  到第一个节点</p>\n\n<p>J  到最后一个节点 </p>\n\n<h2 id=\"alfred\">Alfred</h2>\n\n<p>全局呼出任何程序，必备。自带得spotlight不好用</p>\n\n<p>安装后option＋space，可以加载任何想要的程序。</p>\n\n<h2 id=\"\">配置命令行别名</h2>\n\n<p>mac 中命令行打开chrome：</p>\n\n<pre><code>  open -a Google\\ Chrome\n</code></pre>\n\n<p>在iterm中：</p>\n\n<pre><code>  vi /etc/profile\n  alias chrome=\"open -a Google\\ Chrome\"\n</code></pre>\n\n<p>然后使之生效：</p>\n\n<pre><code>  source /etc/profile \n</code></pre>\n\n<p>这样得好处是，在命令行导航到某个文件夹得时候，可以直接使用chrome或者sublime打开这个文件。</p>\n\n<h2 id=\"brew\">brew</h2>\n\n<p>brew相当于ubuntu里面得apt-get.方便在mac中安装或者卸载软件。</p>\n\n<p>不过遇到得问题是，按照官方得安装方式：</p>\n\n<pre><code>    ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n</code></pre>\n\n<p>在iterm中不能使用brew。也是想着吧brew得安装目录仍系统路径中。 但是，总是找不到安装没有。</p>\n\n<p>find全局发现在 .npm 里面。</p>\n\n<p>删除了原来的，重新安装就好了。</p>\n\n<pre><code>    rm -rf /usr/local/Cellar /usr/local/.git &amp;&amp; brew cleanup\n</code></pre>","image":"/content/images/2016/07/20140601_110348_142.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:12:01","created_by":1,"updated_at":"2016-07-08 00:16:52","updated_by":1,"published_at":"2014-04-18 00:12:00","published_by":1},{"id":58,"uuid":"bc8aecb3-07d4-4c52-9c09-68fb5e1e1cf8","title":"关于长大","slug":"about-grown","markdown":"记得13年总结的时候，写过要多联系朋友。当时发出那样的感叹是因为过去忙于自己的事，从来不主动联系，每次想起时总有或多或少的内疚。\n\n久了，耐心没了，联系更少了。\n\n但总有那么几个朋友，无论多久不联系，无论相隔多远，一见面总会是那么的熟悉。无论我们在外面有多么装逼，凑在一起就会变成一群傻逼。最喜欢知乎的一个回答，什么样的朋友才是最好的朋友：“三秋不见如隔一日，既能亲密无间，也可相忘于江湖。”\n\n越长大越孤单，越孤单越安静。孤单还有另一个好处，就是一个人忙碌一天后，回寝室的路上，能够找个没人的地儿，看看天空，想想莫名其妙的。\n\n所谓成熟，就是经历的多了，遇到再大的事，都能够潇洒的点支烟，想一想，再来面对。\n\n\n \n\n","mobiledoc":null,"html":"<p>记得13年总结的时候，写过要多联系朋友。当时发出那样的感叹是因为过去忙于自己的事，从来不主动联系，每次想起时总有或多或少的内疚。</p>\n\n<p>久了，耐心没了，联系更少了。</p>\n\n<p>但总有那么几个朋友，无论多久不联系，无论相隔多远，一见面总会是那么的熟悉。无论我们在外面有多么装逼，凑在一起就会变成一群傻逼。最喜欢知乎的一个回答，什么样的朋友才是最好的朋友：“三秋不见如隔一日，既能亲密无间，也可相忘于江湖。”</p>\n\n<p>越长大越孤单，越孤单越安静。孤单还有另一个好处，就是一个人忙碌一天后，回寝室的路上，能够找个没人的地儿，看看天空，想想莫名其妙的。</p>\n\n<p>所谓成熟，就是经历的多了，遇到再大的事，都能够潇洒的点支烟，想一想，再来面对。</p>","image":"/content/images/2016/07/aa-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:17:16","created_by":1,"updated_at":"2016-07-08 00:18:27","updated_by":1,"published_at":"2014-03-01 00:17:00","published_by":1},{"id":59,"uuid":"a710df39-0f84-44f6-b2f8-5697dda69d4c","title":"关于「远程兼职」","slug":"about-parttime-job","markdown":">这篇文章创建在14.02.28，但是06.15才开始写。忙完整个毕业季，终于给大学划上一个句号。接下来整理好心情，享受工作和学习。\n最初接远程兼职得原因是大四上不想去帝都实习，又不想用家里钱，于是便想着在寝室干活挣钱。\n\n顺利毕业了，工作找到满意的，兼职也告一段落，大四算是结局圆满了。这里稍作整理，纪念做过得那些兼职，方便有同样意向得朋友。\n\n## 远程兼职是什么\n远程兼职，就是异地网上合作共同完成一个项目。我遇到得团队中，初创团队更倾向远程兼职，他们希望在实体办公前尽可能得压缩成本。\n\n## 远程兼职怎么找\n先不说怎么找远程兼职，换个角度想想如果我们是老板，我们会通过哪些渠道找人？\n\n最靠谱得应该算熟人推荐。老板会先在自己人脉库中搜寻，勾兑。\n\n如果没找到，就会通过认识得人，让他们推荐，叫做隐型人脉库。\n\n如果没找到，会在网上找。常见得是v2ex，上面自荐推荐得都很多，上v2ex得人大部分还是靠谱得。其次就是豆瓣了，在你能搜到得那几个组里面，经常会出现招兼职。\n\n所以，找活干主要就是通过熟人介绍，还有特定网站去搜寻。我的第一份远程兼职是在v2ex上找得，当时年轻气盛，发了一个自荐得贴，过了两个月第一个老板才联系过来。之后都是朋友介绍。\n\n## 远程兼职要求\n对于有远程兼职想法得web前端，我总结几个愉快完成兼职需要注意得地方。\n\n首先，时间。时间不够讲得再好都是扯淡，保证自己和别人约定得时间一致，同时自己也有缓冲得时间。\n\n其次，能力。接项目得时候可以指明前端或者后台，不过一般都会让前后都做，所以对前后端最好都有所了解。如果有独立完成项目得能力，那里远程会做的相对愉快些。\n\n另外，合作细节。合作之前最好有文档协议，双方确定好合作时间，阶段完成时间，阶段完成期望，阶段支付酬劳。\n\n## 远程兼职报酬\n这是一个敏感话题，多少也看自己谈多少。每次报酬根据项目工作量和难度而定，所以自己得对于项目估价有个市场了解。一般情况下，估价比标准价格多30%左右合适，时间比预期完成时间多一半合适，才不至于亏自己。\n\n## 远程兼职合作方式\n主要说说自己合作得方式。\n\n代码托管在`bitbucket`上，因为`github`主要是公有仓库，私有需要交费。而`bitbucket`主要是私有得。\n\n交流通过qq和邮件。\n\nbug管理，计划列表通过`trello`，每人一个bug list。\n\n测试服务器为ubuntu12.04，需要涉及到管理服务器，所以对于`linux`，`ngnix`等都要学一些。\n\n以上都是自己经历几段兼职后，总结得血于泪。不过，对于web前端更使用一些。\n","mobiledoc":null,"html":"<blockquote>\n  <p>这篇文章创建在14.02.28，但是06.15才开始写。忙完整个毕业季，终于给大学划上一个句号。接下来整理好心情，享受工作和学习。\n  最初接远程兼职得原因是大四上不想去帝都实习，又不想用家里钱，于是便想着在寝室干活挣钱。</p>\n</blockquote>\n\n<p>顺利毕业了，工作找到满意的，兼职也告一段落，大四算是结局圆满了。这里稍作整理，纪念做过得那些兼职，方便有同样意向得朋友。</p>\n\n<h2 id=\"\">远程兼职是什么</h2>\n\n<p>远程兼职，就是异地网上合作共同完成一个项目。我遇到得团队中，初创团队更倾向远程兼职，他们希望在实体办公前尽可能得压缩成本。</p>\n\n<h2 id=\"\">远程兼职怎么找</h2>\n\n<p>先不说怎么找远程兼职，换个角度想想如果我们是老板，我们会通过哪些渠道找人？</p>\n\n<p>最靠谱得应该算熟人推荐。老板会先在自己人脉库中搜寻，勾兑。</p>\n\n<p>如果没找到，就会通过认识得人，让他们推荐，叫做隐型人脉库。</p>\n\n<p>如果没找到，会在网上找。常见得是v2ex，上面自荐推荐得都很多，上v2ex得人大部分还是靠谱得。其次就是豆瓣了，在你能搜到得那几个组里面，经常会出现招兼职。</p>\n\n<p>所以，找活干主要就是通过熟人介绍，还有特定网站去搜寻。我的第一份远程兼职是在v2ex上找得，当时年轻气盛，发了一个自荐得贴，过了两个月第一个老板才联系过来。之后都是朋友介绍。</p>\n\n<h2 id=\"\">远程兼职要求</h2>\n\n<p>对于有远程兼职想法得web前端，我总结几个愉快完成兼职需要注意得地方。</p>\n\n<p>首先，时间。时间不够讲得再好都是扯淡，保证自己和别人约定得时间一致，同时自己也有缓冲得时间。</p>\n\n<p>其次，能力。接项目得时候可以指明前端或者后台，不过一般都会让前后都做，所以对前后端最好都有所了解。如果有独立完成项目得能力，那里远程会做的相对愉快些。</p>\n\n<p>另外，合作细节。合作之前最好有文档协议，双方确定好合作时间，阶段完成时间，阶段完成期望，阶段支付酬劳。</p>\n\n<h2 id=\"\">远程兼职报酬</h2>\n\n<p>这是一个敏感话题，多少也看自己谈多少。每次报酬根据项目工作量和难度而定，所以自己得对于项目估价有个市场了解。一般情况下，估价比标准价格多30%左右合适，时间比预期完成时间多一半合适，才不至于亏自己。</p>\n\n<h2 id=\"\">远程兼职合作方式</h2>\n\n<p>主要说说自己合作得方式。</p>\n\n<p>代码托管在<code>bitbucket</code>上，因为<code>github</code>主要是公有仓库，私有需要交费。而<code>bitbucket</code>主要是私有得。</p>\n\n<p>交流通过qq和邮件。</p>\n\n<p>bug管理，计划列表通过<code>trello</code>，每人一个bug list。</p>\n\n<p>测试服务器为ubuntu12.04，需要涉及到管理服务器，所以对于<code>linux</code>，<code>ngnix</code>等都要学一些。</p>\n\n<p>以上都是自己经历几段兼职后，总结得血于泪。不过，对于web前端更使用一些。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:20:09","created_by":1,"updated_at":"2016-07-08 00:23:48","updated_by":1,"published_at":"2014-01-18 00:20:00","published_by":1},{"id":60,"uuid":"6d402e86-e81e-4203-b332-7074dde9a86e","title":"BackBone 源码解读及思考","slug":"backbone-code-learn","markdown":"## 说明\n前段时间略忙，终于找到时间看看backbone代码。\n\n正如知友们说的那样，backbone简单、随性。 代码简单的看一眼，就能知道作者的思路。因为简单，所以随性，可以很自由的和其他类库大搭配使用，不太要求特别的格式。\n\n本文会关注backbone实现的细节，整体框架在博客园的一位朋友已经总结的很好了。链接：[点击这里](http://www.cnblogs.com/nuysoft/archive/2012/03/19/2404274.html)\n\n本文Bakcbone版本： \n\n            // 定义Backbone版本\n            Backbone.VERSION = '0.9.2';\n\n#### 照例提点问题，有目的的读源码。\n\n1. 怎么和模板引擎配合使用的。\n2.  RESTful JSON 接口从服务器检索到的数据\n3. 通过源码，了解到平时使用时的哪些需要注意的细节。\n4. 当models中值被改变时自动触发一个\"change\"事件、所有用于展示models数据的views都会侦听到这个事件，然后进行重新渲染。如何实现？\n5. 如何兼容IE6+\n6. view model collection怎么关联的。\n\n## 整体框架\n\n        (function() {\n            Backbone.Events        // 自定义事件\n            Backbone.Model        // 模型构造函数和原型扩展\n            Backbone.Collection    // 集合构造函数和原型扩展\n            Backbone.Router        // 路由配置器构造函数和原型扩展\n            Backbone.History        // 路由器构造函数和原型扩展\n            Backbone.View            // 视图构造函数和原型扩展\n            Backbone.sync            // 异步请求工具方法\n            var extend = function (protoProps, classProps) { ... } // 自扩展函数\n            Backbone.Model.extend = Backbone.Collection.extend =          Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法\n        }).call(this);\n\n本文的思路是按照这个框架，提炼每个部分的重要部分，解决上面提出的问题，并注释平时使用时需要注意的细节。\n\n## Events\n\n            var Events = Backbone.Events = {\n            // 该方法类似与DOM Level2中的addEventListener方法\n            // events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等)\n            // 当事件名称为\"all\"时, 在调用trigger方法触发任何事件时, 均会调用\"all\"事件中绑定的所有回调函数\n            on : function(events, callback, context) {\n                var calls, event, node, tail, list;\n                if(!callback)\n                    return this;\n                // eventSplitter = /\\s+/; 把多个事件名组成的字符串分开。\n                events = events.split(eventSplitter);\n\n                // 所有事件都存在this._callbacks这个数组里面\n                calls = this._callbacks || (this._callbacks = {});\n\n                while( event = events.shift()) {\n                    list = calls[event];\n                    node = list ? list.tail : {};\n                    node.next = tail = {};\n                    node.context = context;\n                    node.callback = callback;\n                    // 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件\n                    calls[event] = {\n                        tail : tail,\n                        next : list ? list.next : node\n                    };\n                }\n                // 返回当前对象, 方便进行方法链调用\n                return this;\n            },\n            // - 如果context为空, 则移除所有的callback指定的函数\n            // - 如果callback为空, 则移除事件中所有的回调函数\n            // - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称)\n            // - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数\n            off : function(events, callback, context) {\n                // code...\n                return this;\n            },\n            // 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表\n            trigger : function(events) {\n                var event, node, calls, tail, args, all, rest;\n                // 当前对象没有绑定任何事件\n                if(!( calls = this._callbacks))\n                    return this;\n                // 获取回调函数列表中绑定的\"all\"事件列表\n                all = calls.all;\n                // 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组\n                events = events.split(eventSplitter);\n                // 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数\n                rest = slice.call(arguments, 1);\n\n                // 循环需要触发的事件列表\n                while( event = events.shift()) {\n                    // 此处的node变量记录了当前事件的所有回调函数列表\n                    if( node = calls[event]) {\n                        tail = node.tail;\n                        // node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象\n                        // 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据\n                        while(( node = node.next) !== tail) {\n                            // 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数\n                            node.callback.apply(node.context || this, rest);\n                        }\n                    }\n                    if( node = all) {\n                        tail = node.tail;\n                        // 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数\n                        args = [event].concat(rest);\n                        // 遍历并执行\"all\"事件中的回调函数列表\n                        while(( node = node.next) !== tail) {\n                            node.callback.apply(node.context || this, args);\n                        }\n                    }\n                }\n\n                return this;\n            }\n        };\n        // 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本\n        Events.bind = Events.on;\n        Events.unbind = Events.off;\n\n\n## Model\nModel 比较常用，很多细节，所以列出了几个重要的函数，注释了一些重要细节。\n\n        _.extend(Model.prototype, Events, {\n             // code..\n            // 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值\n            set : function(key, value, options) {\n                var attrs, attr, val;\n\n                // 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置\n                // 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数\n                if(_.isObject(key) || key == null) {\n                    attrs = key;\n                    options = value;\n                } else {\n                    attrs = {};\n                    attrs[key] = value;\n                }\n\n                // options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象\n                options || ( options = {});\n                if(!attrs)\n                    return this;\n                // 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs\n                // 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作\n                if( attrs instanceof Model)\n                    attrs = attrs.attributes;\n                \n                // 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作\n                if(options.unset)\n                    for(attr in attrs)\n                    attrs[attr] =\n                    void 0;\n\n                // 如果设置了validate() 函数，则需要验证\n                if(!this._validate(attrs, options))\n                    return false;\n\n                // 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性\n                // 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id\n                if(this.idAttribute in attrs)\n                    this.id = attrs[this.idAttribute];\n\n                var changes = options.changes = {};\n                // now记录当前模型中的数据对象\n                var now = this.attributes;\n                // escaped记录当前模型中通过escape缓存过的数据\n                var escaped = this._escapedAttributes;\n                // prev记录模型中数据被改变之前的值\n                var prev = this._previousAttributes || {};\n\n                // code..\n\n                // 如果没有配置silent参数，则需要触发change函数。\n                if(!options.silent)\n                    this.change(options);\n                return this;\n            },\n            // 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件\n            fetch : function(options) {\n                options = options ? _.clone(options) : {};\n                var model = this;\n                var success = options.success;\n                // 当获取数据成功后填充数据并调用自定义成功回调函数\n                options.success = function(resp, status, xhr) {\n                    // 如果填充数据时验证失败, 则不会调用自定义success回调函数\n                    if(!model.set(model.parse(resp, xhr), options))\n                        return false;\n                    // 调用自定义的success回调函数\n                    if(success)\n                        success(model, resp);\n                };\n                // 请求发生错误时通过wrapError处理error事件\n                options.error = Backbone.wrapError(options.error, model, options);\n                // 所有的读取数据(Model, Collection)都是通过sync提供的HTTP方法操作\n                return (this.sync || Backbone.sync).call(this, 'read', this, options);\n            },\n            // 保存模型中的数据到服务器\n            save : function(key, value, options) {\n                // attrs存储需要保存到服务器的数据对象\n                var attrs, current;\n\n                // 支持设置单个属性的方式 key: value\n                // 支持对象形式的批量设置方式 {key: value}\n                if(_.isObject(key) || key == null) {\n                    // 如果key是一个对象, 则认为是通过对象方式设置\n                    // 此时第二个参数被认为是options\n                    attrs = key;\n                    options = value;\n                } else {\n                    // 如果是通过key: value形式设置单个属性, 则直接设置attrs\n                    attrs = {};\n                    attrs[key] = value;\n                }\n                // 配置对象必须是一个新的对象\n                options = options ? _.clone(options) : {};\n\n                // 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态\n                // 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态\n                if(options.wait) {\n                    // 对需要保存的数据提前进行验证\n                    if(!this._validate(attrs, options))\n                        return false;\n                    current = _.clone(this.attributes);\n                }\n\n                var model = this;\n                // 在options中可以指定保存数据成功后的自定义回调函数\n                var success = options.success;\n                options.success = function(resp, status, xhr) {\n                    var serverAttrs = model.parse(resp, xhr);\n                    if(options.wait) {\n                        delete options.wait;\n                        serverAttrs = _.extend(attrs || {}, serverAttrs);\n                    }\n                    // 如果调用set方法时验证失败, 则不会调用自定义的success回调函数\n                    if(!model.set(serverAttrs, options))\n                        return false;\n                    if(success) {\n                        // 调用响应成功后自定义的success回调函数\n                        success(model, resp);\n                    } else {\n                        // 如果没有指定自定义回调, 则默认触发sync事件\n                        model.trigger('sync', model, resp, options);\n                    }\n                };\n                // 请求发生错误时通过wrapError处理error事件\n                options.error = Backbone.wrapError(options.error, model, options);\n                \n                var method = this.isNew() ? 'create' : 'update';\n                var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n                // 如果设置了options.wait, 则将数据还原为修改前的状态\n                // 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态\n                if(options.wait)\n                    this.set(current, silentOptions);\n                return xhr;\n            },\n            // code..\n        });\n\n\n## Collection \n\n          var Collection = Backbone.Collection = function(models, options) {\n            options || ( options = {});\n            if(options.model)\n                this.model = options.model;\n            // 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用) \n            // 当然也可以服务器做好了传回来，但是如果前后属于不同团队就不好做了。\n            if(options.comparator)\n                this.comparator = options.comparator;\n\n            // 实例化时重置集合的内部状态(第一次调用时可理解为定义状态)\n            this._reset();\n            this.initialize.apply(this, arguments);\n            \n            // 首次调用时设置了silent参数, 因此不会触发\"reset\"事件\n            if(models)\n                this.reset(models, {\n                    silent : true,\n                    parse : options.parse\n                });\n        };\n        _.extend(Collection.prototype, Events, {\n            // 定义集合的模型类, 模型类必须是一个Backbone.Model的子类\n            model : Model,\n            initialize : function() {\n            },\n            // 返回一个数组, 包含了集合中每个模型的数据对象\n            toJSON : function(options) {\n                return this.map(function(model) {\n                    return model.toJSON(options);\n                });\n            },\n            // 默认会触发\"add\"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发\n            // 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 {name: 'test'}), 将自动将数据对象实例化为model指向的模型对象\n            add : function(models, options) {\n                var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];\n                options || ( options = {});\n                // models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组\n                models = _.isArray(models) ? models.slice() : [models];\n\n                // 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作:\n                // - 将数据对象转化模型对象\n                // - 建立模型与集合之间的引用\n                // - 记录无效和重复的模型, 并在后面进行过滤\n                for( i = 0, length = models.length; i < length; i++) {\n                   \n                    // 当前模型的cid和id\n                    cid = model.cid;\n                    id = model.id;\n                    // dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除\n                    if(cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {\n                        dups.push(i);\n                        continue;\n                    }\n                    cids[cid] = ids[id] = model;\n                }\n                // 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表\n                i = dups.length;\n                while(i--) {\n                    models.splice(dups[i], 1);\n                }\n\n                // code ...\n\n                // 遍历新增加的模型列表\n                for( i = 0, length = this.models.length; i < length; i++) {\n                    if(!cids[( model = this.models[i]).cid])\n                        continue;\n                    options.index = i;\n                    // 触发模型的\"add\"事件, 因为集合监听了模型的\"all\"事件, 因此在_onModelEvent方法中, 集合也将触发\"add\"事件\n                    // 详细信息可参考Collection.prototype._onModelEvent方法\n                    model.trigger('add', model, this, options);\n                }\n                return this;\n            },\n            // 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件)\n            remove : function(models, options) {\n                var i, l, index, model;\n                options || ( options = {});\n                models = _.isArray(models) ? models.slice() : [models];\n                // 遍历需要移除的模型列表\n                for( i = 0, l = models.length; i < l; i++) {\n                    model = this.getByCid(models[i]) || this.get(models[i]);\n                    if(!model)\n                        continue;\n                    delete this._byId[model.id];\n                    delete this._byCid[model.cid];\n                    index = this.indexOf(model);\n                    this.models.splice(index, 1);\n                    this.length--;\n                    // 如果没有设置silent属性, 则触发模型的remove事件\n                    if(!options.silent) {\n                        options.index = index;\n                        model.trigger('remove', model, this, options);\n                    }\n                    this._removeReference(model);\n                }\n                return this;\n            },\n            push : function(model, options) {\n                model = this._prepareModel(model, options);\n                this.add(model, options);\n                return model;\n            },\n            // code ..\n        });\n\n\n## Router & History\n   \n        var Router = Backbone.Router = function(options) {\n            options || ( options = {});\n            if(options.routes)\n                this.routes = options.routes;\n            this._bindRoutes();\n            this.initialize.apply(this, arguments);\n        };\n        _.extend(Router.prototype, Events, {\n            // 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件\n            route : function(route, name, callback) {\n                // 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化\n                Backbone.history || (Backbone.history = new History);\n                // code ...\n                Backbone.history.route(route, _.bind(function(fragment) {\n                    var args = this._extractParameters(route, fragment);\n                    // 调用callback路由监听事件, 并将参数传递给监听事件\n                    callback && callback.apply(this, args);\n                    \n                    this.trigger.apply(this, ['route:' + name].concat(args));\n                    // 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件\n                    Backbone.history.trigger('route', this, name, args);\n                    \n                }, this));\n                return this;\n            },\n           // code ..\n        });\n\n        // History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问)\n        var History = Backbone.History = function() {\n            this.handlers = [];\n            // checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法\n            _.bindAll(this, 'checkUrl');\n        };\n\n        _.extend(History.prototype, Events, {\n            // 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化\n            // interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置)\n            interval : 50,\n            // 获取location中Hash字符串(锚点#后的片段)\n            getHash : function(windowOverride) {\n                // 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取\n                var loc = windowOverride ? windowOverride.location : window.location;\n                // 将锚点(#)后的字符串提取出来并返回\n                var match = loc.href.match(/#(.*)$/);\n                return match ? match[1] : '';\n            },\n            // 根据当前设置的路由方式, 处理并返回当前URL中的路由片段\n            getFragment : function(fragment, forcePushState) {\n                // fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288)\n                if(fragment == null) {\n                    if(this._hasPushState || forcePushState) {\n                        // 使用了pushState方式进行路由\n                        fragment = window.location.pathname;\n                        // search记录当前页面后的参数内容\n                        var search = window.location.search;\n                        // 将路径和参数合并在一起, 作为待处理的路由片段\n                        if(search)\n                            fragment += search; \n                    } else {\n                        // 使用了hash方式进行路由\n                        // 通过getHash方法获取当前锚点(#)后的字符串作为路由片段\n                        fragment = this.getHash();\n                    }\n                }\n                if(!fragment.indexOf(this.options.root))\n                    fragment = fragment.substr(this.options.root.length);\n                // 如果URL片段首字母为\"#\"或\"/\", 则去除该字符\n                return fragment.replace(routeStripper, '');\n            },\n            // 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数\n            start : function(options) {\n\n                // (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式)\n                this._wantsHashChange = this.options.hashChange !== false;\n                // _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器\n                // pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式\n                this._wantsPushState = !!this.options.pushState;\n\n                // _hasPushState属性记录浏览器是否支持pushState特性\n                this._hasPushState = !!(this.options.pushState && window.history && window.history.pushState);\n\n                var fragment = this.getFragment();\n                // documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式\n                var docMode = document.documentMode;\n                var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n                if(oldIE) {\n                    // 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件\n                    // 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由\n                    this.iframe = $('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\n                    this.navigate(fragment);\n                }\n\n                // 开始监听路由状态变化\n                if(this._hasPushState) {\n                    // 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法\n                    $(window).bind('popstate', this.checkUrl);\n                } else if(this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n                    // 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法\n                    $(window).bind('hashchange', this.checkUrl);\n                } else if(this._wantsHashChange) {\n                    // 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率\n                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n                }\n                // code ..\n            },\n            // 停止history对路由的监控, 并将状态恢复为未监听状态\n            stop : function() {\n                // 解除对浏览器路由的onpopstate和onhashchange事件的监听\n                $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n                // 停止对于低版本的IE浏览器的心跳监控\n                clearInterval(this._checkUrlInterval);\n                // 恢复started状态, 便于下次重新调用start方法\n                History.started = false;\n            },\n            // 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用\n            checkUrl : function(e) {\n                // 获取当前的URL片段\n                var current = this.getFragment();\n                // 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量\n                if(current == this.fragment && this.iframe)\n                    current = this.getFragment(this.getHash(this.iframe));\n                // 如果当前URL与上一次的状态没有发生任何变化, 则停止执行\n                if(current == this.fragment)\n                    return false;\n\n                // 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL\n                if(this.iframe)\n                    this.navigate(current);\n                // 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法\n                this.loadUrl() || this.loadUrl(this.getHash());\n            },\n            // code ..\n        });\n\n## View\n\n     \n        // Backbone.View 视图相关\n        var View = Backbone.View = function(options) {\n            // 为每一个视图对象创建一个唯一标识, 前缀为\"view\"\n            this.cid = _.uniqueId('view');\n            this._configure(options || {});\n            this._ensureElement();\n            this.initialize.apply(this, arguments);\n            this.delegateEvents();\n        };\n\n        // viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身\n        var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];\n        _.extend(View.prototype, Events, {\n            // 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签\n            tagName : 'div',\n            // code ..\n            // 移除当前视图的$el元素\n            remove : function() {\n                // 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据\n                this.$el.remove();\n                return this;\n            },\n            // 该方法用于在内部创建this.el时自动调用\n            make : function(tagName, attributes, content) {\n                var el = document.createElement(tagName);\n                if(attributes)\n                    $(el).attr(attributes);\n                if(content)\n                    $(el).html(content);\n                return el;\n            },\n            // 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用\n            setElement : function(element, delegate) {\n                // this.$el 存放Jquery或其他库的示例对象\n                this.$el = ( element instanceof $) ? element : $(element);\n                // this.el存放标准的DOM对象\n                this.el = this.$el[0];\n                // code ...\n                return this;\n            },\n            // 为视图元素绑定事件\n            // events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'):\n            // {\n            //     'click #title': 'edit',\n            //     'click .save': 'save'\n            //     'click span': function() {}\n            // }\n            // 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合)\n            delegateEvents : function(events) {\n                if(!(events || ( events = getValue(this, 'events'))))\n                    return;\n                // 取消当前已经绑定过的events事件\n                this.undelegateEvents();\n                for(var key in events) {\n                    // code ...                \n                    // 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素\n                    // 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中\n                    var match = key.match(delegateEventSplitter);\n                    // eventName为解析后的事件名称\n                    // selector为解析后的事件元素选择器表达式\n                    var eventName = match[1], selector = match[2];\n                    \n                    method = _.bind(method, this);\n                    // 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法\n                    eventName += '.delegateEvents' + this.cid;\n                    if(selector === '') {\n                        this.$el.bind(eventName, method);\n                    } else {\n                        this.$el.delegate(selector, eventName, method);\n                    }\n                }\n            },\n            \n            // 在实例化视图对象时设置初始配置\n            // 将传递的配置覆盖到对象的options中\n            // 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性\n            _configure : function(options) {\n                // 如果对象本身设置了默认配置, 则使用传递的配置进行合并\n                if(this.options)\n                    options = _.extend({}, this.options, options);\n                // 遍历viewOptions列表\n                for(var i = 0, l = viewOptions.length; i < l; i++) {\n                    // attr依次为viewOptions中的属性名\n                    var attr = viewOptions[i];\n                    // 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性\n                    if(options[attr])\n                        this[attr] = options[attr];\n                }\n                this.options = options;\n            },\n            _ensureElement : function() {\n                \n                if(!this.el) {\n                    // 如果没有设置el属性, 则创建默认元素\n                    var attrs = getValue(this, 'attributes') || {};\n                    if(this.id)\n                        attrs.id = this.id;\n                    if(this.className)\n                        attrs['class'] = this.className;\n                    // 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素\n                    this.setElement(this.make(this.tagName, attrs), false);\n                } else {\n                    // 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素\n                    this.setElement(this.el, false);\n                }\n            }\n        });\n\n\n## Backbone.sync\n\n    var methodMap = {\n            'create' : 'POST',\n            'update' : 'PUT',\n            'delete' : 'DELETE',\n            'read' : 'GET'\n        };\n        // Async用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的连接\n        // sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持\n        // Model Collection save 或者fetch都用这个这个类。\n        Backbone.sync = function(method, model, options) {\n            // 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE)\n            var type = methodMap[method];\n\n            // params将作为请求参数对象传递给第三方库的$.ajax方法\n            var params = {\n                // 请求类型\n                type : type,\n                // 数据格式默认为json\n                dataType : 'json'\n            };\n\n            // 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url\n            if(!options.url) {\n                params.url = getValue(model, 'url') || urlError();\n            }\n\n            if(!options.data && model && (method == 'create' || method == 'update')) {\n                params.contentType = 'application/json';\n                params.data = JSON.stringify(model.toJSON());\n            }\n            if(Backbone.emulateHTTP) {\n                // 如果操作类型为PUT或DELETE\n                if(type === 'PUT' || type === 'DELETE') {\n                    // 将操作名称存放到_method参数发送到服务器\n                    if(Backbone.emulateJSON)\n                        params.data._method = type;\n                    // 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息\n                    params.type = 'POST';\n                    params.beforeSend = function(xhr) {\n                        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                    };\n                }\n            }\n            // 通过第三方库的$.ajax方法向服务器发送请求同步数据状态\n            return $.ajax(_.extend(params, options));\n        };\n\n\n## 使用\n\n            \n        var extend = function(protoProps, classProps) {\n            // child存储已经实现继承自当前类的子类(Function)\n            // protoProps设置子类原型链中的属性\n            // classProps设置子类的静态属性\n            var child = inherits(this, protoProps, classProps);\n            // 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承\n            child.extend = this.extend;\n            // 返回实现继承的子类\n            return child;\n        };\n        // 为Model, Collection, Router和View类实现继承机制 每次使用只需要 Backbone.View.extend({...});\n        Model.extend = Collection.extend = Router.extend = View.extend = extend;\n\n\n## 说明\n\n本次分析基本上对翻译源码注释，中间省略了一些个人认为对理解代码实现和平时应用关系不大的代码。","mobiledoc":null,"html":"<h2 id=\"\">说明</h2>\n\n<p>前段时间略忙，终于找到时间看看backbone代码。</p>\n\n<p>正如知友们说的那样，backbone简单、随性。 代码简单的看一眼，就能知道作者的思路。因为简单，所以随性，可以很自由的和其他类库大搭配使用，不太要求特别的格式。</p>\n\n<p>本文会关注backbone实现的细节，整体框架在博客园的一位朋友已经总结的很好了。链接：<a href=\"http://www.cnblogs.com/nuysoft/archive/2012/03/19/2404274.html\">点击这里</a></p>\n\n<p>本文Bakcbone版本： </p>\n\n<pre><code>        // 定义Backbone版本\n        Backbone.VERSION = '0.9.2';\n</code></pre>\n\n<h4 id=\"\">照例提点问题，有目的的读源码。</h4>\n\n<ol>\n<li>怎么和模板引擎配合使用的。  </li>\n<li>RESTful JSON 接口从服务器检索到的数据  </li>\n<li>通过源码，了解到平时使用时的哪些需要注意的细节。  </li>\n<li>当models中值被改变时自动触发一个\"change\"事件、所有用于展示models数据的views都会侦听到这个事件，然后进行重新渲染。如何实现？  </li>\n<li>如何兼容IE6+  </li>\n<li>view model collection怎么关联的。</li>\n</ol>\n\n<h2 id=\"\">整体框架</h2>\n\n<pre><code>    (function() {\n        Backbone.Events        // 自定义事件\n        Backbone.Model        // 模型构造函数和原型扩展\n        Backbone.Collection    // 集合构造函数和原型扩展\n        Backbone.Router        // 路由配置器构造函数和原型扩展\n        Backbone.History        // 路由器构造函数和原型扩展\n        Backbone.View            // 视图构造函数和原型扩展\n        Backbone.sync            // 异步请求工具方法\n        var extend = function (protoProps, classProps) { ... } // 自扩展函数\n        Backbone.Model.extend = Backbone.Collection.extend =          Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法\n    }).call(this);\n</code></pre>\n\n<p>本文的思路是按照这个框架，提炼每个部分的重要部分，解决上面提出的问题，并注释平时使用时需要注意的细节。</p>\n\n<h2 id=\"events\">Events</h2>\n\n<pre><code>        var Events = Backbone.Events = {\n        // 该方法类似与DOM Level2中的addEventListener方法\n        // events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等)\n        // 当事件名称为\"all\"时, 在调用trigger方法触发任何事件时, 均会调用\"all\"事件中绑定的所有回调函数\n        on : function(events, callback, context) {\n            var calls, event, node, tail, list;\n            if(!callback)\n                return this;\n            // eventSplitter = /\\s+/; 把多个事件名组成的字符串分开。\n            events = events.split(eventSplitter);\n\n            // 所有事件都存在this._callbacks这个数组里面\n            calls = this._callbacks || (this._callbacks = {});\n\n            while( event = events.shift()) {\n                list = calls[event];\n                node = list ? list.tail : {};\n                node.next = tail = {};\n                node.context = context;\n                node.callback = callback;\n                // 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件\n                calls[event] = {\n                    tail : tail,\n                    next : list ? list.next : node\n                };\n            }\n            // 返回当前对象, 方便进行方法链调用\n            return this;\n        },\n        // - 如果context为空, 则移除所有的callback指定的函数\n        // - 如果callback为空, 则移除事件中所有的回调函数\n        // - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称)\n        // - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数\n        off : function(events, callback, context) {\n            // code...\n            return this;\n        },\n        // 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表\n        trigger : function(events) {\n            var event, node, calls, tail, args, all, rest;\n            // 当前对象没有绑定任何事件\n            if(!( calls = this._callbacks))\n                return this;\n            // 获取回调函数列表中绑定的\"all\"事件列表\n            all = calls.all;\n            // 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组\n            events = events.split(eventSplitter);\n            // 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数\n            rest = slice.call(arguments, 1);\n\n            // 循环需要触发的事件列表\n            while( event = events.shift()) {\n                // 此处的node变量记录了当前事件的所有回调函数列表\n                if( node = calls[event]) {\n                    tail = node.tail;\n                    // node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象\n                    // 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据\n                    while(( node = node.next) !== tail) {\n                        // 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数\n                        node.callback.apply(node.context || this, rest);\n                    }\n                }\n                if( node = all) {\n                    tail = node.tail;\n                    // 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数\n                    args = [event].concat(rest);\n                    // 遍历并执行\"all\"事件中的回调函数列表\n                    while(( node = node.next) !== tail) {\n                        node.callback.apply(node.context || this, args);\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n    // 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n</code></pre>\n\n<h2 id=\"model\">Model</h2>\n\n<p>Model 比较常用，很多细节，所以列出了几个重要的函数，注释了一些重要细节。</p>\n\n<pre><code>    _.extend(Model.prototype, Events, {\n         // code..\n        // 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值\n        set : function(key, value, options) {\n            var attrs, attr, val;\n\n            // 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置\n            // 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数\n            if(_.isObject(key) || key == null) {\n                attrs = key;\n                options = value;\n            } else {\n                attrs = {};\n                attrs[key] = value;\n            }\n\n            // options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象\n            options || ( options = {});\n            if(!attrs)\n                return this;\n            // 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs\n            // 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作\n            if( attrs instanceof Model)\n                attrs = attrs.attributes;\n\n            // 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作\n            if(options.unset)\n                for(attr in attrs)\n                attrs[attr] =\n                void 0;\n\n            // 如果设置了validate() 函数，则需要验证\n            if(!this._validate(attrs, options))\n                return false;\n\n            // 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性\n            // 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id\n            if(this.idAttribute in attrs)\n                this.id = attrs[this.idAttribute];\n\n            var changes = options.changes = {};\n            // now记录当前模型中的数据对象\n            var now = this.attributes;\n            // escaped记录当前模型中通过escape缓存过的数据\n            var escaped = this._escapedAttributes;\n            // prev记录模型中数据被改变之前的值\n            var prev = this._previousAttributes || {};\n\n            // code..\n\n            // 如果没有配置silent参数，则需要触发change函数。\n            if(!options.silent)\n                this.change(options);\n            return this;\n        },\n        // 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件\n        fetch : function(options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n            // 当获取数据成功后填充数据并调用自定义成功回调函数\n            options.success = function(resp, status, xhr) {\n                // 如果填充数据时验证失败, 则不会调用自定义success回调函数\n                if(!model.set(model.parse(resp, xhr), options))\n                    return false;\n                // 调用自定义的success回调函数\n                if(success)\n                    success(model, resp);\n            };\n            // 请求发生错误时通过wrapError处理error事件\n            options.error = Backbone.wrapError(options.error, model, options);\n            // 所有的读取数据(Model, Collection)都是通过sync提供的HTTP方法操作\n            return (this.sync || Backbone.sync).call(this, 'read', this, options);\n        },\n        // 保存模型中的数据到服务器\n        save : function(key, value, options) {\n            // attrs存储需要保存到服务器的数据对象\n            var attrs, current;\n\n            // 支持设置单个属性的方式 key: value\n            // 支持对象形式的批量设置方式 {key: value}\n            if(_.isObject(key) || key == null) {\n                // 如果key是一个对象, 则认为是通过对象方式设置\n                // 此时第二个参数被认为是options\n                attrs = key;\n                options = value;\n            } else {\n                // 如果是通过key: value形式设置单个属性, 则直接设置attrs\n                attrs = {};\n                attrs[key] = value;\n            }\n            // 配置对象必须是一个新的对象\n            options = options ? _.clone(options) : {};\n\n            // 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态\n            // 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态\n            if(options.wait) {\n                // 对需要保存的数据提前进行验证\n                if(!this._validate(attrs, options))\n                    return false;\n                current = _.clone(this.attributes);\n            }\n\n            var model = this;\n            // 在options中可以指定保存数据成功后的自定义回调函数\n            var success = options.success;\n            options.success = function(resp, status, xhr) {\n                var serverAttrs = model.parse(resp, xhr);\n                if(options.wait) {\n                    delete options.wait;\n                    serverAttrs = _.extend(attrs || {}, serverAttrs);\n                }\n                // 如果调用set方法时验证失败, 则不会调用自定义的success回调函数\n                if(!model.set(serverAttrs, options))\n                    return false;\n                if(success) {\n                    // 调用响应成功后自定义的success回调函数\n                    success(model, resp);\n                } else {\n                    // 如果没有指定自定义回调, 则默认触发sync事件\n                    model.trigger('sync', model, resp, options);\n                }\n            };\n            // 请求发生错误时通过wrapError处理error事件\n            options.error = Backbone.wrapError(options.error, model, options);\n\n            var method = this.isNew() ? 'create' : 'update';\n            var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n            // 如果设置了options.wait, 则将数据还原为修改前的状态\n            // 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态\n            if(options.wait)\n                this.set(current, silentOptions);\n            return xhr;\n        },\n        // code..\n    });\n</code></pre>\n\n<h2 id=\"collection\">Collection</h2>\n\n<pre><code>      var Collection = Backbone.Collection = function(models, options) {\n        options || ( options = {});\n        if(options.model)\n            this.model = options.model;\n        // 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用) \n        // 当然也可以服务器做好了传回来，但是如果前后属于不同团队就不好做了。\n        if(options.comparator)\n            this.comparator = options.comparator;\n\n        // 实例化时重置集合的内部状态(第一次调用时可理解为定义状态)\n        this._reset();\n        this.initialize.apply(this, arguments);\n\n        // 首次调用时设置了silent参数, 因此不会触发\"reset\"事件\n        if(models)\n            this.reset(models, {\n                silent : true,\n                parse : options.parse\n            });\n    };\n    _.extend(Collection.prototype, Events, {\n        // 定义集合的模型类, 模型类必须是一个Backbone.Model的子类\n        model : Model,\n        initialize : function() {\n        },\n        // 返回一个数组, 包含了集合中每个模型的数据对象\n        toJSON : function(options) {\n            return this.map(function(model) {\n                return model.toJSON(options);\n            });\n        },\n        // 默认会触发\"add\"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发\n        // 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 {name: 'test'}), 将自动将数据对象实例化为model指向的模型对象\n        add : function(models, options) {\n            var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];\n            options || ( options = {});\n            // models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组\n            models = _.isArray(models) ? models.slice() : [models];\n\n            // 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作:\n            // - 将数据对象转化模型对象\n            // - 建立模型与集合之间的引用\n            // - 记录无效和重复的模型, 并在后面进行过滤\n            for( i = 0, length = models.length; i &lt; length; i++) {\n\n                // 当前模型的cid和id\n                cid = model.cid;\n                id = model.id;\n                // dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除\n                if(cids[cid] || this._byCid[cid] || ((id != null) &amp;&amp; (ids[id] || this._byId[id]))) {\n                    dups.push(i);\n                    continue;\n                }\n                cids[cid] = ids[id] = model;\n            }\n            // 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表\n            i = dups.length;\n            while(i--) {\n                models.splice(dups[i], 1);\n            }\n\n            // code ...\n\n            // 遍历新增加的模型列表\n            for( i = 0, length = this.models.length; i &lt; length; i++) {\n                if(!cids[( model = this.models[i]).cid])\n                    continue;\n                options.index = i;\n                // 触发模型的\"add\"事件, 因为集合监听了模型的\"all\"事件, 因此在_onModelEvent方法中, 集合也将触发\"add\"事件\n                // 详细信息可参考Collection.prototype._onModelEvent方法\n                model.trigger('add', model, this, options);\n            }\n            return this;\n        },\n        // 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件)\n        remove : function(models, options) {\n            var i, l, index, model;\n            options || ( options = {});\n            models = _.isArray(models) ? models.slice() : [models];\n            // 遍历需要移除的模型列表\n            for( i = 0, l = models.length; i &lt; l; i++) {\n                model = this.getByCid(models[i]) || this.get(models[i]);\n                if(!model)\n                    continue;\n                delete this._byId[model.id];\n                delete this._byCid[model.cid];\n                index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                // 如果没有设置silent属性, 则触发模型的remove事件\n                if(!options.silent) {\n                    options.index = index;\n                    model.trigger('remove', model, this, options);\n                }\n                this._removeReference(model);\n            }\n            return this;\n        },\n        push : function(model, options) {\n            model = this._prepareModel(model, options);\n            this.add(model, options);\n            return model;\n        },\n        // code ..\n    });\n</code></pre>\n\n<h2 id=\"routerhistory\">Router &amp; History</h2>\n\n<pre><code>    var Router = Backbone.Router = function(options) {\n        options || ( options = {});\n        if(options.routes)\n            this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n    _.extend(Router.prototype, Events, {\n        // 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件\n        route : function(route, name, callback) {\n            // 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化\n            Backbone.history || (Backbone.history = new History);\n            // code ...\n            Backbone.history.route(route, _.bind(function(fragment) {\n                var args = this._extractParameters(route, fragment);\n                // 调用callback路由监听事件, 并将参数传递给监听事件\n                callback &amp;&amp; callback.apply(this, args);\n\n                this.trigger.apply(this, ['route:' + name].concat(args));\n                // 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件\n                Backbone.history.trigger('route', this, name, args);\n\n            }, this));\n            return this;\n        },\n       // code ..\n    });\n\n    // History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问)\n    var History = Backbone.History = function() {\n        this.handlers = [];\n        // checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法\n        _.bindAll(this, 'checkUrl');\n    };\n\n    _.extend(History.prototype, Events, {\n        // 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化\n        // interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置)\n        interval : 50,\n        // 获取location中Hash字符串(锚点#后的片段)\n        getHash : function(windowOverride) {\n            // 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取\n            var loc = windowOverride ? windowOverride.location : window.location;\n            // 将锚点(#)后的字符串提取出来并返回\n            var match = loc.href.match(/#(.*)$/);\n            return match ? match[1] : '';\n        },\n        // 根据当前设置的路由方式, 处理并返回当前URL中的路由片段\n        getFragment : function(fragment, forcePushState) {\n            // fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288)\n            if(fragment == null) {\n                if(this._hasPushState || forcePushState) {\n                    // 使用了pushState方式进行路由\n                    fragment = window.location.pathname;\n                    // search记录当前页面后的参数内容\n                    var search = window.location.search;\n                    // 将路径和参数合并在一起, 作为待处理的路由片段\n                    if(search)\n                        fragment += search; \n                } else {\n                    // 使用了hash方式进行路由\n                    // 通过getHash方法获取当前锚点(#)后的字符串作为路由片段\n                    fragment = this.getHash();\n                }\n            }\n            if(!fragment.indexOf(this.options.root))\n                fragment = fragment.substr(this.options.root.length);\n            // 如果URL片段首字母为\"#\"或\"/\", 则去除该字符\n            return fragment.replace(routeStripper, '');\n        },\n        // 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数\n        start : function(options) {\n\n            // (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式)\n            this._wantsHashChange = this.options.hashChange !== false;\n            // _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器\n            // pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式\n            this._wantsPushState = !!this.options.pushState;\n\n            // _hasPushState属性记录浏览器是否支持pushState特性\n            this._hasPushState = !!(this.options.pushState &amp;&amp; window.history &amp;&amp; window.history.pushState);\n\n            var fragment = this.getFragment();\n            // documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式\n            var docMode = document.documentMode;\n            var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &amp;&amp; (!docMode || docMode &lt;= 7));\n\n            if(oldIE) {\n                // 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件\n                // 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由\n                this.iframe = $('&lt;iframe src=\"javascript:0\" tabindex=\"-1\" /&gt;').hide().appendTo('body')[0].contentWindow;\n                this.navigate(fragment);\n            }\n\n            // 开始监听路由状态变化\n            if(this._hasPushState) {\n                // 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法\n                $(window).bind('popstate', this.checkUrl);\n            } else if(this._wantsHashChange &amp;&amp; ('onhashchange' in window) &amp;&amp; !oldIE) {\n                // 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法\n                $(window).bind('hashchange', this.checkUrl);\n            } else if(this._wantsHashChange) {\n                // 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率\n                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            }\n            // code ..\n        },\n        // 停止history对路由的监控, 并将状态恢复为未监听状态\n        stop : function() {\n            // 解除对浏览器路由的onpopstate和onhashchange事件的监听\n            $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n            // 停止对于低版本的IE浏览器的心跳监控\n            clearInterval(this._checkUrlInterval);\n            // 恢复started状态, 便于下次重新调用start方法\n            History.started = false;\n        },\n        // 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用\n        checkUrl : function(e) {\n            // 获取当前的URL片段\n            var current = this.getFragment();\n            // 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量\n            if(current == this.fragment &amp;&amp; this.iframe)\n                current = this.getFragment(this.getHash(this.iframe));\n            // 如果当前URL与上一次的状态没有发生任何变化, 则停止执行\n            if(current == this.fragment)\n                return false;\n\n            // 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL\n            if(this.iframe)\n                this.navigate(current);\n            // 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法\n            this.loadUrl() || this.loadUrl(this.getHash());\n        },\n        // code ..\n    });\n</code></pre>\n\n<h2 id=\"view\">View</h2>\n\n<pre><code>    // Backbone.View 视图相关\n    var View = Backbone.View = function(options) {\n        // 为每一个视图对象创建一个唯一标识, 前缀为\"view\"\n        this.cid = _.uniqueId('view');\n        this._configure(options || {});\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents();\n    };\n\n    // viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身\n    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];\n    _.extend(View.prototype, Events, {\n        // 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签\n        tagName : 'div',\n        // code ..\n        // 移除当前视图的$el元素\n        remove : function() {\n            // 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据\n            this.$el.remove();\n            return this;\n        },\n        // 该方法用于在内部创建this.el时自动调用\n        make : function(tagName, attributes, content) {\n            var el = document.createElement(tagName);\n            if(attributes)\n                $(el).attr(attributes);\n            if(content)\n                $(el).html(content);\n            return el;\n        },\n        // 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用\n        setElement : function(element, delegate) {\n            // this.$el 存放Jquery或其他库的示例对象\n            this.$el = ( element instanceof $) ? element : $(element);\n            // this.el存放标准的DOM对象\n            this.el = this.$el[0];\n            // code ...\n            return this;\n        },\n        // 为视图元素绑定事件\n        // events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'):\n        // {\n        //     'click #title': 'edit',\n        //     'click .save': 'save'\n        //     'click span': function() {}\n        // }\n        // 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合)\n        delegateEvents : function(events) {\n            if(!(events || ( events = getValue(this, 'events'))))\n                return;\n            // 取消当前已经绑定过的events事件\n            this.undelegateEvents();\n            for(var key in events) {\n                // code ...                \n                // 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素\n                // 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中\n                var match = key.match(delegateEventSplitter);\n                // eventName为解析后的事件名称\n                // selector为解析后的事件元素选择器表达式\n                var eventName = match[1], selector = match[2];\n\n                method = _.bind(method, this);\n                // 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法\n                eventName += '.delegateEvents' + this.cid;\n                if(selector === '') {\n                    this.$el.bind(eventName, method);\n                } else {\n                    this.$el.delegate(selector, eventName, method);\n                }\n            }\n        },\n\n        // 在实例化视图对象时设置初始配置\n        // 将传递的配置覆盖到对象的options中\n        // 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性\n        _configure : function(options) {\n            // 如果对象本身设置了默认配置, 则使用传递的配置进行合并\n            if(this.options)\n                options = _.extend({}, this.options, options);\n            // 遍历viewOptions列表\n            for(var i = 0, l = viewOptions.length; i &lt; l; i++) {\n                // attr依次为viewOptions中的属性名\n                var attr = viewOptions[i];\n                // 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性\n                if(options[attr])\n                    this[attr] = options[attr];\n            }\n            this.options = options;\n        },\n        _ensureElement : function() {\n\n            if(!this.el) {\n                // 如果没有设置el属性, 则创建默认元素\n                var attrs = getValue(this, 'attributes') || {};\n                if(this.id)\n                    attrs.id = this.id;\n                if(this.className)\n                    attrs['class'] = this.className;\n                // 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素\n                this.setElement(this.make(this.tagName, attrs), false);\n            } else {\n                // 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素\n                this.setElement(this.el, false);\n            }\n        }\n    });\n</code></pre>\n\n<h2 id=\"backbonesync\">Backbone.sync</h2>\n\n<pre><code>var methodMap = {\n        'create' : 'POST',\n        'update' : 'PUT',\n        'delete' : 'DELETE',\n        'read' : 'GET'\n    };\n    // Async用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的连接\n    // sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持\n    // Model Collection save 或者fetch都用这个这个类。\n    Backbone.sync = function(method, model, options) {\n        // 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE)\n        var type = methodMap[method];\n\n        // params将作为请求参数对象传递给第三方库的$.ajax方法\n        var params = {\n            // 请求类型\n            type : type,\n            // 数据格式默认为json\n            dataType : 'json'\n        };\n\n        // 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url\n        if(!options.url) {\n            params.url = getValue(model, 'url') || urlError();\n        }\n\n        if(!options.data &amp;&amp; model &amp;&amp; (method == 'create' || method == 'update')) {\n            params.contentType = 'application/json';\n            params.data = JSON.stringify(model.toJSON());\n        }\n        if(Backbone.emulateHTTP) {\n            // 如果操作类型为PUT或DELETE\n            if(type === 'PUT' || type === 'DELETE') {\n                // 将操作名称存放到_method参数发送到服务器\n                if(Backbone.emulateJSON)\n                    params.data._method = type;\n                // 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息\n                params.type = 'POST';\n                params.beforeSend = function(xhr) {\n                    xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                };\n            }\n        }\n        // 通过第三方库的$.ajax方法向服务器发送请求同步数据状态\n        return $.ajax(_.extend(params, options));\n    };\n</code></pre>\n\n<h2 id=\"\">使用</h2>\n\n<pre><code>    var extend = function(protoProps, classProps) {\n        // child存储已经实现继承自当前类的子类(Function)\n        // protoProps设置子类原型链中的属性\n        // classProps设置子类的静态属性\n        var child = inherits(this, protoProps, classProps);\n        // 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承\n        child.extend = this.extend;\n        // 返回实现继承的子类\n        return child;\n    };\n    // 为Model, Collection, Router和View类实现继承机制 每次使用只需要 Backbone.View.extend({...});\n    Model.extend = Collection.extend = Router.extend = View.extend = extend;\n</code></pre>\n\n<h2 id=\"\">说明</h2>\n\n<p>本次分析基本上对翻译源码注释，中间省略了一些个人认为对理解代码实现和平时应用关系不大的代码。</p>","image":"/content/images/2016/07/backbone.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:26:34","created_by":1,"updated_at":"2016-07-08 00:47:17","updated_by":1,"published_at":"2014-01-28 00:26:00","published_by":1},{"id":61,"uuid":"d2ae0380-e750-4d4c-9c32-9fbce39e62e7","title":"基于Seajs的可控台球碰撞游戏","slug":"ji-yu-seajsde-ke-kong-tai-qiu-peng-zhuang-you-xi","markdown":"# 前言\n\n不记得哪个黑色星期五，贪吃鱼基本完工的时候，产品突然增加需求，要求金币扔出去后不消失，互相可碰撞，其最终结果还要由服务器控制(没错，至今做的所有游戏都有幕后黑手，=W=).\n\n对于碰撞以前只写过一个球到处碰墙壁的，小球之间的碰撞倒是没有接触，想到他们碰撞过程中的角度变化、速度分配，就不敢往下想了，于是马上想到box2d这个牛逼哄哄的引擎.\n\n但是，使用物理引擎虽然高效、逼真，但所有碰撞都是不可控，包括最终的落点。所以引擎不能解决这次遇到的需求。\n\n不能用引擎，咱自己写也不怕，反正当年物理和高数都学得还不错，嘻嘻、\n\n最后，趁游戏上线后的空闲时间，整理下碰撞的思路，记录成本文。\n\n如果你喜欢先睹为快，可以先去玩玩这个游戏:\n\n<a href=\"http://qubaoming.me/demo/CrashBall/index.html\" target=\"_blank\"> view demo >></a>\n\n\n\n# 游戏实现\n\n本文的核心代码是通过游戏中的逻辑移动过来，为了方便，所以代码组织也和cocos2d的思想类似。\n\ncocos2d中有Scene、director、layer层级之分，在demo中也有对应的init、game、ball，既然用到模块层级，当然首选seajs。\n\n#### 游戏架构\n        ├ css \n            ├ main.css\n        ├ js\n            ├ jquery   \n            ├ jquery.js\n            ├ seajs\n            ├ seajs.js\n            ├ ball\n            ├ game\n            ├ util\n            └ init\n        └ CrashBall.html\n\n`util`模块封装的是一些必要的工具函数\n\n`ball`模块封装小球move和drawPredict的类\n\n`game`模块控制游戏进度，管理小球的运动\n\n`init`模块是游戏入口，调用`game.js`的初始化和开始接口\n\n游戏难度集中在`ball`和`game`模块，所以只分析碰撞过程得碰撞检测和处理。\n\n\n\n####  复杂的碰撞\n\n&nbsp;&nbsp;&nbsp;&nbsp;首先建系很重要。由于我们模拟使用`left`和`top`来改变坐标，所以我们以`table`左上角为坐标原点，垂直向下为x轴正方向，水平向左为y轴正方向。\n\n__边缘碰撞处理__\n\n边缘碰撞处理较为常规，只需要检测小球坐标和边缘的相对关系即可：\n\n           // 左右墙壁\n           if (ball.x < util.R || ball.x > util.W - util.R) { \n                ball.angle *= -1; \n                ball.angle %= Math.PI; \n                ....\n                if (ball.x < util.R) {\n                   ball.x = util.R; \n                }\n                if (ball.x > util.W - util.R) {\n                   ball.x = util.W - util.R; \n                }\n            }\n\n            // 上下墙壁\n            if (ball.y < util.R || ball.y > util.H - util.R) { \n                ball.angle = ball.angle > 0 ? Math.PI - ball.angle: -Math.PI - ball.angle;                \n                ball.angle %= Math.PI;\n                ....\n            }  \n\n上述代码作用是，检测小球坐标和墙壁大小关系，修改小球运动的角度。\n\n计算角度的源码：\n    \n         angle = Math.atan2(toPos[0] - fromPos[0], toPos[1] - fromPos[1]);\n\n计算的是点(left, top)和x正方向的角度，即下图的∠DAC.\n\n\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\" alt=\"left\" width=\"264\" height=\"217\" class=\"alignnone size-full wp-image-282\" /></a>\n\n左右碰撞处理方案是乘以`-1`，∠DAC是入角，∠DAB和∠DAC正好差个`-1`.\n\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\" alt=\"top\" width=\"278\" height=\"240\" class=\"alignnone size-medium wp-image-283\" /></a>\n\n上下碰撞是分正负处理。如上图中∠EAC和∠EAB互补，如果反向运动，∠EAB和∠CAB的变化应该是反向再选择180°。\n\n最后注意的是，如果小球坐标超过边界坐标，则要它坐标设为边界坐标，不然就会出现靠着边界来回撞的bug，前人留下来的bug找了好久，= = .\n\n\n__小球碰撞处理__\n\na. 碰撞检测是判断他们的距离和2倍半径的关系：\n\n        var dis = Math.sqrt(Math.pow(disX, 2) + Math.pow(disY, 2)); \n        if (dis <= gap) {...}\n\n\n\nb. 如果速度太大或者重绘频率太小，怎会看到两个小球互相融入的效果，所以处理第一步是还原碰撞初始状态。\n\n        ball.x -= (gap - dis) * sin;\n        ball.y -= (gap - dis) * cos;\n\n上面代码是修正主动碰的小球的位置，让他退回刚好碰撞的位置，其实就是下图的AB之间的距离，相当于球o1从A退到B.\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\" alt=\"roll\" width=\"270\" height=\"233\" class=\"alignnone size-full wp-image-288\" /></a>\n\n\n\n\nc.  小球斜碰很难分析，我们把他们的速度旋转到x轴方向。\n\n        vx1 = vx * hitcos + vy * hitsin,\n        vy1 = vy * hitcos - vx * hitsin,\n\n上面的vx是原来速度v在x方向的速度，vy是v在y方向的速度。把原来的速度顺时针旋转两球圆心弦的角度，以后则不考虑y方向的运动。x方向上动量守恒和能量守恒，即\n\n        m * vx10 + m * vx20 = m * vx11 + m * vx21;\n        1/2 * m * vx10² + 1/2 * m * vx20² = 1/2 * m * vx11² + 1/2 * m * v21²\n\n联立求解可得碰撞后的速度大小。\n\n然后将速度旋转回去：\n    \n        vx = vx1 * hitcos - vy1 * hitsin;\n        vy = vy1 * hitcos + vx1 * hitsin;\n \n则碰撞后的速度和角度都可以得出：\n\n        ball.v = Math.sqrt(vx * vx + vy * vy) * (1 - 0); // (1-0) 变为大小，标量\n        obj.v = Math.sqrt(objVx * objVx + objVy * objVy) * (1 - 0);\n        ball.angle = Math.atan2(vx, vy);\n        obj.angle = Math.atan2(objVx, objVy);\n\n注意atan2(y, x)计算的是(x,y)到(0,0)的角度，我们这里使用(vx, vy),计算的是(vx, vy)到(0,0)角的余角。\n\n\n\n__考虑外力__\n\n        ball.v = ball.v * (1 - util.LOSS); // 碰撞边缘后减速\n\n故循环跳出条件是 `Math.round(v) <= 0`\n\n        if( Math.round(ball.v <= 0) {\n            ball.v = 0;\n            for(var i = 0; i < movingballs.length; i++) {\n                if(movingballs[i] == ball) {\n                    movingballs.remove(i);\n                }\n            }\n            window.clearInterval(_this.emmiter);\n        }\n         \n\n上式moveingballs.remove(i)移除数组指定位置的元素，是手动添加的：\n\n        Array.prototype.remove = function() { \n            ...\n        }\n\n\n\n\n__预测线__\n\n\n预测线的运动逻辑和小球一样，唯一不同的是，使用while而不是setInterval, 这样预测路线就会比我们的小球提前运动到指定位置。\n\n由于预测路线和小球运动路径相同，且比小球提前到达，那么就能提前知道小球的停止位置，如果判断到小球到达了不能到达的位置，则可以减小他的速度即可。\n\n\n预测路线的小黄点，是通过\n    \n        var elem = document.createElement(\"div\");\n        ....\n        wrap.append(elem);\n\n追加到DOM父节点上的，所以如果一次碰撞小球太多，则会卡死的现象。\n\n<br>\n在cocos2d中是使用在Layer上drawDot()，几乎没有内存消耗，所以不存在卡的现象。\n\n如果要应用到是项目中，建议使用canvas 或者 documentFragment处理。\n\n另外在贪吃鱼游戏中，运动的过程是通过加速度和路程来计算每次增加的位置的，运动效果比刚才的每次增加相同dx,dy的方案要好，如果对运动效果要求较高，可以考虑这种方式。\n\n\n\n## 结语\n\n实际需求中，很多情况下我们不能使用现成的引擎或者框架，必须要去自己造轮子。\n\n像刚才的碰撞处理中完全靠数学和物理知识，可见学好基本理论知识的重要性，就像作为程序员必需的数据结构和算法一样，总有你不知道的哪天就会用上，所以不断学习这些基础的东西，才能在用的时候随机应变。\n\n最后，源码放在github上： <a href=\"https://github.com/freestyle21/CrashBall\" target=\"_blank\">https://github.com/freestyle21/CrashBall</a>\n","mobiledoc":null,"html":"<h1 id=\"\">前言</h1>\n\n<p>不记得哪个黑色星期五，贪吃鱼基本完工的时候，产品突然增加需求，要求金币扔出去后不消失，互相可碰撞，其最终结果还要由服务器控制(没错，至今做的所有游戏都有幕后黑手，=W=).</p>\n\n<p>对于碰撞以前只写过一个球到处碰墙壁的，小球之间的碰撞倒是没有接触，想到他们碰撞过程中的角度变化、速度分配，就不敢往下想了，于是马上想到box2d这个牛逼哄哄的引擎.</p>\n\n<p>但是，使用物理引擎虽然高效、逼真，但所有碰撞都是不可控，包括最终的落点。所以引擎不能解决这次遇到的需求。</p>\n\n<p>不能用引擎，咱自己写也不怕，反正当年物理和高数都学得还不错，嘻嘻、</p>\n\n<p>最后，趁游戏上线后的空闲时间，整理下碰撞的思路，记录成本文。</p>\n\n<p>如果你喜欢先睹为快，可以先去玩玩这个游戏:</p>\n\n<p><a href=\"http://qubaoming.me/demo/CrashBall/index.html\" target=\"_blank\"> view demo >></a></p>\n\n<h1 id=\"\">游戏实现</h1>\n\n<p>本文的核心代码是通过游戏中的逻辑移动过来，为了方便，所以代码组织也和cocos2d的思想类似。</p>\n\n<p>cocos2d中有Scene、director、layer层级之分，在demo中也有对应的init、game、ball，既然用到模块层级，当然首选seajs。</p>\n\n<h4 id=\"\">游戏架构</h4>\n\n<pre><code>    ├ css \n        ├ main.css\n    ├ js\n        ├ jquery   \n        ├ jquery.js\n        ├ seajs\n        ├ seajs.js\n        ├ ball\n        ├ game\n        ├ util\n        └ init\n    └ CrashBall.html\n</code></pre>\n\n<p><code>util</code>模块封装的是一些必要的工具函数</p>\n\n<p><code>ball</code>模块封装小球move和drawPredict的类</p>\n\n<p><code>game</code>模块控制游戏进度，管理小球的运动</p>\n\n<p><code>init</code>模块是游戏入口，调用<code>game.js</code>的初始化和开始接口</p>\n\n<p>游戏难度集中在<code>ball</code>和<code>game</code>模块，所以只分析碰撞过程得碰撞检测和处理。</p>\n\n<h4 id=\"\">复杂的碰撞</h4>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;首先建系很重要。由于我们模拟使用<code>left</code>和<code>top</code>来改变坐标，所以我们以<code>table</code>左上角为坐标原点，垂直向下为x轴正方向，水平向左为y轴正方向。</p>\n\n<p><strong>边缘碰撞处理</strong></p>\n\n<p>边缘碰撞处理较为常规，只需要检测小球坐标和边缘的相对关系即可：</p>\n\n<pre><code>       // 左右墙壁\n       if (ball.x &lt; util.R || ball.x &gt; util.W - util.R) { \n            ball.angle *= -1; \n            ball.angle %= Math.PI; \n            ....\n            if (ball.x &lt; util.R) {\n               ball.x = util.R; \n            }\n            if (ball.x &gt; util.W - util.R) {\n               ball.x = util.W - util.R; \n            }\n        }\n\n        // 上下墙壁\n        if (ball.y &lt; util.R || ball.y &gt; util.H - util.R) { \n            ball.angle = ball.angle &gt; 0 ? Math.PI - ball.angle: -Math.PI - ball.angle;                \n            ball.angle %= Math.PI;\n            ....\n        }  \n</code></pre>\n\n<p>上述代码作用是，检测小球坐标和墙壁大小关系，修改小球运动的角度。</p>\n\n<p>计算角度的源码：</p>\n\n<pre><code>     angle = Math.atan2(toPos[0] - fromPos[0], toPos[1] - fromPos[1]);\n</code></pre>\n\n<p>计算的是点(left, top)和x正方向的角度，即下图的∠DAC.</p>\n\n<p><a href=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\" alt=\"left\" width=\"264\" height=\"217\" class=\"alignnone size-full wp-image-282\" /></a></p>\n\n<p>左右碰撞处理方案是乘以<code>-1</code>，∠DAC是入角，∠DAB和∠DAC正好差个<code>-1</code>.</p>\n\n<p><a href=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\" alt=\"top\" width=\"278\" height=\"240\" class=\"alignnone size-medium wp-image-283\" /></a></p>\n\n<p>上下碰撞是分正负处理。如上图中∠EAC和∠EAB互补，如果反向运动，∠EAB和∠CAB的变化应该是反向再选择180°。</p>\n\n<p>最后注意的是，如果小球坐标超过边界坐标，则要它坐标设为边界坐标，不然就会出现靠着边界来回撞的bug，前人留下来的bug找了好久，= = .</p>\n\n<p><strong>小球碰撞处理</strong></p>\n\n<p>a. 碰撞检测是判断他们的距离和2倍半径的关系：</p>\n\n<pre><code>    var dis = Math.sqrt(Math.pow(disX, 2) + Math.pow(disY, 2)); \n    if (dis &lt;= gap) {...}\n</code></pre>\n\n<p>b. 如果速度太大或者重绘频率太小，怎会看到两个小球互相融入的效果，所以处理第一步是还原碰撞初始状态。</p>\n\n<pre><code>    ball.x -= (gap - dis) * sin;\n    ball.y -= (gap - dis) * cos;\n</code></pre>\n\n<p>上面代码是修正主动碰的小球的位置，让他退回刚好碰撞的位置，其实就是下图的AB之间的距离，相当于球o1从A退到B.\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\" alt=\"roll\" width=\"270\" height=\"233\" class=\"alignnone size-full wp-image-288\" /></a></p>\n\n<p>c.  小球斜碰很难分析，我们把他们的速度旋转到x轴方向。</p>\n\n<pre><code>    vx1 = vx * hitcos + vy * hitsin,\n    vy1 = vy * hitcos - vx * hitsin,\n</code></pre>\n\n<p>上面的vx是原来速度v在x方向的速度，vy是v在y方向的速度。把原来的速度顺时针旋转两球圆心弦的角度，以后则不考虑y方向的运动。x方向上动量守恒和能量守恒，即</p>\n\n<pre><code>    m * vx10 + m * vx20 = m * vx11 + m * vx21;\n    1/2 * m * vx10² + 1/2 * m * vx20² = 1/2 * m * vx11² + 1/2 * m * v21²\n</code></pre>\n\n<p>联立求解可得碰撞后的速度大小。</p>\n\n<p>然后将速度旋转回去：</p>\n\n<pre><code>    vx = vx1 * hitcos - vy1 * hitsin;\n    vy = vy1 * hitcos + vx1 * hitsin;\n</code></pre>\n\n<p>则碰撞后的速度和角度都可以得出：</p>\n\n<pre><code>    ball.v = Math.sqrt(vx * vx + vy * vy) * (1 - 0); // (1-0) 变为大小，标量\n    obj.v = Math.sqrt(objVx * objVx + objVy * objVy) * (1 - 0);\n    ball.angle = Math.atan2(vx, vy);\n    obj.angle = Math.atan2(objVx, objVy);\n</code></pre>\n\n<p>注意atan2(y, x)计算的是(x,y)到(0,0)的角度，我们这里使用(vx, vy),计算的是(vx, vy)到(0,0)角的余角。</p>\n\n<p><strong>考虑外力</strong></p>\n\n<pre><code>    ball.v = ball.v * (1 - util.LOSS); // 碰撞边缘后减速\n</code></pre>\n\n<p>故循环跳出条件是 <code>Math.round(v) &lt;= 0</code></p>\n\n<pre><code>    if( Math.round(ball.v &lt;= 0) {\n        ball.v = 0;\n        for(var i = 0; i &lt; movingballs.length; i++) {\n            if(movingballs[i] == ball) {\n                movingballs.remove(i);\n            }\n        }\n        window.clearInterval(_this.emmiter);\n    }\n</code></pre>\n\n<p>上式moveingballs.remove(i)移除数组指定位置的元素，是手动添加的：</p>\n\n<pre><code>    Array.prototype.remove = function() { \n        ...\n    }\n</code></pre>\n\n<p><strong>预测线</strong></p>\n\n<p>预测线的运动逻辑和小球一样，唯一不同的是，使用while而不是setInterval, 这样预测路线就会比我们的小球提前运动到指定位置。</p>\n\n<p>由于预测路线和小球运动路径相同，且比小球提前到达，那么就能提前知道小球的停止位置，如果判断到小球到达了不能到达的位置，则可以减小他的速度即可。</p>\n\n<p>预测路线的小黄点，是通过</p>\n\n<pre><code>    var elem = document.createElement(\"div\");\n    ....\n    wrap.append(elem);\n</code></pre>\n\n<p>追加到DOM父节点上的，所以如果一次碰撞小球太多，则会卡死的现象。</p>\n\n<p><br> <br />\n在cocos2d中是使用在Layer上drawDot()，几乎没有内存消耗，所以不存在卡的现象。</p>\n\n<p>如果要应用到是项目中，建议使用canvas 或者 documentFragment处理。</p>\n\n<p>另外在贪吃鱼游戏中，运动的过程是通过加速度和路程来计算每次增加的位置的，运动效果比刚才的每次增加相同dx,dy的方案要好，如果对运动效果要求较高，可以考虑这种方式。</p>\n\n<h2 id=\"\">结语</h2>\n\n<p>实际需求中，很多情况下我们不能使用现成的引擎或者框架，必须要去自己造轮子。</p>\n\n<p>像刚才的碰撞处理中完全靠数学和物理知识，可见学好基本理论知识的重要性，就像作为程序员必需的数据结构和算法一样，总有你不知道的哪天就会用上，所以不断学习这些基础的东西，才能在用的时候随机应变。</p>\n\n<p>最后，源码放在github上： <a href=\"https://github.com/freestyle21/CrashBall\" target=\"_blank\">https://github.com/freestyle21/CrashBall</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:47:41","created_by":1,"updated_at":"2016-07-12 13:27:51","updated_by":1,"published_at":"2013-07-10 03:44:00","published_by":1},{"id":62,"uuid":"66d36866-439d-43f1-9f38-f3fe3895fe4d","title":"蜕变·WebRebuild 2013 前端年度交流会成都站邀请","slug":"webrebuild-2013","markdown":"![](/content/images/2016/07/aaa--1-.jpg)\n\n互联网web前端设计行业通过一段时期的茧封或焰炼，web技术使行业、企业及自身发生质的改变。痛苦的蜕变是成长的契机，在彼此互相冲击、交流、融合的对话下，将以尊重包容互助合作同步发展的心态，对行业蜕变、自我提升的过程分享自己的观点进行探讨。\n\n2013，本届主题为“蜕变”的前端技术年度交流会已是第七届，依然如往年在深圳、广州、上海、北京、成都五地举行，腾讯ecd联合 WebRebuild.ORG、深圳大学文化产业研究院、迅雷CUED主办了第七届前端年度交流会. “蜕变” 成都站，将于11月17日下午一点半在翼起来咖啡馆举行。\n\n### 交流会形式\n\nweb前端设计主题分享、现场来宾主题交流对话探讨。\n\n### 会议进行时间\n\n2013-11-17 (星期日) 13:30-18:00\n\n### 会议地点\n\n武侯区高新区天府大道765号天府软件园A11楼（翼起来创业咖啡馆）\n\n### 邀请参会对象\n\n互联网web前端/设计从业者及相关专业、兴趣的学生。\n\n### 报名渠道\n\nWebRebuild.ORG官方网站，或添加微信公众帐号(webrebuildorg)进行相关操作。\n\n### 交流会背景\n\nWebRebuild.ORG 成立于2007年，由互联网前端业界人员自发起的一个交流会组织，从深圳扩散至全国，旨在推动互联网前端web标准技术在中国的发展，致力于为同行从业者 提供一个分享交流的平台，提升从业者的影响力及技术能力储备，并向发展成为推动中国互联网前端web标准技术的非盈利性组织的目标而努力。\n\n从2007年至今，WebRebuild.ORG得到了W3C中国、Google中国、腾讯、迅雷、网易、欢聚时代、百家筝鸣古筝教育集团等企业组织、同行及会议组委志愿者的大力支持与帮助，已成为中国前端盛大的行业盛会之一。\n\n广州、上海、北京、成都地区更多详细信息及参会报名请访问WebRebuild官方网站查阅：[http://www.webrebuild.org](http://www.webrebuild.org) 或收听WebRebuild微信公众帐号（webrebuildorg）获取最新信息。\n\n\nPS：此次 [WebRebuild 成都站](http://www.webrebuild.org/2013/cd/agenda.html)，[@fs21](http://qubaoming.me) 会做一个分享，欢迎成都的前端朋友~\n\n分享ppt [下载](http://vdisk.weibo.com/s/BJjK1OuvdXeqA)","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/07/aaa--1-.jpg\" alt=\"\" /></p>\n\n<p>互联网web前端设计行业通过一段时期的茧封或焰炼，web技术使行业、企业及自身发生质的改变。痛苦的蜕变是成长的契机，在彼此互相冲击、交流、融合的对话下，将以尊重包容互助合作同步发展的心态，对行业蜕变、自我提升的过程分享自己的观点进行探讨。</p>\n\n<p>2013，本届主题为“蜕变”的前端技术年度交流会已是第七届，依然如往年在深圳、广州、上海、北京、成都五地举行，腾讯ecd联合 WebRebuild.ORG、深圳大学文化产业研究院、迅雷CUED主办了第七届前端年度交流会. “蜕变” 成都站，将于11月17日下午一点半在翼起来咖啡馆举行。</p>\n\n<h3 id=\"\">交流会形式</h3>\n\n<p>web前端设计主题分享、现场来宾主题交流对话探讨。</p>\n\n<h3 id=\"\">会议进行时间</h3>\n\n<p>2013-11-17 (星期日) 13:30-18:00</p>\n\n<h3 id=\"\">会议地点</h3>\n\n<p>武侯区高新区天府大道765号天府软件园A11楼（翼起来创业咖啡馆）</p>\n\n<h3 id=\"\">邀请参会对象</h3>\n\n<p>互联网web前端/设计从业者及相关专业、兴趣的学生。</p>\n\n<h3 id=\"\">报名渠道</h3>\n\n<p>WebRebuild.ORG官方网站，或添加微信公众帐号(webrebuildorg)进行相关操作。</p>\n\n<h3 id=\"\">交流会背景</h3>\n\n<p>WebRebuild.ORG 成立于2007年，由互联网前端业界人员自发起的一个交流会组织，从深圳扩散至全国，旨在推动互联网前端web标准技术在中国的发展，致力于为同行从业者 提供一个分享交流的平台，提升从业者的影响力及技术能力储备，并向发展成为推动中国互联网前端web标准技术的非盈利性组织的目标而努力。</p>\n\n<p>从2007年至今，WebRebuild.ORG得到了W3C中国、Google中国、腾讯、迅雷、网易、欢聚时代、百家筝鸣古筝教育集团等企业组织、同行及会议组委志愿者的大力支持与帮助，已成为中国前端盛大的行业盛会之一。</p>\n\n<p>广州、上海、北京、成都地区更多详细信息及参会报名请访问WebRebuild官方网站查阅：<a href=\"http://www.webrebuild.org\">http://www.webrebuild.org</a> 或收听WebRebuild微信公众帐号（webrebuildorg）获取最新信息。</p>\n\n<p>PS：此次 <a href=\"http://www.webrebuild.org/2013/cd/agenda.html\">WebRebuild 成都站</a>，<a href=\"http://qubaoming.me\">@fs21</a> 会做一个分享，欢迎成都的前端朋友~</p>\n\n<p>分享ppt <a href=\"http://vdisk.weibo.com/s/BJjK1OuvdXeqA\">下载</a></p>","image":"/content/images/2016/07/aaa--1--1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 06:59:47","created_by":1,"updated_at":"2016-07-09 07:05:31","updated_by":1,"published_at":"2013-11-01 06:59:00","published_by":1},{"id":63,"uuid":"a425623a-d8e4-4502-8056-b7ed5de080df","title":"cocos2d-html5 中的性能优化","slug":"cocos2d-html5-performance-optimization","markdown":"游戏开发中，难免会遇到性能瓶颈。图片一多，渲染批次就会直线上升，任何动画都会变得闪动。\n\nOpenGL ES优化的问题，主要考虑两个方面：**内存存储**和**运行速度**。\n\n2D游戏中的最占内存的就是图片资源，一张图片使用的纹理格式不同，就可能带来极大的性能差异。图片数量的控制好坏，对一个游戏的流程与否有最直接的关系。在前端开发中，常见的减少HTTP请求的方式有css Sprite 来处理图片数量的问题，在cocos2d中也有类似的处理方式。（这里打个广告，操哥的[grunt-sprite](https://npmjs.org/package/grunt-sprite)）.\n\n关于内存，cocos2d中采用预加载的方式来处理。把所有同类图片打包成plist文件，然后通过帧缓存的方式读取。打包软件推荐 [TexturePacker](http://www.codeandweb.com/texturepacker).这里注意打包后的的图片空隙不要太多，Size constraints设置为Any size，改变layout Algorithm找到最合适图片。如下图：\n\n![](/content/images/2016/07/QQ---a---20131024093817-300x229.png)\n\n\npublish后会得到plist文件和png文件。其中plist文件记录了打包前的图片的名字和在生成png文件中的位置。在项目的入口文件中引入刚才的plist文件，就可以在任何Layer和Sprite里面提取这些预加载过的图片了。举个栗子：\n    \n\n    cc.MenuItemImage.createWithFrames(\"setA.png\", \"setB.png\",null,this.click_set, this);\n\n    cc.Sprite.createWithSpriteFrameName('deskBg.png');\n\n关于运行速度，纹理渲染每一次都会调用GLDrawArray，要是上千图片，结果不难想象。要降低渲染批次，我们使用SpriteBatchNode的方式。\n   \n\nSpriteBatchNode的作用管理Sprite。我们知道，每当屏幕渲染一个纹理的时候，需要三个过程：准备渲染、渲染图形、清除渲染。如果每一次都重复这三个过程，这些固定开销就会降低我们的渲染效率。SpriteBatchNode的作用就是把很多次这样的过程变成一次。\n\n\n例如最近的一次项目。需要把旋转指针、旋转云图、内环背景等添加到一个Layer中。这是可以考虑先给Layer创建SpriteBatchNode，然后把上面的物体放到刚创建的SpriteBatchNode中。\n\n\n\n    this.spriteBatch = cc.SpriteBatchNode.create(\"res/pan.png\");\n    this.pan.addChild(this.spriteBatch ,200);\n\n    // 转盘 内环\n    var ring = cc.Sprite.createWithSpriteFrameName(Pan_Arr.l1.ring);\n    this.spriteBatch.addChild(ring);\n\n\n\n使用了后，对应的渲染批次就会降低N-1次。N是SpriteBatchNode管理的Sprite的数量。\n\n\n\n关于SpriteBatchNode有两点注意：\n\n*   使用贴图必须是同一张图片，例如可以使用TexturePacker打包publish出来的图片。\n*   所有被管理的Sprite必须在同一渲染层。也就是说呗AddChild的时候的zOrder必须是一样的。\n\n\n\n以上就是最近研究的cocos2d-html5性能优化实践，主要就是FrameCache和SpriteBatchNode两种预加载。\n\n\n\n  \n   ","mobiledoc":null,"html":"<p>游戏开发中，难免会遇到性能瓶颈。图片一多，渲染批次就会直线上升，任何动画都会变得闪动。</p>\n\n<p>OpenGL ES优化的问题，主要考虑两个方面：<strong>内存存储</strong>和<strong>运行速度</strong>。</p>\n\n<p>2D游戏中的最占内存的就是图片资源，一张图片使用的纹理格式不同，就可能带来极大的性能差异。图片数量的控制好坏，对一个游戏的流程与否有最直接的关系。在前端开发中，常见的减少HTTP请求的方式有css Sprite 来处理图片数量的问题，在cocos2d中也有类似的处理方式。（这里打个广告，操哥的<a href=\"https://npmjs.org/package/grunt-sprite\">grunt-sprite</a>）.</p>\n\n<p>关于内存，cocos2d中采用预加载的方式来处理。把所有同类图片打包成plist文件，然后通过帧缓存的方式读取。打包软件推荐 <a href=\"http://www.codeandweb.com/texturepacker\">TexturePacker</a>.这里注意打包后的的图片空隙不要太多，Size constraints设置为Any size，改变layout Algorithm找到最合适图片。如下图：</p>\n\n<p><img src=\"/content/images/2016/07/QQ---a---20131024093817-300x229.png\" alt=\"\" /></p>\n\n<p>publish后会得到plist文件和png文件。其中plist文件记录了打包前的图片的名字和在生成png文件中的位置。在项目的入口文件中引入刚才的plist文件，就可以在任何Layer和Sprite里面提取这些预加载过的图片了。举个栗子：</p>\n\n<pre><code>cc.MenuItemImage.createWithFrames(\"setA.png\", \"setB.png\",null,this.click_set, this);\n\ncc.Sprite.createWithSpriteFrameName('deskBg.png');\n</code></pre>\n\n<p>关于运行速度，纹理渲染每一次都会调用GLDrawArray，要是上千图片，结果不难想象。要降低渲染批次，我们使用SpriteBatchNode的方式。</p>\n\n<p>SpriteBatchNode的作用管理Sprite。我们知道，每当屏幕渲染一个纹理的时候，需要三个过程：准备渲染、渲染图形、清除渲染。如果每一次都重复这三个过程，这些固定开销就会降低我们的渲染效率。SpriteBatchNode的作用就是把很多次这样的过程变成一次。</p>\n\n<p>例如最近的一次项目。需要把旋转指针、旋转云图、内环背景等添加到一个Layer中。这是可以考虑先给Layer创建SpriteBatchNode，然后把上面的物体放到刚创建的SpriteBatchNode中。</p>\n\n<pre><code>this.spriteBatch = cc.SpriteBatchNode.create(\"res/pan.png\");\nthis.pan.addChild(this.spriteBatch ,200);\n\n// 转盘 内环\nvar ring = cc.Sprite.createWithSpriteFrameName(Pan_Arr.l1.ring);\nthis.spriteBatch.addChild(ring);\n</code></pre>\n\n<p>使用了后，对应的渲染批次就会降低N-1次。N是SpriteBatchNode管理的Sprite的数量。</p>\n\n<p>关于SpriteBatchNode有两点注意：</p>\n\n<ul>\n<li>使用贴图必须是同一张图片，例如可以使用TexturePacker打包publish出来的图片。</li>\n<li>所有被管理的Sprite必须在同一渲染层。也就是说呗AddChild的时候的zOrder必须是一样的。</li>\n</ul>\n\n<p>以上就是最近研究的cocos2d-html5性能优化实践，主要就是FrameCache和SpriteBatchNode两种预加载。</p>","image":"/content/images/2016/07/2051584439.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:05:59","created_by":1,"updated_at":"2016-07-09 07:12:30","updated_by":1,"published_at":"2013-10-24 07:05:00","published_by":1},{"id":64,"uuid":"f9e178b0-3b96-4261-bf98-f92f1b1a9f28","title":"细说移动前端Android联调","slug":"mobile-debug","markdown":"#### 为什么要联调\nA：正在疯狂coding的时候，产品MM过来，焦急的说两周前的一个页面在手机上显示略微错位，但小本上显示正常！\n\nB：本着爱折腾的原则，作为大前端，在移动互联网时代的基本技能。\n#### 联调的方式：\n1：ADB Chrome extension\n\n2：Opera Mobile\n\n3：weinre\n\n4: [Adobe Egde Inspect CC](http://html.adobe.com/edge/inspect/)\n\n\n#### 方式一：ADB Chrome extension：具体参考：[这里](https://developers.google.com/chrome-developer-tools/docs/remote-debugging?hl=zh-CN&csw=1)\n\n步骤一：[ADB extension](https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage)\n\n步骤二：安装手机驱动\n\n步骤三：手机chrome 开发者工具->启动USB网页调试\n\n步骤四：ADB->View Inspection Targets\n\n细节：手机驱动如果不好找就装个91或者豌豆荚吧\n\n优缺点：配置简单，可快速开始。但ADB会闹脾气，时快时慢\t\n\n优化：解决慢可以尝试用android的sdk本地搞个服务器。\n\n基本配置->下载[ADT](http://developer.android.com/sdk/index.html)->CMD(adb forward tcp:8888 localadstract:chrome_devtools_remote)->localhost:8888\n\n#### 方式二：Opera Mobile\n\n步骤一：下载Opera桌面版(低版本)\n       下载Opera 模拟器\n\n步骤二：打开桌面版的Dragonfly 点击右上角的远程调试设置端口\n\n步骤三：在模拟器中输入 opera:debug 设置端口连接。\n\n细节：Opera桌面版高版本的调试器居然不是dragongly，下低版本(10.52)。\n\n优缺点：简单方便，支持模拟各种机型的显示效果。但是不能选择元素方式不友好。\n\n#### 方式三：weinre(web in remote)\n步骤一：安装Node.js. => 安装weinre(npm install -g weinre)\n\n步骤二：启动服务器 weinre --httpPort 8080 --boundHost -all-\n\n步骤三：在目标调试文件中加入： \n\n     <script src=\"http://本机ip:8080/target/target-script-min.js#anonymous\"></script>\n\n步骤四：[localhost:8080/client](localhost:8080/client) 即可调试\n\n细节：引入的script标签中必须有#anonymous,否则看不到可调试文件。\n\n优缺点：高端上流，操作简单，可用浏览器自带的调试器调试，适合爱好不同开发者。\n\n缺点是，方便前端开发。\n\n优化：每次都手动引入js很不爽，效率极低。做成书签形式，每次在当前页面引入js。\n\n    javascript:(function(e){\n        e.setAttribute(\"src\",\"http://192.168.1.5:8080/target/target-script-min.js#anonymous\");\n        document.getElementsByTagName(\"body\")[0].appendChild(e);\n        alert('has executed!');\n    })(document.createElement(\"script\"));\n    void(0);\n\n#### 结语：\n移动端调试虽好玩，但是太折腾，保证效率，只能作为最后法宝\n\n遇到问题：Bug现象->本地调试->定位bug->确定是否联调\n\n\t\n","mobiledoc":null,"html":"<h4 id=\"\">为什么要联调</h4>\n\n<p>A：正在疯狂coding的时候，产品MM过来，焦急的说两周前的一个页面在手机上显示略微错位，但小本上显示正常！</p>\n\n<p>B：本着爱折腾的原则，作为大前端，在移动互联网时代的基本技能。  </p>\n\n<h4 id=\"\">联调的方式：</h4>\n\n<p>1：ADB Chrome extension</p>\n\n<p>2：Opera Mobile</p>\n\n<p>3：weinre</p>\n\n<p>4: <a href=\"http://html.adobe.com/edge/inspect/\">Adobe Egde Inspect CC</a></p>\n\n<h4 id=\"adbchromeextensionhttpsdevelopersgooglecomchromedevelopertoolsdocsremotedebugginghlzhcncsw1\">方式一：ADB Chrome extension：具体参考：<a href=\"https://developers.google.com/chrome-developer-tools/docs/remote-debugging?hl=zh-CN&amp;csw=1\">这里</a></h4>\n\n<p>步骤一：<a href=\"https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage\">ADB extension</a></p>\n\n<p>步骤二：安装手机驱动</p>\n\n<p>步骤三：手机chrome 开发者工具->启动USB网页调试</p>\n\n<p>步骤四：ADB->View Inspection Targets</p>\n\n<p>细节：手机驱动如果不好找就装个91或者豌豆荚吧</p>\n\n<p>优缺点：配置简单，可快速开始。但ADB会闹脾气，时快时慢    </p>\n\n<p>优化：解决慢可以尝试用android的sdk本地搞个服务器。</p>\n\n<p>基本配置->下载<a href=\"http://developer.android.com/sdk/index.html\">ADT</a>->CMD(adb forward tcp:8888 localadstract:chrome<em>devtools</em>remote)->localhost:8888</p>\n\n<h4 id=\"operamobile\">方式二：Opera Mobile</h4>\n\n<p>步骤一：下载Opera桌面版(低版本)\n       下载Opera 模拟器</p>\n\n<p>步骤二：打开桌面版的Dragonfly 点击右上角的远程调试设置端口</p>\n\n<p>步骤三：在模拟器中输入 opera:debug 设置端口连接。</p>\n\n<p>细节：Opera桌面版高版本的调试器居然不是dragongly，下低版本(10.52)。</p>\n\n<p>优缺点：简单方便，支持模拟各种机型的显示效果。但是不能选择元素方式不友好。</p>\n\n<h4 id=\"weinrewebinremote\">方式三：weinre(web in remote)</h4>\n\n<p>步骤一：安装Node.js. => 安装weinre(npm install -g weinre)</p>\n\n<p>步骤二：启动服务器 weinre --httpPort 8080 --boundHost -all-</p>\n\n<p>步骤三：在目标调试文件中加入： </p>\n\n<pre><code> &lt;script src=\"http://本机ip:8080/target/target-script-min.js#anonymous\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>步骤四：<a href=\"localhost:8080/client\">localhost:8080/client</a> 即可调试</p>\n\n<p>细节：引入的script标签中必须有#anonymous,否则看不到可调试文件。</p>\n\n<p>优缺点：高端上流，操作简单，可用浏览器自带的调试器调试，适合爱好不同开发者。</p>\n\n<p>缺点是，方便前端开发。</p>\n\n<p>优化：每次都手动引入js很不爽，效率极低。做成书签形式，每次在当前页面引入js。</p>\n\n<pre><code>javascript:(function(e){\n    e.setAttribute(\"src\",\"http://192.168.1.5:8080/target/target-script-min.js#anonymous\");\n    document.getElementsByTagName(\"body\")[0].appendChild(e);\n    alert('has executed!');\n})(document.createElement(\"script\"));\nvoid(0);\n</code></pre>\n\n<h4 id=\"\">结语：</h4>\n\n<p>移动端调试虽好玩，但是太折腾，保证效率，只能作为最后法宝</p>\n\n<p>遇到问题：Bug现象->本地调试->定位bug->确定是否联调</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:13:03","created_by":1,"updated_at":"2016-07-09 07:21:54","updated_by":1,"published_at":"2013-09-08 07:13:00","published_by":1},{"id":65,"uuid":"b722e4ac-fa7e-4237-84fe-d1cb9d2f4b48","title":"grunt-2x2x","slug":"grunt-2x2x","markdown":"> a grunt plugin to resize and rename @2x.png(jpg,gif,) image to .png(jpg,gif)\n\n场景：移动前端开发中，设计给的psd都是双倍图，适用于高清屏。对于低端手机，需要用@x的图片。平时工作中，用「App设计助理」+「Photoshop切图脚本工具PNG@2x Export」可以秒出@2x图层的@2x图片，之后再用grunt-2x2x便可将@2x转到@x，实现流程自动化。\n\n详见： [https://npmjs.org/package/grunt-2x2x](https://npmjs.org/package/grunt-2x2x)","mobiledoc":null,"html":"<blockquote>\n  <p>a grunt plugin to resize and rename @2x.png(jpg,gif,) image to .png(jpg,gif)</p>\n</blockquote>\n\n<p>场景：移动前端开发中，设计给的psd都是双倍图，适用于高清屏。对于低端手机，需要用@x的图片。平时工作中，用「App设计助理」+「Photoshop切图脚本工具PNG@2x Export」可以秒出@2x图层的@2x图片，之后再用grunt-2x2x便可将@2x转到@x，实现流程自动化。</p>\n\n<p>详见： <a href=\"https://npmjs.org/package/grunt-2x2x\">https://npmjs.org/package/grunt-2x2x</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:23:48","created_by":1,"updated_at":"2016-07-09 07:24:40","updated_by":1,"published_at":"2013-06-17 07:23:00","published_by":1},{"id":66,"uuid":"3602e45e-2a7e-4128-b83a-b26a3dda32a3","title":"居中","slug":"css-align-center","markdown":"说到居中，好像每个前端人都能随口说出几个，像耳熟能详的`margin:0 auto`、`line-heght`之类的。但是，当天天面对各式各样的设计稿时，或许你知道的那几个法宝也不能应对了。\n\n本文就日常重构中遇到的一些情景给出对应的解决方案，并对每种解决方案的优缺点进行简要概括。\n\n* * *\n\n## 垂直居中\n\n### -webkit-box- 居中\n\n      <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\theight: 300px;\n\t\t\twidth: 300px;\n\t\t\tdisplay: -webkit-box;\n\t\t\t-webkit-box-align: center; // 水平居中\n\t\t\t-webkit-box-pack: center; // 垂直居中\n\t\t\t-webkit-box-orient: vertical;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t    <span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t</div>\n\n评价：适用于多行文本，缺点是只有-webkit内核浏览器支持，移动端可以多使用。\n\n### height | line-height 等值居中\n\n    <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\theight: 90px;\n\t\t\tline-height: 90px;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t</div>    \n\n评价：使用于单行文本(图片也可以)，缺点是要求父元素高度已知。\n\n### padding 居中\n\n    <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\tpadding: 25px;\n\t\t\twidth: 560px;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t</div>    \n\n评价：只是看起来居中，其实是用padding撑满父元素而已，=。=。\n\n### table-cell 居中\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tdisplay: table-cell;\n\t\t\tvertical-align: middle;\n\t\t}\n\t\t.wraper {\n\t\t\tdisplay: table;\n\t\t\theight: 80px;\n\t\t\tbackground: #DBE6FD;\n\t\t}\n\t</style> \n\t<div class=\"wraper\">\n\t\t<div class=\"inner\">\n\t\t\t我是文本我居中\n\t\t\t我是文本我居中\n\t\t</div>\n\t</div>    \n\n评价：等于移动端用的较多，很适用。不过要注意的是他可能会破坏布局，要用display破坏原来的block属性。\n\n### absolute 居中\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tposition: absolute;\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tmargin: auto;\n\t\t\twidth: 300px;\n\t\t\theight: 100px;\n\t\t}\n\t\t.wraper {\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t</style> \n\t<div class=\"wraper\">\n\t\t<div class=\"inner\">\n\t\t\t我是文本我居中\n\t\t\t我是文本我居中\n\t\t</div>\n\t</div>    \n\n评价：要求父元素高度宽度都固定。\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tposition: absolute;\n\t\t\theight: 100px;\n\t\t\ttop: 50%;\n\t\t\tmargin-top: -50px: \n\t\t}\n\t\t.wraper {\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t</style> \n\n\t<div class=\"wraper\">\n\t    <div class=\"inner\">\n\t        \t我是文本我居中\n\t\t        我是文本我居中\n\t    </div>\n\t</div>    \n\n评价：要求需要居中的元素高度已知。\n\n### 对于span，img等行内元素，使用vertical-align: middle。\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\theight: 100px;\n\t\t}\n\t\timg {\n\t\t\tvertical-align: middle;\n\t\t}\n\t</style>\n\t<p>\n\t\t<img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\">\n\t\t我是图片后的文字，我要居中\n\t</p>\n\n### 图片和文本要图片居中，可以使用`<img src=\"\" align=\"absmiddle\" />`\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n\t<p>\n\t\t<img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\">\n\t\t我是图片后的文字，我要居中\n\t</p> \n\n* * *\n\n## 水平居中\n\n### text-align 居中\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n\t<p>\n\t\t<span>我要水平居中！</span>\n\t</p>    \n\n评价： 限于文本和图片等内联元素。\n\n### `margin: 0 auto;` 居中\n\n    <style>\n\t\t.outer {\n\t\t\tbackground: #DBE6FD;\n\t\t}\n\t\t.inner {\n\t\t\tbackground: #F3F3F3;\n\t\t\twidth: 80%;\n\t\t\tmargin: 0 auto;\n\t\t}\n\t</style>\n\t<div class=\"outer\">\n\t\t<div class=\"inner\">\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t</div>\n\t</div>    \n\n评价：只对于块级元素有效。\n\n### `absolute`\n\n    <style>\n\t\t.outer {\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t\t.inner {\n\t\t\tbackground: #F3F3F3;\n\t\t\tposition: relative;\n\t\t\tleft: 50%;\n\t\t\twidth: 400px;\n\t\t\tmargin-left: -200px;\n\t\t}\n\t</style>\n\t<div class=\"outer\">\n\t\t<div class=\"inner\">\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t</div>\n\t</div>  \n\n评价：只对宽度已知的元素有效。\n### 总结：以上每种方法都有自己的优点和缺点，对于特定场景，选用适合此场景的方法即可。\n## 补充\n\nbox-flex：布局的垂直等高、水平均分、按比例划分。\n\n    <style>\n\t\t.wraper {\n\t\t\tdisplay: box;\n\t\t}\n\t\t.sectionOne {\n\t\t\tbox-flex: 3;\n\t\t}\n\t\t.sectionTwo {\n\t\t\tbox-flex: 2;\n\t\t}\n\t\t.sectionThree {\n\t\t\tbox-flex: 1;\n\t\t}\n\t</style>\n\t<article class=\"wrap\">\n\t\t<section class=\"sectionOne\">01</section>\n\t\t<section class=\"sectionTwo\">02</section>\n\t\t<section class=\"sectionThree\">03</section>\n\t</article>\n\t    \n#### 说明：\n\n1.    父元素必须为display:box（此时容器定义为内联元素，使用margin：0 auto无效，要在父元素上使用text-aglin:center.）\n\n2.    如果其中一个子元素设置了固定宽度，该子元素直接应用设置的宽度，其他的在按比例平分剩下的。\n\n    \n\n#### box属性：\n\nbox-orient box-direction(排列顺序，reverse|normal)\n\nbox-align（父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch）\n\nbox-pack(子容器的水平对齐方式 start | end | center | justify)","mobiledoc":null,"html":"<p>说到居中，好像每个前端人都能随口说出几个，像耳熟能详的<code>margin:0 auto</code>、<code>line-heght</code>之类的。但是，当天天面对各式各样的设计稿时，或许你知道的那几个法宝也不能应对了。</p>\n\n<p>本文就日常重构中遇到的一些情景给出对应的解决方案，并对每种解决方案的优缺点进行简要概括。</p>\n\n<hr />\n\n<h2 id=\"\">垂直居中</h2>\n\n<h3 id=\"webkitbox\">-webkit-box- 居中</h3>\n\n<pre><code>  &lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        height: 300px;\n        width: 300px;\n        display: -webkit-box;\n        -webkit-box-align: center; // 水平居中\n        -webkit-box-pack: center; // 垂直居中\n        -webkit-box-orient: vertical;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>评价：适用于多行文本，缺点是只有-webkit内核浏览器支持，移动端可以多使用。</p>\n\n<h3 id=\"heightlineheight\">height | line-height 等值居中</h3>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        height: 90px;\n        line-height: 90px;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：使用于单行文本(图片也可以)，缺点是要求父元素高度已知。</p>\n\n<h3 id=\"padding\">padding 居中</h3>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        padding: 25px;\n        width: 560px;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    我是文本我居中\n    我是文本我居中\n    我是文本我居中\n    我是文本我居中\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：只是看起来居中，其实是用padding撑满父元素而已，=。=。</p>\n\n<h3 id=\"tablecell\">table-cell 居中</h3>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .wraper {\n        display: table;\n        height: 80px;\n        background: #DBE6FD;\n    }\n&lt;/style&gt; \n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n        我是文本我居中\n        我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：等于移动端用的较多，很适用。不过要注意的是他可能会破坏布局，要用display破坏原来的block属性。</p>\n\n<h3 id=\"absolute\">absolute 居中</h3>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        position: absolute;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        margin: auto;\n        width: 300px;\n        height: 100px;\n    }\n    .wraper {\n        width: 400px;\n        height: 400px;\n        background: #DBE6FD;\n        position: relative;\n    }\n&lt;/style&gt; \n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n        我是文本我居中\n        我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：要求父元素高度宽度都固定。</p>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        position: absolute;\n        height: 100px;\n        top: 50%;\n        margin-top: -50px: \n    }\n    .wraper {\n        width: 400px;\n        height: 400px;\n        background: #DBE6FD;\n        position: relative;\n    }\n&lt;/style&gt; \n\n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n            我是文本我居中\n            我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：要求需要居中的元素高度已知。</p>\n\n<h3 id=\"spanimgverticalalignmiddle\">对于span，img等行内元素，使用vertical-align: middle。</h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        height: 100px;\n    }\n    img {\n        vertical-align: middle;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\"&gt;\n    我是图片后的文字，我要居中\n&lt;/p&gt;\n</code></pre>\n\n<h3 id=\"imgsrcalignabsmiddle\">图片和文本要图片居中，可以使用<code>&lt;img src=\"\" align=\"absmiddle\" /&gt;</code></h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        text-align: center;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\"&gt;\n    我是图片后的文字，我要居中\n&lt;/p&gt; \n</code></pre>\n\n<hr />\n\n<h2 id=\"\">水平居中</h2>\n\n<h3 id=\"textalign\">text-align 居中</h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        text-align: center;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;span&gt;我要水平居中！&lt;/span&gt;\n&lt;/p&gt;    \n</code></pre>\n\n<p>评价： 限于文本和图片等内联元素。</p>\n\n<h3 id=\"margin0auto\"><code>margin: 0 auto;</code> 居中</h3>\n\n<pre><code>&lt;style&gt;\n    .outer {\n        background: #DBE6FD;\n    }\n    .inner {\n        background: #F3F3F3;\n        width: 80%;\n        margin: 0 auto;\n    }\n&lt;/style&gt;\n&lt;div class=\"outer\"&gt;\n    &lt;div class=\"inner\"&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：只对于块级元素有效。</p>\n\n<h3 id=\"absolute\"><code>absolute</code></h3>\n\n<pre><code>&lt;style&gt;\n    .outer {\n        background: #DBE6FD;\n        position: relative;\n    }\n    .inner {\n        background: #F3F3F3;\n        position: relative;\n        left: 50%;\n        width: 400px;\n        margin-left: -200px;\n    }\n&lt;/style&gt;\n&lt;div class=\"outer\"&gt;\n    &lt;div class=\"inner\"&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;  \n</code></pre>\n\n<p>评价：只对宽度已知的元素有效。</p>\n\n<h3 id=\"\">总结：以上每种方法都有自己的优点和缺点，对于特定场景，选用适合此场景的方法即可。</h3>\n\n<h2 id=\"\">补充</h2>\n\n<p>box-flex：布局的垂直等高、水平均分、按比例划分。</p>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        display: box;\n    }\n    .sectionOne {\n        box-flex: 3;\n    }\n    .sectionTwo {\n        box-flex: 2;\n    }\n    .sectionThree {\n        box-flex: 1;\n    }\n&lt;/style&gt;\n&lt;article class=\"wrap\"&gt;\n    &lt;section class=\"sectionOne\"&gt;01&lt;/section&gt;\n    &lt;section class=\"sectionTwo\"&gt;02&lt;/section&gt;\n    &lt;section class=\"sectionThree\"&gt;03&lt;/section&gt;\n&lt;/article&gt;\n</code></pre>\n\n<h4 id=\"\">说明：</h4>\n\n<ol>\n<li><p>   父元素必须为display:box（此时容器定义为内联元素，使用margin：0 auto无效，要在父元素上使用text-aglin:center.）</p></li>\n<li><p>   如果其中一个子元素设置了固定宽度，该子元素直接应用设置的宽度，其他的在按比例平分剩下的。</p></li>\n</ol>\n\n<h4 id=\"box\">box属性：</h4>\n\n<p>box-orient box-direction(排列顺序，reverse|normal)</p>\n\n<p>box-align（父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch）</p>\n\n<p>box-pack(子容器的水平对齐方式 start | end | center | justify)</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:38:39","created_by":1,"updated_at":"2016-07-09 08:01:30","updated_by":1,"published_at":"2013-06-08 07:38:00","published_by":1},{"id":67,"uuid":"7ed10fcd-73ce-4086-84b3-828d449118d2","title":"实习之始","slug":"shi-xi-zhi-shi","markdown":"今天终于有时间安静下来，看看书，听听音乐，写写文字。\n\n来深圳三天了，还是没有放下对一个陌生城市的防备。曾经想着来这个世界，就是为了改变它，但游离在这座城市的高楼大厦间，突然觉得自己是多么的渺小，无助。入职培训的两天里，都没有很人有较多接触，独来独往。外面看来是高贵冷艳，其实是害怕、没准备。有时候都在思考，自己到底是属于静如处子还是动如狡兔，或者一半一半。\n\n深圳给人的印象太深了。首先是喜怒无常的天气，有时候可以是左边阳光灿烂，右边却乌云密布，有时早上红火太阳，下午就滚滚雷声。另外还有，本地人说话很好听。每次在地铁里都很认真的听广播，无聊的时候还故意找别人说话，其实是为了听听广东话。有时候都在想要好好学两句，回去好骗骗小马和颖姐。其他的还有吃饭贵、交通好，高楼多、腿好看（*@ο@*）……\n\n腾讯确实给力，做什么都有大公司的霸气。实习生直接住三星级酒店，短短15天，但住了真心不想走。工作的环境跟想象中一样，气氛很好，椅子很舒服，两个大屏幕超给力，这里的人初次接触就很nice。入职培训的时候，跳跳虎从最后逆袭到了10颗星，最感动地是鲜姐居然记住了我的生日，专门去买了礼物，当时真的有点受宠若惊。不知道是不是腾讯的传统。\n\n写着写着，又想远了。本来的满肚子的话，不知接下来如何开始。\n\n计划的，每天锻炼呢？来了深圳就没有锻炼过。反思，以后每天至少做点俯卧撑，没事去公司的健身房走走！\n\n最近一直在听周围的人说租房难，所以不敢马虎。早上在豆瓣和58上泡了一上午，下午去看了房，没有什么不满意的，就交了押金。懒得讲价和到处找。后面没有麻烦了，全身心投入工作吧。虽然干的可能是给峰哥猫哥搓背倒水的体力活，但也要以不为自己打工的精神干好，从小事做起。另外保证效率，必须获得认可。明天陪恺睿和高富帅去high一天，后天开始fight吧！","mobiledoc":null,"html":"<p>今天终于有时间安静下来，看看书，听听音乐，写写文字。</p>\n\n<p>来深圳三天了，还是没有放下对一个陌生城市的防备。曾经想着来这个世界，就是为了改变它，但游离在这座城市的高楼大厦间，突然觉得自己是多么的渺小，无助。入职培训的两天里，都没有很人有较多接触，独来独往。外面看来是高贵冷艳，其实是害怕、没准备。有时候都在思考，自己到底是属于静如处子还是动如狡兔，或者一半一半。</p>\n\n<p>深圳给人的印象太深了。首先是喜怒无常的天气，有时候可以是左边阳光灿烂，右边却乌云密布，有时早上红火太阳，下午就滚滚雷声。另外还有，本地人说话很好听。每次在地铁里都很认真的听广播，无聊的时候还故意找别人说话，其实是为了听听广东话。有时候都在想要好好学两句，回去好骗骗小马和颖姐。其他的还有吃饭贵、交通好，高楼多、腿好看（<em>@ο@</em>）……</p>\n\n<p>腾讯确实给力，做什么都有大公司的霸气。实习生直接住三星级酒店，短短15天，但住了真心不想走。工作的环境跟想象中一样，气氛很好，椅子很舒服，两个大屏幕超给力，这里的人初次接触就很nice。入职培训的时候，跳跳虎从最后逆袭到了10颗星，最感动地是鲜姐居然记住了我的生日，专门去买了礼物，当时真的有点受宠若惊。不知道是不是腾讯的传统。</p>\n\n<p>写着写着，又想远了。本来的满肚子的话，不知接下来如何开始。</p>\n\n<p>计划的，每天锻炼呢？来了深圳就没有锻炼过。反思，以后每天至少做点俯卧撑，没事去公司的健身房走走！</p>\n\n<p>最近一直在听周围的人说租房难，所以不敢马虎。早上在豆瓣和58上泡了一上午，下午去看了房，没有什么不满意的，就交了押金。懒得讲价和到处找。后面没有麻烦了，全身心投入工作吧。虽然干的可能是给峰哥猫哥搓背倒水的体力活，但也要以不为自己打工的精神干好，从小事做起。另外保证效率，必须获得认可。明天陪恺睿和高富帅去high一天，后天开始fight吧！</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:02:26","created_by":1,"updated_at":"2016-07-09 08:03:17","updated_by":1,"published_at":"2013-06-20 08:02:00","published_by":1},{"id":68,"uuid":"50fdebd1-8b6c-4cb2-9f9e-a4dfe94f38e3","title":"Canvas动画","slug":"canvas-animation","markdown":"## 引题\n\n最近忙完实验，在慢慢开始的学习HTML5 的canvas，很早就听过动态canvas的威名，一直没有机会和时间学习。这次系统学习HTML5和css3，自然不会放过这次机会。\n\n本文主要是总结学习canvas动画的一些基本知识，并不会介绍canvas，关于入门读者朋友可以回去翻翻书本。另外本文还会试着写几个实例，加深理解。\n\n## canvas动画基本思想\n\n### 思想一 刷新重绘\n\n我们平时看到的canvas游戏里，人物运动、物体变化都是基于这个思想。比如绘制动画的圆，我们通过鼠标触动或者重力等外界因素改变圆的圆心坐标。下一步，通过：\n\n    context.clearRect(0, 0, canvas.width, canvas.height)\n\n把当前canvas的画面清空。然后，再通过：\n    \n    context.art(circle.x, circle.y, circle.radius, 0, Math.PI*2) \n\n利用新的圆心坐标绘制新的圆。\n\n刷新重绘的思想是canvas游戏的核心，任何需要移动的物体都是通过这种方式。\n\n不过在即时战略游戏中，很多东西不需要更新，需要的只是人物，这样我们全部清楚再重绘就有点得不偿失。这里就需要用到一种区域适配更新的技术，是John Carmack发明的，叫做ATR技术。有兴趣的朋友可以去google一下。\n\n### 思想二 碰撞检测\n\n碰撞检测用的比较比较频繁。比如和canvas上的圆交互的时候，需要检测点击的是哪个圆，只需循环判断触点坐标到圆心的距离与半径的关系即可。再比如迷宫游戏里面，移动人物的时候需要判断前方是否是墙壁，是墙壁的话就不能移动。这个碰撞检测的方法不太常见，是通过像素检测的方式。如果前方的像素是我们预定的墙壁的颜色，就不能移动了。\n\n### 一些需要知道的东西\n\n动画对于重绘速度有要求，通常每秒30次以上才不会导致出现间断的现象。由于绘制速度很快，可能你会觉得我们的画布会反应迟钝。但是，由于很多现代浏览器都使用了**硬件加速**等性能增强技术，把图像处理工作转移给显卡，从而节省了CPU。由此引申出一个css hack技术。开启硬件加速，css如下：\n\n    transform: translateZ(0);\n    transform: translate3d(0, 0, 0);\n\n圆圈绘图程序每次刷新画布，都会先使用clearRect清除所有，再绘制所有(比上次多). 这样不会出现闪烁，因为Canvas针对这个问题进行了优化，它实际上会在绘图逻辑执行完成后才清除或绘制所有内容。\n\n## canvas动画实例\n\n### 实例一 自由落体交互的小球\n\n要不断的移动小球，正如上面所说，就需要不断重绘canvas\n\n    setTimeOut(\"drawFrame()\", 20)\n\n接下来看看drawFrame函数：\n    \n    function drawFrame() {\n      //清空\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      context.beginPath();\n      //balls是一个存放我们小球的数组。\n      for(var i=0; i&lt;balls.length; i++) {\n        var ball = balls[i];\n        ball.x += ball.dx;\n        ball.y += ball.dy;\n        // 添加重力效果\n        if ((ball.y) &lt; canvas.height) ball.dy += 0.22;\n        // 添加摩擦力效果\n        ball.dx = ball.dx * 0.998;\n        // 碰到墙反弹\n        if ((ball.x + ball.radius &gt; canvas.width) || (ball.x - ball.radius &lt; 0)) {\n          ball.dx = -ball.dx;\n        }\n        // 碰到地反弹注意0.96哦！\n        if ((ball.y + ball.radius &gt; canvas.height) || (ball.y - ball.radius &lt; 0)) { \n          ball.dy = -ball.dy*0.96; \n        }\n        context.fillStyle = \"white\";\n        // Draw 开始绘制球\n        context.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);\n        context.lineWidth = 1;\n        context.fill();\n        context.stroke(); \n      }\n      setTimeout(\"drawFrame()\", 20);\n    }\n\n\n`drawFrame`函数是动画的核心，处理外力对小球的影响。考虑了重力摩擦力等。然后不断调整小球的坐标，刷新重绘。\n\n下面是我们处理鼠标交互的函数：\n\n    function canvasClick(e) {\n      // 触点位置\n      var clickX = e.pageX - canvas.offsetLeft;\n      var clickY = e.pageY - canvas.offsetTop;\n      // 边界检测，看点击哪个球。\n      for(var i in balls)\n      {\n        var ball = balls[i];\n        if ((clickX &gt; (ball.x-ball.radius)) &amp;&amp; (clickX &lt; (ball.x+ball.radius)))\n        {\n          if ((clickY &gt; (ball.y-ball.radius)) &amp;&amp; (clickY &lt; (ball.y+ball.radius)))\n          {\n            // 改变小球的速度。\n            ball.dx -= 2;\n            ball.dy -= 3;\n            return;\n          }\n        }\n      }\n    }\n\n最后是增加小球和清空画布：\n\n\n    function addBall() {\n      var radius = parseFloat(document.getElementById(\"ballSize\").value);\n      var ball = new Ball(50,50,1,1,radius);\n      balls.push(ball);\n    }\n    function clearBalls() {\n      // 清空数组，下次重绘的就是空得了。\n      balls = [];\n    }\n\n最终结果：\n\n![](/content/images/2016/07/eI--A--A--cI--A--A--eI--A--A--aI--A--A--aI--A--A--cI--A--A---958x198.png)\n\n### 实例二 散落的粒子\n\n这次，写一个无数粒子构成的名字，鼠标接触马上散落各处的例子。\n\n无数粒子是用canvas画的圆，不过半径我写成了1px。这里就不展示了。\n\n下面看核心函数，处理小球运动的轨迹：\n\n    function updateBalls(canvas, balls, timeDiff, mousePos) {\n       var context = canvas.getContext('2d');\n      \tvar collisionDamper = 0.3;//碰撞减缓\n      \tvar floorFriction = 0.0005 * timeDiff;//摩擦力\n      \tvar mouseForceMultiplier = 1 * timeDiff;//Multiplier 乘数\n      \tvar restoreForce = 0.002 * timeDiff;\n        //和上个例子一样，循环小球数组，改变每个小球的圆心坐标。\n      \tfor(var n = 0; n &lt; balls.length; n++) {\n            var ball = balls[n];\n            // 改变圆心坐标\n      \t    ball.y += ball.vy;\n            ball.x += ball.vx;\n            // 恢复力，最后要静止。\n      \t    if(ball.x &gt; ball.origX) {\n      \t\t      ball.vx -= restoreForce;\n            } else {\n      \t\t      ball.vx += restoreForce;\n            }\n            if(ball.y &gt; ball.origY) {\n      \t\t      ball.vy -= restoreForce;\n            } else {\n      \t\t      ball.vy += restoreForce;\n            }\n            // 鼠标给的力\n            var mouseX = mousePos.x;\n      \t    var mouseY = mousePos.y;\n      \t    var distX = ball.x - mouseX;//判断左右的。\n      \t    var distY = ball.y - mouseY;\n            var radius = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));\n            var totalDist = Math.abs(distX) + Math.abs(distY);\n            var forceX = (Math.abs(distX) / totalDist) * (1 / radius) *   mouseForceMultiplier;\n      \t    var forceY = (Math.abs(distY) / totalDist) * (1 / radius) * mouseForceMultiplier;\n      \t    if(distX &gt; 0) {\n          \t\t // 如果从左边触动小球\n          \t\t ball.vx += forceX;\n            } else {\n      \t\t     ball.vx -= forceX;\n            }\n            if(distY &gt; 0) {\n          \t\t // 从上方触动小球\n          \t\t ball.vy += forceY;\n            } else {\n      \t\t     ball.vy -= forceY;\n            }\n            // 考虑地板摩擦力\n            if(ball.vx &gt; 0) {\n      \t\t      ball.vx -= floorFriction;\n            } else if(ball.vx &lt; 0) {\n      \t\t      ball.vx += floorFriction; \n            }\n      \t    if(ball.vy &gt; 0) {\n      \t\t      ball.vy -= floorFriction;\n            } else if(ball.vy &lt; 0) {\n      \t\t      ball.vy += floorFriction;\n      \t    }\n      \t    // 碰到地板反弹\n            if(ball.y &gt; (canvas.height - ball.radius)) {\n        \t\t   ball.y = canvas.height - ball.radius - 2;\n        \t\t   ball.vy *= -1;\n        \t\t   ball.vy *= (1 - collisionDamper);\n            }\n            // 碰到上顶反弹\n      \t    if(ball.y &lt; (ball.radius)) {\n        \t\t   ball.y = ball.radius + 2;\n        \t\t   ball.vy *= -1;\n        \t\t   ball.vy *= (1 - collisionDamper);\n            }\n            // 碰到右边反弹\n            if(ball.x &gt; (canvas.width - ball.radius)) {\n        \t\t   ball.x = canvas.width - ball.radius - 2;\n        \t\t   ball.vx *= -1;\n        \t\t   ball.vx *= (1 - collisionDamper);\n           }\n            // 碰到左边反弹\n            if(ball.x &lt; (ball.radius)) {\n        \t\t   ball.x = ball.radius + 2;\n        \t\t   ball.vx *= -1;\n        \t\t   ball.vx *= (1 - collisionDamper);\n            }\n        }\n   }\n   \n\n就像注释的一样，考虑了反弹、地板摩擦力、鼠标力、恢复力等。通过这个函数改变小球的位置。\n\n剩下其他几个不太重要的函数就不写了，主要是循环小球数组重绘，寻找鼠标触点位置等，和第一个差不多。\n\n效果（本来想写freestyle的，太多了，懒得去复制后面的。）：\n\n![](/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198.png)\n","mobiledoc":null,"html":"<h2 id=\"\">引题</h2>\n\n<p>最近忙完实验，在慢慢开始的学习HTML5 的canvas，很早就听过动态canvas的威名，一直没有机会和时间学习。这次系统学习HTML5和css3，自然不会放过这次机会。</p>\n\n<p>本文主要是总结学习canvas动画的一些基本知识，并不会介绍canvas，关于入门读者朋友可以回去翻翻书本。另外本文还会试着写几个实例，加深理解。</p>\n\n<h2 id=\"canvas\">canvas动画基本思想</h2>\n\n<h3 id=\"\">思想一 刷新重绘</h3>\n\n<p>我们平时看到的canvas游戏里，人物运动、物体变化都是基于这个思想。比如绘制动画的圆，我们通过鼠标触动或者重力等外界因素改变圆的圆心坐标。下一步，通过：</p>\n\n<pre><code>context.clearRect(0, 0, canvas.width, canvas.height)\n</code></pre>\n\n<p>把当前canvas的画面清空。然后，再通过：</p>\n\n<pre><code>context.art(circle.x, circle.y, circle.radius, 0, Math.PI*2) \n</code></pre>\n\n<p>利用新的圆心坐标绘制新的圆。</p>\n\n<p>刷新重绘的思想是canvas游戏的核心，任何需要移动的物体都是通过这种方式。</p>\n\n<p>不过在即时战略游戏中，很多东西不需要更新，需要的只是人物，这样我们全部清楚再重绘就有点得不偿失。这里就需要用到一种区域适配更新的技术，是John Carmack发明的，叫做ATR技术。有兴趣的朋友可以去google一下。</p>\n\n<h3 id=\"\">思想二 碰撞检测</h3>\n\n<p>碰撞检测用的比较比较频繁。比如和canvas上的圆交互的时候，需要检测点击的是哪个圆，只需循环判断触点坐标到圆心的距离与半径的关系即可。再比如迷宫游戏里面，移动人物的时候需要判断前方是否是墙壁，是墙壁的话就不能移动。这个碰撞检测的方法不太常见，是通过像素检测的方式。如果前方的像素是我们预定的墙壁的颜色，就不能移动了。</p>\n\n<h3 id=\"\">一些需要知道的东西</h3>\n\n<p>动画对于重绘速度有要求，通常每秒30次以上才不会导致出现间断的现象。由于绘制速度很快，可能你会觉得我们的画布会反应迟钝。但是，由于很多现代浏览器都使用了<strong>硬件加速</strong>等性能增强技术，把图像处理工作转移给显卡，从而节省了CPU。由此引申出一个css hack技术。开启硬件加速，css如下：</p>\n\n<pre><code>transform: translateZ(0);\ntransform: translate3d(0, 0, 0);\n</code></pre>\n\n<p>圆圈绘图程序每次刷新画布，都会先使用clearRect清除所有，再绘制所有(比上次多). 这样不会出现闪烁，因为Canvas针对这个问题进行了优化，它实际上会在绘图逻辑执行完成后才清除或绘制所有内容。</p>\n\n<h2 id=\"canvas\">canvas动画实例</h2>\n\n<h3 id=\"\">实例一 自由落体交互的小球</h3>\n\n<p>要不断的移动小球，正如上面所说，就需要不断重绘canvas</p>\n\n<pre><code>setTimeOut(\"drawFrame()\", 20)\n</code></pre>\n\n<p>接下来看看drawFrame函数：</p>\n\n<pre><code>function drawFrame() {\n  //清空\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.beginPath();\n  //balls是一个存放我们小球的数组。\n  for(var i=0; i&amp;lt;balls.length; i++) {\n    var ball = balls[i];\n    ball.x += ball.dx;\n    ball.y += ball.dy;\n    // 添加重力效果\n    if ((ball.y) &amp;lt; canvas.height) ball.dy += 0.22;\n    // 添加摩擦力效果\n    ball.dx = ball.dx * 0.998;\n    // 碰到墙反弹\n    if ((ball.x + ball.radius &amp;gt; canvas.width) || (ball.x - ball.radius &amp;lt; 0)) {\n      ball.dx = -ball.dx;\n    }\n    // 碰到地反弹注意0.96哦！\n    if ((ball.y + ball.radius &amp;gt; canvas.height) || (ball.y - ball.radius &amp;lt; 0)) { \n      ball.dy = -ball.dy*0.96; \n    }\n    context.fillStyle = \"white\";\n    // Draw 开始绘制球\n    context.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);\n    context.lineWidth = 1;\n    context.fill();\n    context.stroke(); \n  }\n  setTimeout(\"drawFrame()\", 20);\n}\n</code></pre>\n\n<p><code>drawFrame</code>函数是动画的核心，处理外力对小球的影响。考虑了重力摩擦力等。然后不断调整小球的坐标，刷新重绘。</p>\n\n<p>下面是我们处理鼠标交互的函数：</p>\n\n<pre><code>function canvasClick(e) {\n  // 触点位置\n  var clickX = e.pageX - canvas.offsetLeft;\n  var clickY = e.pageY - canvas.offsetTop;\n  // 边界检测，看点击哪个球。\n  for(var i in balls)\n  {\n    var ball = balls[i];\n    if ((clickX &amp;gt; (ball.x-ball.radius)) &amp;amp;&amp;amp; (clickX &amp;lt; (ball.x+ball.radius)))\n    {\n      if ((clickY &amp;gt; (ball.y-ball.radius)) &amp;amp;&amp;amp; (clickY &amp;lt; (ball.y+ball.radius)))\n      {\n        // 改变小球的速度。\n        ball.dx -= 2;\n        ball.dy -= 3;\n        return;\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>最后是增加小球和清空画布：</p>\n\n<pre><code>function addBall() {\n  var radius = parseFloat(document.getElementById(\"ballSize\").value);\n  var ball = new Ball(50,50,1,1,radius);\n  balls.push(ball);\n}\nfunction clearBalls() {\n  // 清空数组，下次重绘的就是空得了。\n  balls = [];\n}\n</code></pre>\n\n<p>最终结果：</p>\n\n<p><img src=\"/content/images/2016/07/eI--A--A--cI--A--A--eI--A--A--aI--A--A--aI--A--A--cI--A--A---958x198.png\" alt=\"\" /></p>\n\n<h3 id=\"\">实例二 散落的粒子</h3>\n\n<p>这次，写一个无数粒子构成的名字，鼠标接触马上散落各处的例子。</p>\n\n<p>无数粒子是用canvas画的圆，不过半径我写成了1px。这里就不展示了。</p>\n\n<p>下面看核心函数，处理小球运动的轨迹：</p>\n\n<pre><code>function updateBalls(canvas, balls, timeDiff, mousePos) {\n   var context = canvas.getContext('2d');\n      var collisionDamper = 0.3;//碰撞减缓\n      var floorFriction = 0.0005 * timeDiff;//摩擦力\n      var mouseForceMultiplier = 1 * timeDiff;//Multiplier 乘数\n      var restoreForce = 0.002 * timeDiff;\n    //和上个例子一样，循环小球数组，改变每个小球的圆心坐标。\n      for(var n = 0; n &amp;lt; balls.length; n++) {\n        var ball = balls[n];\n        // 改变圆心坐标\n          ball.y += ball.vy;\n        ball.x += ball.vx;\n        // 恢复力，最后要静止。\n          if(ball.x &amp;gt; ball.origX) {\n                ball.vx -= restoreForce;\n        } else {\n                ball.vx += restoreForce;\n        }\n        if(ball.y &amp;gt; ball.origY) {\n                ball.vy -= restoreForce;\n        } else {\n                ball.vy += restoreForce;\n        }\n        // 鼠标给的力\n        var mouseX = mousePos.x;\n          var mouseY = mousePos.y;\n          var distX = ball.x - mouseX;//判断左右的。\n          var distY = ball.y - mouseY;\n        var radius = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));\n        var totalDist = Math.abs(distX) + Math.abs(distY);\n        var forceX = (Math.abs(distX) / totalDist) * (1 / radius) *   mouseForceMultiplier;\n          var forceY = (Math.abs(distY) / totalDist) * (1 / radius) * mouseForceMultiplier;\n          if(distX &amp;gt; 0) {\n               // 如果从左边触动小球\n               ball.vx += forceX;\n        } else {\n               ball.vx -= forceX;\n        }\n        if(distY &amp;gt; 0) {\n               // 从上方触动小球\n               ball.vy += forceY;\n        } else {\n               ball.vy -= forceY;\n        }\n        // 考虑地板摩擦力\n        if(ball.vx &amp;gt; 0) {\n                ball.vx -= floorFriction;\n        } else if(ball.vx &amp;lt; 0) {\n                ball.vx += floorFriction; \n        }\n          if(ball.vy &amp;gt; 0) {\n                ball.vy -= floorFriction;\n        } else if(ball.vy &amp;lt; 0) {\n                ball.vy += floorFriction;\n          }\n          // 碰到地板反弹\n        if(ball.y &amp;gt; (canvas.height - ball.radius)) {\n               ball.y = canvas.height - ball.radius - 2;\n               ball.vy *= -1;\n               ball.vy *= (1 - collisionDamper);\n        }\n        // 碰到上顶反弹\n          if(ball.y &amp;lt; (ball.radius)) {\n               ball.y = ball.radius + 2;\n               ball.vy *= -1;\n               ball.vy *= (1 - collisionDamper);\n        }\n        // 碰到右边反弹\n        if(ball.x &amp;gt; (canvas.width - ball.radius)) {\n               ball.x = canvas.width - ball.radius - 2;\n               ball.vx *= -1;\n               ball.vx *= (1 - collisionDamper);\n       }\n        // 碰到左边反弹\n        if(ball.x &amp;lt; (ball.radius)) {\n               ball.x = ball.radius + 2;\n               ball.vx *= -1;\n               ball.vx *= (1 - collisionDamper);\n        }\n    }\n</code></pre>\n\n<p>}</p>\n\n<p>就像注释的一样，考虑了反弹、地板摩擦力、鼠标力、恢复力等。通过这个函数改变小球的位置。</p>\n\n<p>剩下其他几个不太重要的函数就不写了，主要是循环小球数组重绘，寻找鼠标触点位置等，和第一个差不多。</p>\n\n<p>效果（本来想写freestyle的，太多了，懒得去复制后面的。）：</p>\n\n<p><img src=\"/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198.png\" alt=\"\" /></p>","image":"/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198-1.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:03:40","created_by":1,"updated_at":"2016-07-09 08:13:14","updated_by":1,"published_at":"2013-06-22 08:09:00","published_by":1},{"id":69,"uuid":"50ea9671-d57e-4f59-82e9-3eb8aa982bcc","title":"关于文件上传的几种方式","slug":"file-upload-theme","markdown":"##### 上传之前 JavaScript 检测\n1：javascript判断上传文件的大小：\n\n在FireFox、Chrome浏览器中可以根据`document.getElementById(\"id_of_file\").size` 获取上传文件的大小（字节数），而IE浏览器中不支持该属性，只能借助`<img>`标签的`dynsrc`属性，来间接实现获取文件的大小（但需要同意ActiveX控件的运行）。\n\n\tvar ua = window.navigator.userAgent;\n\tif (ua.indexOf(\"MSIE\")>=1){\n\t    browserCfg.ie = true;\n\t}else if(ua.indexOf(\"Firefox\")>=1){\n\t    browserCfg.firefox = true;\n\t}else if(ua.indexOf(\"Chrome\")>=1){\n\t    browserCfg.chrome = true;\n\t}</pre><p>&nbsp;</p>\n\n\tif(browserCfg.firefox || browserCfg.chrome ){\n\t    filesize = obj_file.files[0].size;\n\t}else if(browserCfg.ie){\n\t    var obj_img = document.getElementById(&#39;tempimg&#39;);\n\t    obj_img.dynsrc=obj_file.value;\n\t    filesize = obj_img.fileSize;\n\t}\n\n2：在 HTML 文档中`<input type=\"file\">`标签每出现一次，一个`FileUpload` 对象就会被创建。\n\n该元素的 value 属性保存了用户指定的文件的名称，但是当包含一个 file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容而不仅仅是发送文件名。\n\n为安全起见，file-upload 元素不允许 HTML 作者或 JavaScript 程序员指定一个默认的文件名。HTML value 属性被忽略，并且对于此类元素来说，value 属性是只读的，这意味着只有用户可以输入一个文件名。当用户选择或编辑一个文件名，file-upload 元素触发 onchange 事件句柄。\n\n直接读value属性：\n\n![](/content/images/2016/07/1685753635620199227.png)\n\n3：`<input type='file'>`的files属性，是一个FileList对象（类数组对象），包含了名字和大小 等。如下：\n\n![](/content/images/2016/07/1982709736049941728-300x81.png)\n\n##### HTML5 File API实现上传文件\n\n访问本地文件的一个简单的方法是通过`<input type=\"file\"/>` HTML表单元素。这会给你访问为只读信息提供一个单独的文件如它的名称，大小，MIME类型，文件句柄的引用。\n\nHTML5的File API包括：\n\n1.    FileList序列：代表本地系统中选中的文件组成的数组，通过`<input type='file'>`调用\n2.    Blob接口，原始二进制数据，通过Blob对戏那个你可以访问里面的字节数据。\n3.    File接口，里面存有文件中的只读属性，文件名，类型，访问地址。\n4.    FileReader接口，提供读取文件方法\n5.    FileError接口和FileException对象，定义错误产生条件。\n\n下面实现单文件访问：核心代码就两行，也就是上面提到的FileList和FileReader。\n\n![](/content/images/2016/07/3167719388001804717-300x211.png)\n\n结果：\n\n![](/content/images/2016/07/6597294067029538127-300x235.png)\n\n实现多文件访问：\n\n![](/content/images/2016/07/3334352574214486754-300x255.png)\n\n结果：\n\n![](/content/images/2016/07/3172785937582596517-199x300.png)\n\nps：另外一个种方式File API，它 是 Mozilla 向 W3C 提交的一个草案，可以监听onload，onprogress，onloadstart等事件。详见[这里](http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload)。</a>\n\n##### 使用PHP实现文件上传\n\nHTML:注意设置MIME编码为`multipart/form-data.`\n\n`enctype=\"multipart/form-data\"`是上传二进制数据; form里面的input的值以2进制的方式传过去。\n\n\t<form enctype=\"multipart/form-data\" method=\"post\" action=\"..\">\n\t    <input type=\"file\" id=\"screenshot\" name=\"screenshot\" />\n\t    <hr />\n\t    <input type=\"submit\" value=\"Add\" name=\"submit\" />\n\t</form></pre><p>&nbsp;</p>\n\n\tphp:\n\t$screenshot = $_FILES[&#39;screenshot&#39;][&#39;name&#39;];\n\t$screenshot_type = $_FILES[&#39;screenshot&#39;][&#39;type&#39;];\n\t$screenshot_size = $_FILES[&#39;screenshot&#39;][&#39;size&#39;]; \n\n\n\t$target = $_SERVER[\"DOCUMENT_ROOT\"].GW_UPLOADPATH. $screenshot;\n\tmove_uploaded_file($_FILES[&#39;screenshot&#39;][&#39;tmp_name&#39;], $target)//这里把我们上传的文件放到$target。\n\n需要注意的是，move_uploaded_file函数里面的$target只能为绝对路径，不然就会报错。在这里困了好久。\n\n\n","mobiledoc":null,"html":"<h5 id=\"javascript\">上传之前 JavaScript 检测</h5>\n\n<p>1：javascript判断上传文件的大小：</p>\n\n<p>在FireFox、Chrome浏览器中可以根据<code>document.getElementById(\"id_of_file\").size</code> 获取上传文件的大小（字节数），而IE浏览器中不支持该属性，只能借助<code>&lt;img&gt;</code>标签的<code>dynsrc</code>属性，来间接实现获取文件的大小（但需要同意ActiveX控件的运行）。</p>\n\n<pre><code>var ua = window.navigator.userAgent;\nif (ua.indexOf(\"MSIE\")&gt;=1){\n    browserCfg.ie = true;\n}else if(ua.indexOf(\"Firefox\")&gt;=1){\n    browserCfg.firefox = true;\n}else if(ua.indexOf(\"Chrome\")&gt;=1){\n    browserCfg.chrome = true;\n}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\nif(browserCfg.firefox || browserCfg.chrome ){\n    filesize = obj_file.files[0].size;\n}else if(browserCfg.ie){\n    var obj_img = document.getElementById(&amp;#39;tempimg&amp;#39;);\n    obj_img.dynsrc=obj_file.value;\n    filesize = obj_img.fileSize;\n}\n</code></pre>\n\n<p>2：在 HTML 文档中<code>&lt;input type=\"file\"&gt;</code>标签每出现一次，一个<code>FileUpload</code> 对象就会被创建。</p>\n\n<p>该元素的 value 属性保存了用户指定的文件的名称，但是当包含一个 file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容而不仅仅是发送文件名。</p>\n\n<p>为安全起见，file-upload 元素不允许 HTML 作者或 JavaScript 程序员指定一个默认的文件名。HTML value 属性被忽略，并且对于此类元素来说，value 属性是只读的，这意味着只有用户可以输入一个文件名。当用户选择或编辑一个文件名，file-upload 元素触发 onchange 事件句柄。</p>\n\n<p>直接读value属性：</p>\n\n<p><img src=\"/content/images/2016/07/1685753635620199227.png\" alt=\"\" /></p>\n\n<p>3：<code>&lt;input type='file'&gt;</code>的files属性，是一个FileList对象（类数组对象），包含了名字和大小 等。如下：</p>\n\n<p><img src=\"/content/images/2016/07/1982709736049941728-300x81.png\" alt=\"\" /></p>\n\n<h5 id=\"html5fileapi\">HTML5 File API实现上传文件</h5>\n\n<p>访问本地文件的一个简单的方法是通过<code>&lt;input type=\"file\"/&gt;</code> HTML表单元素。这会给你访问为只读信息提供一个单独的文件如它的名称，大小，MIME类型，文件句柄的引用。</p>\n\n<p>HTML5的File API包括：</p>\n\n<ol>\n<li>FileList序列：代表本地系统中选中的文件组成的数组，通过<code>&lt;input type='file'&gt;</code>调用  </li>\n<li>Blob接口，原始二进制数据，通过Blob对戏那个你可以访问里面的字节数据。  </li>\n<li>File接口，里面存有文件中的只读属性，文件名，类型，访问地址。  </li>\n<li>FileReader接口，提供读取文件方法  </li>\n<li>FileError接口和FileException对象，定义错误产生条件。</li>\n</ol>\n\n<p>下面实现单文件访问：核心代码就两行，也就是上面提到的FileList和FileReader。</p>\n\n<p><img src=\"/content/images/2016/07/3167719388001804717-300x211.png\" alt=\"\" /></p>\n\n<p>结果：</p>\n\n<p><img src=\"/content/images/2016/07/6597294067029538127-300x235.png\" alt=\"\" /></p>\n\n<p>实现多文件访问：</p>\n\n<p><img src=\"/content/images/2016/07/3334352574214486754-300x255.png\" alt=\"\" /></p>\n\n<p>结果：</p>\n\n<p><img src=\"/content/images/2016/07/3172785937582596517-199x300.png\" alt=\"\" /></p>\n\n<p>ps：另外一个种方式File API，它 是 Mozilla 向 W3C 提交的一个草案，可以监听onload，onprogress，onloadstart等事件。详见<a href=\"http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload\">这里</a>。</a></p>\n\n<h5 id=\"php\">使用PHP实现文件上传</h5>\n\n<p>HTML:注意设置MIME编码为<code>multipart/form-data.</code></p>\n\n<p><code>enctype=\"multipart/form-data\"</code>是上传二进制数据; form里面的input的值以2进制的方式传过去。</p>\n\n<pre><code>&lt;form enctype=\"multipart/form-data\" method=\"post\" action=\"..\"&gt;\n    &lt;input type=\"file\" id=\"screenshot\" name=\"screenshot\" /&gt;\n    &lt;hr /&gt;\n    &lt;input type=\"submit\" value=\"Add\" name=\"submit\" /&gt;\n&lt;/form&gt;&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\nphp:\n$screenshot = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;name&amp;#39;];\n$screenshot_type = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;type&amp;#39;];\n$screenshot_size = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;size&amp;#39;]; \n\n\n$target = $_SERVER[\"DOCUMENT_ROOT\"].GW_UPLOADPATH. $screenshot;\nmove_uploaded_file($_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;tmp_name&amp;#39;], $target)//这里把我们上传的文件放到$target。\n</code></pre>\n\n<p>需要注意的是，move<em>uploaded</em>file函数里面的$target只能为绝对路径，不然就会报错。在这里困了好久。</p>","image":"/content/images/2016/07/images.jpeg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:13:46","created_by":1,"updated_at":"2016-07-09 08:43:43","updated_by":1,"published_at":"2013-05-24 08:13:00","published_by":1},{"id":70,"uuid":"22dadcb9-cd81-427a-8779-ec5c8faacc42","title":"前端跨域方式总结和实践","slug":"cross-origin-summary","markdown":"面试的时候问了跨域，之前知道几种方式，不过没有深入。既然面试官都问了，那么估计在实践中也会很多吧。总结学习学习！后面和同学讨论后，再问了下google，发现跨域的方式真的好多。\n\n本文意在总结和实践各种跨域方式，然后对比每种的优缺点，希望找到最佳实践方案。\n\n很好的一篇文章，推荐之：\n\n[http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)\n\n通过这篇文章知道了，`域名／协议／端口`只要其中之一不同都不能跨域，另外二级域名之间也不能跨。跨域的解决 ,有句经典的话就是，凡是有src属性的东东，都可以用来跨域。比如img，iframe，script等。\n\n如果练习的话，本机配置虚拟主机的教程在以前的[一篇文章](http://freestyleboy21.blog.163.com/blog/static/20840624120133139420259/?COLLCC=726912607)\n\n## 跨域之动态script\n\n这里，要首先弄清楚，我们跨域的目的是什么？\n\n我理解的是，跨域就是a.com要访问b.com的数据，包括变量，对象等。弄清楚后就可以开始实践这种动态script的方式了。\n\n在127.0.0.2的test.js中，我们要把传递给127.0.0.1/test.php 的数据封装好，我这里简单一个例子:\n\n    // 127.0.0.2/test.js\n\t(function() {\n\t\tvar b_myinfo = {\n\t\t\t'name' : 'fs21',\n\t\t\t'sex'  : 'male',\n\t\t\t'old'  : '21',\n\t\t\t'from' : 'uestc'\n\t\t}\n\t\ta_handler(b_myinfo);\n\t})();\n\n如果在php中，则可以用`echo $_GET('callback').\"($data);\";`来调用回调函数。\n\n另外在`127.0.0.1/test.php`中：\n\n![](/content/images/2016/07/1.png)\n\n请注意上面判断script加载完毕的方式。还有加载完了后的销毁，释放内存。\n这样在我们访问127.0.0.1/test.php时，结果如下：\n\n![](/content/images/2016/07/2.png)\n\n### 传说中的神器，jsonp\n\n上面的方式是两个域我们都可以控制，在一个域中配置好数据接口，另一个域来动态使用。\n\n其实另一个域也第三方的。下面的例子调用百度翻译，写一个简单的单词查询demo。test.html如下：\n\n![](/content/images/2016/07/3.png)\n\n就是获取输入框的内容，动态配置script的src，然后把查询的返回过来。\n\n注意上面src的最后一个回调函数。还有这个回调函数的作用域问题。\n\n结果如下：\n\n![](/content/images/2016/07/4.png)\n\n# 跨域之document.domain + iframe\n\n这种方式主要用在主域相同而子域不同的情况，由于不好模拟，就不折腾了，等以后有需求了，在来弄吧。核心代码如下：\n\n    //a.b.com/c.html\n\tdocument.domain = 'b.com';\n\tvar iframe = document.createElement('iframe');\n\tiframe.src = 'http://e.b.com/f.html';\n\tiframe.style.display = 'none';\n\tiframe.onload = function() {\n\t    var doc = iframe.contentDocument || iframe.contentWindow.document;\n\t    //这里操纵f.html\n\t    var fH1 = doc.getElementsByTagName('h1')[0];\n\t    .....\n\t}\n\t//e.b.com/f.html \n\tdocument.domain = 'b.com\n\n# 跨域之window.name\n\n这个方法早在08年的时候，克军和怿飞就写了博文介绍这这个方法。只怪生的太迟，不能跟上步伐。。站在巨人肩膀上的前提是学习前人的知识经验。\n\n先解释这个方法的原理。这种方法的核心是frame的window.name属性可以存不少数据，**当内部iframe src变化时window.name不变。**\n\n由三个页面组成，`127.0.0.1/test.php｜127.0.0.1/proxy.html｜127.0.0.2/index.php`\n\n我要做的是从第一个访问第三个中的数据。在/test.php中创建一个frame，src指向index.php,如果直接访问frame中的window.name会提示跨域错误，所以第二个proxy.html就上场了，proxy.html内容为空，但是和test.php在同一个域。我们判断如果把index.php加载完成后就把frame的src改成proxy.html，现在访问就不会提示跨域错误了，而且刚才说过，frame的window.name不会变！\n\n代码如下：\n\n//test.php\n\n![](/content/images/2016/07/5.png)\n\n\n    //index.php\n    window.name = 'i am from 127.0.0.2 !';\n\n当访问127.0.0.1/test.php时返回如下：\n\n![](/content/images/2016/07/6.png)\n\n\n这里有点需要注意，即使是IP和域名互相对应，也不能互相通信，他们之间也算跨域。因为这个原因，调了好久。上面的localhost/proxy.html那行最开始写成了`http://127.0.0.1/proxy.html`,这样是不能通信的。\n\n#跨域之HTML5 postMessage\n\n这种跨域方式比较新，而且api简单，容易上手，缺点就是浏览器支持不够，目前就那么几个比较潮的支持。不过相信，不过多久就会成为主流的跨域方式～\n\n下面的目标是两个域互相对话。先给效果图：\n\n![](/content/images/2016/07/7.png)\n\n用iframe的目的是为了方便我们看到，不然还得两个来回转换。其实可以不用iframe的哈！\n\n代码如下:\n\n// 127.0.0.1 test.php\n\n![](/content/images/2016/07/8.png)\n\n//127.0.0.2 index.php\n\n![](/content/images/2016/07/9.png)\n\n如大家所看，HTML5的PostMessage核心代码就postMessage和onmessage。相信不用解释都能懂啦～\n\n# 跨域之flash\n\n现在的flash已经不只是一个动画，更多的有了数据交互，与外界互动，那么跨域也是必须要面对的问题。\n\n由于对flash不太熟悉，只能从网上找点例子，看看原理，这里大致解释一下，如果有熟悉的朋友，欢迎交流指教。\n大致原理就是利用flash API中的LocalConnecttion这个类，在需要通信的两个域中各嵌套一个SWF，然后互相交换数据。\n\n别人说的，数据量限制40kb，数据快。没有实践，先记着吧。\n\n用这种方式跨域通信比较复杂，需要两个SWF，个人感觉实用性不强。\n\n# 跨域之CORS\n\nCORS的全称是`Cross-Origin Resource Sharing`，中文名字叫做“跨域资源共享”。目前在W3C的文档中还是草案，不过浏览器支持情况还是很乐观，IE8(不是XHR而是XDR）以上的IE，chrome 4.0以上，firefox 3.5以上都支持。参见caniuse.com\n\n最开始的时候是在高级程序设计上看到的，不过没有仔细研究。这次弄跨域，果断一起弄了。\n\n其实CORS和XHR差不多，唯一的差别就是CORS需要服务器支持。之前在XHR的写法是：\n\n    xhr.open('GET‘，’test.php',true);\n\n这里的test.php都是在同域名下，一般用相对地址。而我们的CORS写法是：\n\n    xhr.open('GET','freestyle21.cn',true);\n\n差别就是url变成不同域了！但是。。直接这样访问肯定是不行的，要报`Origin is not allowed by Access-Control-Allow-Origin.`的错误。CORS的解决方案是在服务器端该Header头部：\n\n    header(\"Access-Control-Allow-Origin：＊\");\n\n这样再次访问就可以了。对，CORS就这么简单！\n\n下面照例写个demo。http://127.0.0.1/test.php\n\n![](/content/images/2016/07/10.png)\n\n// 127.0.0.2/index.php\n\n    header(\"Access-Control-Allow-Origin:http://localhost\"); \n\n    i am from http://127.0.0.2/index.php\n\n现在访问`127.0.0.1／test.php`结果如下：\n\n![](/content/images/2016/07/10-1.png)\n\n# 总结\n\n通过动态script跨域，就是相当与引入一个外部的js文件而已，只不过这个文件带回来了一些有用的数据。\n\n通过jsonp跨域，实质是HTTP的GET方式请求，把参数或者回调函数传入url，然后在服务端做好相应的接口，返回给回调函数。见过别人做个的另一各种相似的方式是把参数给hash值，另一边通过轮询判断hash的变化，然后利用location.hash使用这个参数。这种方式都感觉略不完美，数据放在url上很不安全，而且会产生历史记录，数量有限\n\n总的来说，目前最简单有效的方式是jsonp，如果在受信任的双方传递数据，它是最佳的选择。\n在上面的例子中同样看到了CORS和postMessage的高效，在可预见的几年内，势必会成为主流。\n\nps：这篇文章边实践边写，写的比较久，断断续续的。因为博客的代码效果(之前在github上)不是很好，所以直接截图了。","mobiledoc":null,"html":"<p>面试的时候问了跨域，之前知道几种方式，不过没有深入。既然面试官都问了，那么估计在实践中也会很多吧。总结学习学习！后面和同学讨论后，再问了下google，发现跨域的方式真的好多。</p>\n\n<p>本文意在总结和实践各种跨域方式，然后对比每种的优缺点，希望找到最佳实践方案。</p>\n\n<p>很好的一篇文章，推荐之：</p>\n\n<p><a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>\n\n<p>通过这篇文章知道了，<code>域名／协议／端口</code>只要其中之一不同都不能跨域，另外二级域名之间也不能跨。跨域的解决 ,有句经典的话就是，凡是有src属性的东东，都可以用来跨域。比如img，iframe，script等。</p>\n\n<p>如果练习的话，本机配置虚拟主机的教程在以前的<a href=\"http://freestyleboy21.blog.163.com/blog/static/20840624120133139420259/?COLLCC=726912607\">一篇文章</a></p>\n\n<h2 id=\"script\">跨域之动态script</h2>\n\n<p>这里，要首先弄清楚，我们跨域的目的是什么？</p>\n\n<p>我理解的是，跨域就是a.com要访问b.com的数据，包括变量，对象等。弄清楚后就可以开始实践这种动态script的方式了。</p>\n\n<p>在127.0.0.2的test.js中，我们要把传递给127.0.0.1/test.php 的数据封装好，我这里简单一个例子:</p>\n\n<pre><code>// 127.0.0.2/test.js\n(function() {\n    var b_myinfo = {\n        'name' : 'fs21',\n        'sex'  : 'male',\n        'old'  : '21',\n        'from' : 'uestc'\n    }\n    a_handler(b_myinfo);\n})();\n</code></pre>\n\n<p>如果在php中，则可以用<code>echo $_GET('callback').\"($data);\";</code>来调用回调函数。</p>\n\n<p>另外在<code>127.0.0.1/test.php</code>中：</p>\n\n<p><img src=\"/content/images/2016/07/1.png\" alt=\"\" /></p>\n\n<p>请注意上面判断script加载完毕的方式。还有加载完了后的销毁，释放内存。\n这样在我们访问127.0.0.1/test.php时，结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/2.png\" alt=\"\" /></p>\n\n<h3 id=\"jsonp\">传说中的神器，jsonp</h3>\n\n<p>上面的方式是两个域我们都可以控制，在一个域中配置好数据接口，另一个域来动态使用。</p>\n\n<p>其实另一个域也第三方的。下面的例子调用百度翻译，写一个简单的单词查询demo。test.html如下：</p>\n\n<p><img src=\"/content/images/2016/07/3.png\" alt=\"\" /></p>\n\n<p>就是获取输入框的内容，动态配置script的src，然后把查询的返回过来。</p>\n\n<p>注意上面src的最后一个回调函数。还有这个回调函数的作用域问题。</p>\n\n<p>结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/4.png\" alt=\"\" /></p>\n\n<h1 id=\"documentdomainiframe\">跨域之document.domain + iframe</h1>\n\n<p>这种方式主要用在主域相同而子域不同的情况，由于不好模拟，就不折腾了，等以后有需求了，在来弄吧。核心代码如下：</p>\n\n<pre><code>//a.b.com/c.html\ndocument.domain = 'b.com';\nvar iframe = document.createElement('iframe');\niframe.src = 'http://e.b.com/f.html';\niframe.style.display = 'none';\niframe.onload = function() {\n    var doc = iframe.contentDocument || iframe.contentWindow.document;\n    //这里操纵f.html\n    var fH1 = doc.getElementsByTagName('h1')[0];\n    .....\n}\n//e.b.com/f.html \ndocument.domain = 'b.com\n</code></pre>\n\n<h1 id=\"windowname\">跨域之window.name</h1>\n\n<p>这个方法早在08年的时候，克军和怿飞就写了博文介绍这这个方法。只怪生的太迟，不能跟上步伐。。站在巨人肩膀上的前提是学习前人的知识经验。</p>\n\n<p>先解释这个方法的原理。这种方法的核心是frame的window.name属性可以存不少数据，<strong>当内部iframe src变化时window.name不变。</strong></p>\n\n<p>由三个页面组成，<code>127.0.0.1/test.php｜127.0.0.1/proxy.html｜127.0.0.2/index.php</code></p>\n\n<p>我要做的是从第一个访问第三个中的数据。在/test.php中创建一个frame，src指向index.php,如果直接访问frame中的window.name会提示跨域错误，所以第二个proxy.html就上场了，proxy.html内容为空，但是和test.php在同一个域。我们判断如果把index.php加载完成后就把frame的src改成proxy.html，现在访问就不会提示跨域错误了，而且刚才说过，frame的window.name不会变！</p>\n\n<p>代码如下：</p>\n\n<p>//test.php</p>\n\n<p><img src=\"/content/images/2016/07/5.png\" alt=\"\" /></p>\n\n<pre><code>//index.php\nwindow.name = 'i am from 127.0.0.2 !';\n</code></pre>\n\n<p>当访问127.0.0.1/test.php时返回如下：</p>\n\n<p><img src=\"/content/images/2016/07/6.png\" alt=\"\" /></p>\n\n<p>这里有点需要注意，即使是IP和域名互相对应，也不能互相通信，他们之间也算跨域。因为这个原因，调了好久。上面的localhost/proxy.html那行最开始写成了<code>http://127.0.0.1/proxy.html</code>,这样是不能通信的。</p>\n\n<h1 id=\"html5postmessage\">跨域之HTML5 postMessage</h1>\n\n<p>这种跨域方式比较新，而且api简单，容易上手，缺点就是浏览器支持不够，目前就那么几个比较潮的支持。不过相信，不过多久就会成为主流的跨域方式～</p>\n\n<p>下面的目标是两个域互相对话。先给效果图：</p>\n\n<p><img src=\"/content/images/2016/07/7.png\" alt=\"\" /></p>\n\n<p>用iframe的目的是为了方便我们看到，不然还得两个来回转换。其实可以不用iframe的哈！</p>\n\n<p>代码如下:</p>\n\n<p>// 127.0.0.1 test.php</p>\n\n<p><img src=\"/content/images/2016/07/8.png\" alt=\"\" /></p>\n\n<p>//127.0.0.2 index.php</p>\n\n<p><img src=\"/content/images/2016/07/9.png\" alt=\"\" /></p>\n\n<p>如大家所看，HTML5的PostMessage核心代码就postMessage和onmessage。相信不用解释都能懂啦～</p>\n\n<h1 id=\"flash\">跨域之flash</h1>\n\n<p>现在的flash已经不只是一个动画，更多的有了数据交互，与外界互动，那么跨域也是必须要面对的问题。</p>\n\n<p>由于对flash不太熟悉，只能从网上找点例子，看看原理，这里大致解释一下，如果有熟悉的朋友，欢迎交流指教。\n大致原理就是利用flash API中的LocalConnecttion这个类，在需要通信的两个域中各嵌套一个SWF，然后互相交换数据。</p>\n\n<p>别人说的，数据量限制40kb，数据快。没有实践，先记着吧。</p>\n\n<p>用这种方式跨域通信比较复杂，需要两个SWF，个人感觉实用性不强。</p>\n\n<h1 id=\"cors\">跨域之CORS</h1>\n\n<p>CORS的全称是<code>Cross-Origin Resource Sharing</code>，中文名字叫做“跨域资源共享”。目前在W3C的文档中还是草案，不过浏览器支持情况还是很乐观，IE8(不是XHR而是XDR）以上的IE，chrome 4.0以上，firefox 3.5以上都支持。参见caniuse.com</p>\n\n<p>最开始的时候是在高级程序设计上看到的，不过没有仔细研究。这次弄跨域，果断一起弄了。</p>\n\n<p>其实CORS和XHR差不多，唯一的差别就是CORS需要服务器支持。之前在XHR的写法是：</p>\n\n<pre><code>xhr.open('GET‘，’test.php',true);\n</code></pre>\n\n<p>这里的test.php都是在同域名下，一般用相对地址。而我们的CORS写法是：</p>\n\n<pre><code>xhr.open('GET','freestyle21.cn',true);\n</code></pre>\n\n<p>差别就是url变成不同域了！但是。。直接这样访问肯定是不行的，要报<code>Origin is not allowed by Access-Control-Allow-Origin.</code>的错误。CORS的解决方案是在服务器端该Header头部：</p>\n\n<pre><code>header(\"Access-Control-Allow-Origin：＊\");\n</code></pre>\n\n<p>这样再次访问就可以了。对，CORS就这么简单！</p>\n\n<p>下面照例写个demo。<a href=\"http://127.0.0.1/test.php\">http://127.0.0.1/test.php</a></p>\n\n<p><img src=\"/content/images/2016/07/10.png\" alt=\"\" /></p>\n\n<p>// 127.0.0.2/index.php</p>\n\n<pre><code>header(\"Access-Control-Allow-Origin:http://localhost\"); \n\ni am from http://127.0.0.2/index.php\n</code></pre>\n\n<p>现在访问<code>127.0.0.1／test.php</code>结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/10-1.png\" alt=\"\" /></p>\n\n<h1 id=\"\">总结</h1>\n\n<p>通过动态script跨域，就是相当与引入一个外部的js文件而已，只不过这个文件带回来了一些有用的数据。</p>\n\n<p>通过jsonp跨域，实质是HTTP的GET方式请求，把参数或者回调函数传入url，然后在服务端做好相应的接口，返回给回调函数。见过别人做个的另一各种相似的方式是把参数给hash值，另一边通过轮询判断hash的变化，然后利用location.hash使用这个参数。这种方式都感觉略不完美，数据放在url上很不安全，而且会产生历史记录，数量有限</p>\n\n<p>总的来说，目前最简单有效的方式是jsonp，如果在受信任的双方传递数据，它是最佳的选择。\n在上面的例子中同样看到了CORS和postMessage的高效，在可预见的几年内，势必会成为主流。</p>\n\n<p>ps：这篇文章边实践边写，写的比较久，断断续续的。因为博客的代码效果(之前在github上)不是很好，所以直接截图了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:44:37","created_by":1,"updated_at":"2016-07-09 08:54:06","updated_by":1,"published_at":"2013-05-09 08:44:00","published_by":1},{"id":71,"uuid":"dbe40561-81ee-4b64-bf19-1ec0b42871a0","title":"Ant的故事","slug":"ant-build-tools","markdown":"##   Ant的来历\n\n前段时间在学习淘宝的前端框架Kissy，在项目开发指南中看到了Ant，由于以前听过，所以来了兴趣。正如上篇文章所说，前端实践非常重要，于是就从头到尾研究起Ant来。。\n\n说来，Ant来自Java，是一个基于Java的build工具。和Unix/Linux c中的make工具类似，不过由于Java的原因具有跨平台的优势。那么Ant和前端有半毛线关系么？答案是，哈哈~~\n对前端来说，Ant可以\n\n* 合并js和css文件\n* 压缩js和css文件\n* 生成jsDOC文档\n* 连接FTP，将代码上传到指定服务器\n* 自动上传到SVN，自动打包成zip文件\n* ....\n\n当然这些都是网上抄来的，没有一一实验。喜欢的还是合并、压缩、文档，也都自己从0开始慢慢摸索了下，总结记录一下，方便对她有兴趣的朋友..\n\n# Ant的入门\n\n### 首先我们安装Ant的环境。\n\n安装jdk的步骤就不细说，度娘那里有很多。\n\n下载Ant，传送门: [apache-ant-1.9.0](http://apache.fayea.com/apache-mirror//ant/source/apache-ant-1.9.0-src.zip)\n\n解压到你喜欢的位置，我是F:\\apache-ant-1.9.0.\n\n在path里面添加：`F:\\apache-ant-1.9.0.\\bin`\n\n在DOS里面输入ant，验证安装是否完成。出现下面的结果就算成功了。\n\n\n\tBuildfile：build.xml does not exist! \n\tBuild failed\n\n## 牛刀小试\n\n新建test的java项目，里面建立src目录，在src里面写一个hello.java，内容如下：\n\n\tpublic class HelloWorld {\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n在test目录里面建立build.xml文件。内容如下：\n\n\t<?xml version=\"1.0\" ?>\n\t<project name =\"javacTest\" default=\"run\" basedir=\".\">\n\n\t\t<target name=\"compile\">\n\t\t\t<mkdir dir =\"${basedir}/build/classes\"/>\n\t\t\t<javac srcdir =\"${basedir}/src\" destdir =\"${basedir}/build/classes\"/>\n\t\t</target>\n\t\t<target name=\"run\" depends =\"compile\">\n\t\t\t<java classname =\"HelloWorld\">\n\t\t\t<classpath>\n\t\t\t\t\t<pathelement path=\"${basedir}/build/classes\"/>\n\t\t\t</classpath>\n\t\t\t</java>\n\t\t</target>\n\t</project>\n\n用命令行进入`test`目录里面，执行`ant`。你会发现`build`里面多了`classes`目录，`classes`里面多了`hello.class`。在命令行里面会有`hello world`输出。如下图：\n\n![](/content/images/2016/07/ant.png)\n\n这次不准备讲ant的api，有兴趣的童鞋可以去看[官方文档](http://ant.apache.org/manual/index.html)。这里我把遇到的讲一下，相信这样你也能掌握常见的语法了~\n\n上面的`build.xml`中，就是我们的主角`Ant`了。每个`Ant`都有且只能有一个`project`，多个`target`(可理解为任务块)，`depends=\"compile\"`指必须名字为compile的target先执行，他们存在依赖关系。其他的就不解释了。\n\n## Ant和前端。\n\n### 合并js\n\n在test目录里面建四个js文件内容依次为`console.log(\"hello, i am from 1/2/3/4\");`然后建立build.xml内容为：\n\n\t\n\t<?xml version=\"1.0\"?>\n\t<project name=\"concat\" default=\"build\">\n\t\t<property name=\"concat.note\" value=\"//合并js\" />\n\t\t<target name=\"build\">\n\t\t\t<echo>生成src目录</echo>\n\t\t\t<mkdir dir=\"src\"/>\n\t\t\t<echo>开始合并文件</echo>\n\t\t\t<concat destfile=\"src/fs.js\">\n\t\t\t<header trimleading=\"yes\">${concat.note}\n\t\t\t</header>\n\t\t\t<path path=\"1.js\"/>\n\t\t\t<path path=\"2.js\"/>\n\t\t\t<path path=\"3.js\"/>\n\t\t\t<path path=\"4.js\"/>\n\t\t</concat>\n\t\t</target>\n\t</project>\n\nCMD切换到test目录，执行ant。输出\n\n![](/content/images/2016/07/ant2.png)\n\n在src里面多了fs.js文件，内容为：\n\n![](/content/images/2016/07/concat.png)\n\n现在解释上面的build.xml。property定义一个名为concat.note的变量，内容为`\"//合并js\"`，下面会用${concat.note}引用。header是给fs.js最上面加一行。下面的合并就那样，都看得懂，记住格式就好了。提示一点是header那里有换行，如果不换，自己试试后果，呵呵。\n\n有些童鞋就在想了，要是我有20个js，是不是要写20个path呢？当然不是！为了解决这个问题，我们的dadaType标签就闪亮登场啦~\n\n把path变成\n\n    <pre class=\"brush:xml\">\n        <fileset dir = \"./\" includes = \"**/*.js\">\n    </pre>\n\n\n就可以代替20个path！dataType常用除了我们见过的fileset/path，还有我们在压缩和生成文档要用的argument。fileset还有一个常用的语句，如下：\n\n\t<fileset dir = \"./\">\n\t    <include name = \"**/*.js\" if = \"test\">\n\t    <exclude name = \"my.js\" unless = \"my\">\n\t</fileset>\n\n如果设置了test属性，读取所有js，如果没有设置my属性，则排除my.js\n\n### 压缩js\n\n先下载[YUICompressor](http://vdisk.weibo.com/s/AjhVv)\n\n运行解压过后的install.cmd。(用管理员身份运行，否则会出错哦)\n\n然后随便右键一个文件就就会多一个Process with YUICompressor了。\n\n把刚才解压的YUICompressor放到test目录中，新建一个min文件夹。把build.xml改成如下：\n\n\t\t<?xml version=\"1.0\"?>\n\t\t<project name=\"refund\" default=\"build\">\n\t\t\t<dirname property=\"current.dir\" file=\"${ant.file.uploader}\"/>\n\t\t\t<property name=\"src.dir\" location=\"${current.dir}/src/\"/>\n\t\t\t<property name=\"yuicompressor.path\" location=\"${current.dir}/yuicompressor/yuicompressor.jar\"/>\n\t\t\t<target name=\"build\">\n\t\t\t\t<apply executable=\"java\" dest=\"${current.dir}/min\">\n\t\t\t\t<fileset dir=\"${src.dir}\" includes=\"*.js\"/>\n\t\t\t\t<arg line=\"-jar\"/>\n\t\t\t\t<arg path=\"${yuicompressor.path}\"/>\n\t\t\t\t<arg value=\"-o\"/>\n\t\t\t\t<targetfile/>\n\t\t\t\t<mapper type=\"glob\" from=\"*.js\" to=\"*-min.js\"/>\n\t\t\t\t</apply>\n\t\t\t</target>\n\t\t</project>\n\n然后运行ant命令。在min文件夹里面就会出现：\n\n![](/content/images/2016/07/min.png)\n\n解释上面的build.xml.dirname用来获取文件的目录路径。注意到里面有个变量指向yuicompressor.jar，这样才能用YUICompressor。这里的arg提供给apply一些参数。-jar为YUICompressor中的.jar路径，就是刚才提到的那个变量。mapper定义源文件和目标文件的关联方式，这里是把.js变成-min.js。\n\n生成文档的方式和压缩差不多，用的是jsdoc toolkit。偷下懒，这里就不演示了。\n\n对于我们来说，如果压缩的文件就那么两个，手动就好了。如果多了，就要用Ant了。合并的时候要注意我们的js的顺序，比如jquery一定要在bootstrap.js的前面，注意他们的依赖关系。\n\n本文的参考文章:\n\n* [明河的电子书](http://book.36ria.com/ant/index.html#index)\n* [Apache Ant手册](http://ant.apache.org/manual)\n* [Top 15 Ant Best Practices](http://www.onjava.com/pub/a/onjava/2003/12/17/ant_bestpractices.html)","mobiledoc":null,"html":"<h2 id=\"ant\">  Ant的来历</h2>\n\n<p>前段时间在学习淘宝的前端框架Kissy，在项目开发指南中看到了Ant，由于以前听过，所以来了兴趣。正如上篇文章所说，前端实践非常重要，于是就从头到尾研究起Ant来。。</p>\n\n<p>说来，Ant来自Java，是一个基于Java的build工具。和Unix/Linux c中的make工具类似，不过由于Java的原因具有跨平台的优势。那么Ant和前端有半毛线关系么？答案是，哈哈~~\n对前端来说，Ant可以</p>\n\n<ul>\n<li>合并js和css文件</li>\n<li>压缩js和css文件</li>\n<li>生成jsDOC文档</li>\n<li>连接FTP，将代码上传到指定服务器</li>\n<li>自动上传到SVN，自动打包成zip文件</li>\n<li>....</li>\n</ul>\n\n<p>当然这些都是网上抄来的，没有一一实验。喜欢的还是合并、压缩、文档，也都自己从0开始慢慢摸索了下，总结记录一下，方便对她有兴趣的朋友..</p>\n\n<h1 id=\"ant\">Ant的入门</h1>\n\n<h3 id=\"ant\">首先我们安装Ant的环境。</h3>\n\n<p>安装jdk的步骤就不细说，度娘那里有很多。</p>\n\n<p>下载Ant，传送门: <a href=\"http://apache.fayea.com/apache-mirror//ant/source/apache-ant-1.9.0-src.zip\">apache-ant-1.9.0</a></p>\n\n<p>解压到你喜欢的位置，我是F:\\apache-ant-1.9.0.</p>\n\n<p>在path里面添加：<code>F:\\apache-ant-1.9.0.\\bin</code></p>\n\n<p>在DOS里面输入ant，验证安装是否完成。出现下面的结果就算成功了。</p>\n\n<pre><code>Buildfile：build.xml does not exist! \nBuild failed\n</code></pre>\n\n<h2 id=\"\">牛刀小试</h2>\n\n<p>新建test的java项目，里面建立src目录，在src里面写一个hello.java，内容如下：</p>\n\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"hello world!\");\n    }\n}\n</code></pre>\n\n<p>在test目录里面建立build.xml文件。内容如下：</p>\n\n<pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;project name =\"javacTest\" default=\"run\" basedir=\".\"&gt;\n\n    &lt;target name=\"compile\"&gt;\n        &lt;mkdir dir =\"${basedir}/build/classes\"/&gt;\n        &lt;javac srcdir =\"${basedir}/src\" destdir =\"${basedir}/build/classes\"/&gt;\n    &lt;/target&gt;\n    &lt;target name=\"run\" depends =\"compile\"&gt;\n        &lt;java classname =\"HelloWorld\"&gt;\n        &lt;classpath&gt;\n                &lt;pathelement path=\"${basedir}/build/classes\"/&gt;\n        &lt;/classpath&gt;\n        &lt;/java&gt;\n    &lt;/target&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>用命令行进入<code>test</code>目录里面，执行<code>ant</code>。你会发现<code>build</code>里面多了<code>classes</code>目录，<code>classes</code>里面多了<code>hello.class</code>。在命令行里面会有<code>hello world</code>输出。如下图：</p>\n\n<p><img src=\"/content/images/2016/07/ant.png\" alt=\"\" /></p>\n\n<p>这次不准备讲ant的api，有兴趣的童鞋可以去看<a href=\"http://ant.apache.org/manual/index.html\">官方文档</a>。这里我把遇到的讲一下，相信这样你也能掌握常见的语法了~</p>\n\n<p>上面的<code>build.xml</code>中，就是我们的主角<code>Ant</code>了。每个<code>Ant</code>都有且只能有一个<code>project</code>，多个<code>target</code>(可理解为任务块)，<code>depends=\"compile\"</code>指必须名字为compile的target先执行，他们存在依赖关系。其他的就不解释了。</p>\n\n<h2 id=\"ant\">Ant和前端。</h2>\n\n<h3 id=\"js\">合并js</h3>\n\n<p>在test目录里面建四个js文件内容依次为<code>console.log(\"hello, i am from 1/2/3/4\");</code>然后建立build.xml内容为：</p>\n\n<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;project name=\"concat\" default=\"build\"&gt;\n    &lt;property name=\"concat.note\" value=\"//合并js\" /&gt;\n    &lt;target name=\"build\"&gt;\n        &lt;echo&gt;生成src目录&lt;/echo&gt;\n        &lt;mkdir dir=\"src\"/&gt;\n        &lt;echo&gt;开始合并文件&lt;/echo&gt;\n        &lt;concat destfile=\"src/fs.js\"&gt;\n        &lt;header trimleading=\"yes\"&gt;${concat.note}\n        &lt;/header&gt;\n        &lt;path path=\"1.js\"/&gt;\n        &lt;path path=\"2.js\"/&gt;\n        &lt;path path=\"3.js\"/&gt;\n        &lt;path path=\"4.js\"/&gt;\n    &lt;/concat&gt;\n    &lt;/target&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>CMD切换到test目录，执行ant。输出</p>\n\n<p><img src=\"/content/images/2016/07/ant2.png\" alt=\"\" /></p>\n\n<p>在src里面多了fs.js文件，内容为：</p>\n\n<p><img src=\"/content/images/2016/07/concat.png\" alt=\"\" /></p>\n\n<p>现在解释上面的build.xml。property定义一个名为concat.note的变量，内容为<code>\"//合并js\"</code>，下面会用${concat.note}引用。header是给fs.js最上面加一行。下面的合并就那样，都看得懂，记住格式就好了。提示一点是header那里有换行，如果不换，自己试试后果，呵呵。</p>\n\n<p>有些童鞋就在想了，要是我有20个js，是不是要写20个path呢？当然不是！为了解决这个问题，我们的dadaType标签就闪亮登场啦~</p>\n\n<p>把path变成</p>\n\n<pre><code>&lt;pre class=\"brush:xml\"&gt;\n    &lt;fileset dir = \"./\" includes = \"**/*.js\"&gt;\n&lt;/pre&gt;\n</code></pre>\n\n<p>就可以代替20个path！dataType常用除了我们见过的fileset/path，还有我们在压缩和生成文档要用的argument。fileset还有一个常用的语句，如下：</p>\n\n<pre><code>&lt;fileset dir = \"./\"&gt;\n    &lt;include name = \"**/*.js\" if = \"test\"&gt;\n    &lt;exclude name = \"my.js\" unless = \"my\"&gt;\n&lt;/fileset&gt;\n</code></pre>\n\n<p>如果设置了test属性，读取所有js，如果没有设置my属性，则排除my.js</p>\n\n<h3 id=\"js\">压缩js</h3>\n\n<p>先下载<a href=\"http://vdisk.weibo.com/s/AjhVv\">YUICompressor</a></p>\n\n<p>运行解压过后的install.cmd。(用管理员身份运行，否则会出错哦)</p>\n\n<p>然后随便右键一个文件就就会多一个Process with YUICompressor了。</p>\n\n<p>把刚才解压的YUICompressor放到test目录中，新建一个min文件夹。把build.xml改成如下：</p>\n\n<pre><code>    &lt;?xml version=\"1.0\"?&gt;\n    &lt;project name=\"refund\" default=\"build\"&gt;\n        &lt;dirname property=\"current.dir\" file=\"${ant.file.uploader}\"/&gt;\n        &lt;property name=\"src.dir\" location=\"${current.dir}/src/\"/&gt;\n        &lt;property name=\"yuicompressor.path\" location=\"${current.dir}/yuicompressor/yuicompressor.jar\"/&gt;\n        &lt;target name=\"build\"&gt;\n            &lt;apply executable=\"java\" dest=\"${current.dir}/min\"&gt;\n            &lt;fileset dir=\"${src.dir}\" includes=\"*.js\"/&gt;\n            &lt;arg line=\"-jar\"/&gt;\n            &lt;arg path=\"${yuicompressor.path}\"/&gt;\n            &lt;arg value=\"-o\"/&gt;\n            &lt;targetfile/&gt;\n            &lt;mapper type=\"glob\" from=\"*.js\" to=\"*-min.js\"/&gt;\n            &lt;/apply&gt;\n        &lt;/target&gt;\n    &lt;/project&gt;\n</code></pre>\n\n<p>然后运行ant命令。在min文件夹里面就会出现：</p>\n\n<p><img src=\"/content/images/2016/07/min.png\" alt=\"\" /></p>\n\n<p>解释上面的build.xml.dirname用来获取文件的目录路径。注意到里面有个变量指向yuicompressor.jar，这样才能用YUICompressor。这里的arg提供给apply一些参数。-jar为YUICompressor中的.jar路径，就是刚才提到的那个变量。mapper定义源文件和目标文件的关联方式，这里是把.js变成-min.js。</p>\n\n<p>生成文档的方式和压缩差不多，用的是jsdoc toolkit。偷下懒，这里就不演示了。</p>\n\n<p>对于我们来说，如果压缩的文件就那么两个，手动就好了。如果多了，就要用Ant了。合并的时候要注意我们的js的顺序，比如jquery一定要在bootstrap.js的前面，注意他们的依赖关系。</p>\n\n<p>本文的参考文章:</p>\n\n<ul>\n<li><a href=\"http://book.36ria.com/ant/index.html#index\">明河的电子书</a></li>\n<li><a href=\"http://ant.apache.org/manual\">Apache Ant手册</a></li>\n<li><a href=\"http://www.onjava.com/pub/a/onjava/2003/12/17/ant_bestpractices.html\">Top 15 Ant Best Practices</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:54:29","created_by":1,"updated_at":"2016-07-09 14:19:17","updated_by":1,"published_at":"2013-05-06 08:54:00","published_by":1},{"id":72,"uuid":"18e4c0cb-28af-48b7-b36a-996e1330cf81","title":"从其他网站抓数据","slug":"grab-data-from-website","markdown":"## 缘由\n\n吃饭的时候和朋友聊天，谈到他上一个项目，他去抓其他网站的数据，然后用canvas画出走势图。吸引我的是前面的抓数据，以前从来没有尝试过，一定会很有意思了！\n\n## 开始\n\n听他讲大致就是用jsonp去请求，然后读取json吧。感觉这种方式不太好，因为只有目标网站提供了相应接口，才能去请求，然后解析收到的数据。\n自己尝试用jsonp去请求一些数据，于是找数据接口，不过好少。目前找到的下面几个：\n（浏览器中打开的json格式不太好看，请读者朋友把下面的json拷到\n\n[http://jsonformatter.curiousconcept.com](http://jsonformatter.curiousconcept.com)\n\n朋友项目中用到的[http://jry.baidao.com/api/hq/npdata.do](http://jry.baidao.com/api/hq/npdata.do)\n\n天气：\n\n[http://www.weather.com.cn/data/sk/101281601.html](http://www.weather.com.cn/data/sk/101281601.html)\n\n[http://www.weather.com.cn/data/cityinfo/101281601.html](http://www.weather.com.cn/data/cityinfo/101281601.html)\n\n[http://m.weather.com.cn/data/101281601.html](http://m.weather.com.cn/data/101281601.html) \n\n新浪：\n\n[https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522)  //获取公共微博注意.最后为你的appkey。\n\n[https://api.weibo.com/2/account/get_uid.json?source=1105337522](https://api.weibo.com/2/account/get_uid.json?source=1105337522) //获取授权用户UID.\n\n[https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522) //获取当前登录用户及其所关注用户的最新微博\n\n[https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522) //获取用户最新的微博\n\n豆瓣：\n\n[http://api.douban.com/v2/user/freestyle21](http://api.douban.com/v2/user/freestyle21) //获取用户信息\n\n[http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21](http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21) //获取用户时间线\n\n在用jsonp请求数据的时候，只需要把url换成上面的就可以了，然后在回调函数里面处理返回的json数据就好了。\n\n文章的标题叫做抓数据，但是到此为止好像只有请求数据，没有抓。。\n\n##然后\n\n尽管上面找的那些链接能够完成很多事情，但是，让我不爽的是提供接口的网站并不多。要是我想要虎扑上的比赛数据呢？要是我想要河畔最新的贴子呢？\n\n于是，又开始在网上找可以抓取任意网站数据的方法。在一篇文章中看到了火车头采集器，去下载了。把它的论坛上三个视频看了，感觉这个只是适合站长，不太适合普通开发者。不过功能真的是比较强大。这里不讲了，有兴趣的可以从[这里](http://bbs.locoy.com/spider-132850-1-1.html)去看下。\n\n然后接着查询。。印象中python和java比较适合干这样的事，但是对这两门语言都不太熟悉，故还是想从熟悉的东西着手。咨询几个朋友，原来php也可以抓取数据～～\n\n查看了几个例子，自己实验了一番，总结如下。\n\n## 通过fopen来读取要抓取的网页\n\n下面的例子来抓取我博客的title：\n\n      <php\n        $file = fopen (\"http://qubaoming.me/\", \"r\"); \n        if (!$file) { \n            echo \"&lt;font color=red>Unable to open remote file.&lt;/font>\\n\"; \n            exit; \n        } \n        while (!feof ($file)) { \n            $line = fgets ($file, 1024); \n            if (eregi (\"&lt;title>(.*)&lt;/title>\", $line, $out)) { \n                $title = $out[1]; \n                echo \"\".$title.\"\"; \n                break; \n            } \n        } \n        fclose($file); \n    ?>\n\n获取我博客所有代码：\n\n    <php\n        $fp = fsockopen(\"freestyle21.cn\", 80, $errno, $errstr, 30); \n        if (!$fp) { \n           echo \"$errstr ($errno)&lt;br/>\\n\"; \n        } else { \n           $out = \"GET / HTTP/1.1\\r\\n\"; \n           $out .= \"Host: freestyle21.cn \\r\\n\"; \n           $out .= \"Connection: Close \\r\\n\\r\\n\"; \n           fputs($fp, $out); \n           while (!feof($fp)) { \n             echo fgets($fp, 128); \n           } \n           fclose($fp); \n        }\n    ?>\n\n或者\n\n    <php\n        $urlstr = file_get_contents(\"http://qubaoming.me\");\n        $urlstr = htmlspecialchars($urlstr);\n        print_r($urlstr);\n    ?>\n\n## 通过curl／DOMDocument／DOMXpath抓取数据\n\n上面的那种方式或许还不能叫抓数据。因为对返回的HTML处理不够。\n然后，我们知道在php中curl可以抓取下载html（也可以模拟登录，伪装客户端等），DOMDocument可以刚刚下载的HTML加载成DOM，DOMXPath则可以使用XPath语法进行数据的定位和采集。幸运的是，对于前端来说，三个都比较熟悉，所以就比较简单了。\n\n### 抓博客中所有的链接url\n\n\t<php\n        $target_url = \"http://qubaoming.me\";\n        $ch = curl_init();\n        //执行之前，设置一些参数\n        curl_setopt($ch, CURLOPT_URL,$target_url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        $html = curl_exec($ch);\n        if (!$html) {\n            echo \"&lt;br />cURL error number:\" .curl_errno($ch);\n            echo \"&lt;br />cURL error:\" . curl_error($ch);\n            exit;\n        }\n        //创建一个DomDocument对象，用于处理一个HTML\n        $dom = new DOMDocument();\n        //从一个字符串加载HTML\n        @$dom->loadHTML($html);\n        //使该HTML规范化\n        $dom->normalize();\n        //用DOMXpath加载DOM，用于查询\n        $xpath = new DOMXPath($dom);\n        //获取所有的a标签的地址\n        $hrefs = $xpath->evaluate(\"/html/body//a//@href\");\n        for ($i = 0; $i &lt; $hrefs->length; $i++) {\n            $href = $hrefs->item($i);\n            $linktext = $href->nodeValue;\n            echo $linktex;\n            echo \"&lt;BR>\";\n        }\n    ?>\n\n结果如下；\n\n![](/content/images/2016/07/grab_link.png)\n\n如果想要抓取博客中的“这里记载着帅气的博主的技术成长过程，也会时而发下生活的牢骚”，这几个字，把xpath改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//h2\");\n\n如果想要抓取\"freestyle21\"几个字母，改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//a//h1\");\n\n如果想要抓去最下面的描述“一个老男人,今年22岁.一枚程序员，Web前端！一只科蜜，季后赛！”，改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//ul//li\");\n\n到此，要抓取给定网页的任意数据就比较简单了，最终任务转换到解析DOM。而这，又是没有前端都擅长的～\n\n## 总结\n\n总的来说，用这篇文章中的方法抓取数据都不是最科学的，因为我们必须要读取所以的HTML，这样效率肯定比较低。最科学的方式还是不用下到本地服务器，直接读取。以后有需求了，还是学下Python和Java的抓取方式～～","mobiledoc":null,"html":"<h2 id=\"\">缘由</h2>\n\n<p>吃饭的时候和朋友聊天，谈到他上一个项目，他去抓其他网站的数据，然后用canvas画出走势图。吸引我的是前面的抓数据，以前从来没有尝试过，一定会很有意思了！</p>\n\n<h2 id=\"\">开始</h2>\n\n<p>听他讲大致就是用jsonp去请求，然后读取json吧。感觉这种方式不太好，因为只有目标网站提供了相应接口，才能去请求，然后解析收到的数据。\n自己尝试用jsonp去请求一些数据，于是找数据接口，不过好少。目前找到的下面几个：\n（浏览器中打开的json格式不太好看，请读者朋友把下面的json拷到</p>\n\n<p><a href=\"http://jsonformatter.curiousconcept.com\">http://jsonformatter.curiousconcept.com</a></p>\n\n<p>朋友项目中用到的<a href=\"http://jry.baidao.com/api/hq/npdata.do\">http://jry.baidao.com/api/hq/npdata.do</a></p>\n\n<p>天气：</p>\n\n<p><a href=\"http://www.weather.com.cn/data/sk/101281601.html\">http://www.weather.com.cn/data/sk/101281601.html</a></p>\n\n<p><a href=\"http://www.weather.com.cn/data/cityinfo/101281601.html\">http://www.weather.com.cn/data/cityinfo/101281601.html</a></p>\n\n<p><a href=\"http://m.weather.com.cn/data/101281601.html\">http://m.weather.com.cn/data/101281601.html</a> </p>\n\n<p>新浪：</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522</a>  //获取公共微博注意.最后为你的appkey。</p>\n\n<p><a href=\"https://api.weibo.com/2/account/get_uid.json?source=1105337522\">https://api.weibo.com/2/account/get_uid.json?source=1105337522</a> //获取授权用户UID.</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522</a> //获取当前登录用户及其所关注用户的最新微博</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522</a> //获取用户最新的微博</p>\n\n<p>豆瓣：</p>\n\n<p><a href=\"http://api.douban.com/v2/user/freestyle21\">http://api.douban.com/v2/user/freestyle21</a> //获取用户信息</p>\n\n<p><a href=\"http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21\">http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21</a> //获取用户时间线</p>\n\n<p>在用jsonp请求数据的时候，只需要把url换成上面的就可以了，然后在回调函数里面处理返回的json数据就好了。</p>\n\n<p>文章的标题叫做抓数据，但是到此为止好像只有请求数据，没有抓。。</p>\n\n<h2 id=\"\">然后</h2>\n\n<p>尽管上面找的那些链接能够完成很多事情，但是，让我不爽的是提供接口的网站并不多。要是我想要虎扑上的比赛数据呢？要是我想要河畔最新的贴子呢？</p>\n\n<p>于是，又开始在网上找可以抓取任意网站数据的方法。在一篇文章中看到了火车头采集器，去下载了。把它的论坛上三个视频看了，感觉这个只是适合站长，不太适合普通开发者。不过功能真的是比较强大。这里不讲了，有兴趣的可以从<a href=\"http://bbs.locoy.com/spider-132850-1-1.html\">这里</a>去看下。</p>\n\n<p>然后接着查询。。印象中python和java比较适合干这样的事，但是对这两门语言都不太熟悉，故还是想从熟悉的东西着手。咨询几个朋友，原来php也可以抓取数据～～</p>\n\n<p>查看了几个例子，自己实验了一番，总结如下。</p>\n\n<h2 id=\"fopen\">通过fopen来读取要抓取的网页</h2>\n\n<p>下面的例子来抓取我博客的title：</p>\n\n<pre><code>  &lt;php\n    $file = fopen (\"http://qubaoming.me/\", \"r\"); \n    if (!$file) { \n        echo \"&amp;lt;font color=red&gt;Unable to open remote file.&amp;lt;/font&gt;\\n\"; \n        exit; \n    } \n    while (!feof ($file)) { \n        $line = fgets ($file, 1024); \n        if (eregi (\"&amp;lt;title&gt;(.*)&amp;lt;/title&gt;\", $line, $out)) { \n            $title = $out[1]; \n            echo \"\".$title.\"\"; \n            break; \n        } \n    } \n    fclose($file); \n?&gt;\n</code></pre>\n\n<p>获取我博客所有代码：</p>\n\n<pre><code>&lt;php\n    $fp = fsockopen(\"freestyle21.cn\", 80, $errno, $errstr, 30); \n    if (!$fp) { \n       echo \"$errstr ($errno)&amp;lt;br/&gt;\\n\"; \n    } else { \n       $out = \"GET / HTTP/1.1\\r\\n\"; \n       $out .= \"Host: freestyle21.cn \\r\\n\"; \n       $out .= \"Connection: Close \\r\\n\\r\\n\"; \n       fputs($fp, $out); \n       while (!feof($fp)) { \n         echo fgets($fp, 128); \n       } \n       fclose($fp); \n    }\n?&gt;\n</code></pre>\n\n<p>或者</p>\n\n<pre><code>&lt;php\n    $urlstr = file_get_contents(\"http://qubaoming.me\");\n    $urlstr = htmlspecialchars($urlstr);\n    print_r($urlstr);\n?&gt;\n</code></pre>\n\n<h2 id=\"curldomdocumentdomxpath\">通过curl／DOMDocument／DOMXpath抓取数据</h2>\n\n<p>上面的那种方式或许还不能叫抓数据。因为对返回的HTML处理不够。\n然后，我们知道在php中curl可以抓取下载html（也可以模拟登录，伪装客户端等），DOMDocument可以刚刚下载的HTML加载成DOM，DOMXPath则可以使用XPath语法进行数据的定位和采集。幸运的是，对于前端来说，三个都比较熟悉，所以就比较简单了。</p>\n\n<h3 id=\"url\">抓博客中所有的链接url</h3>\n\n<pre><code>&lt;php\n    $target_url = \"http://qubaoming.me\";\n    $ch = curl_init();\n    //执行之前，设置一些参数\n    curl_setopt($ch, CURLOPT_URL,$target_url);\n    curl_setopt($ch, CURLOPT_FAILONERROR, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    $html = curl_exec($ch);\n    if (!$html) {\n        echo \"&amp;lt;br /&gt;cURL error number:\" .curl_errno($ch);\n        echo \"&amp;lt;br /&gt;cURL error:\" . curl_error($ch);\n        exit;\n    }\n    //创建一个DomDocument对象，用于处理一个HTML\n    $dom = new DOMDocument();\n    //从一个字符串加载HTML\n    @$dom-&gt;loadHTML($html);\n    //使该HTML规范化\n    $dom-&gt;normalize();\n    //用DOMXpath加载DOM，用于查询\n    $xpath = new DOMXPath($dom);\n    //获取所有的a标签的地址\n    $hrefs = $xpath-&gt;evaluate(\"/html/body//a//@href\");\n    for ($i = 0; $i &amp;lt; $hrefs-&gt;length; $i++) {\n        $href = $hrefs-&gt;item($i);\n        $linktext = $href-&gt;nodeValue;\n        echo $linktex;\n        echo \"&amp;lt;BR&gt;\";\n    }\n?&gt;\n</code></pre>\n\n<p>结果如下；</p>\n\n<p><img src=\"/content/images/2016/07/grab_link.png\" alt=\"\" /></p>\n\n<p>如果想要抓取博客中的“这里记载着帅气的博主的技术成长过程，也会时而发下生活的牢骚”，这几个字，把xpath改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//h2\");\n</code></pre>\n\n<p>如果想要抓取\"freestyle21\"几个字母，改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//a//h1\");\n</code></pre>\n\n<p>如果想要抓去最下面的描述“一个老男人,今年22岁.一枚程序员，Web前端！一只科蜜，季后赛！”，改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//ul//li\");\n</code></pre>\n\n<p>到此，要抓取给定网页的任意数据就比较简单了，最终任务转换到解析DOM。而这，又是没有前端都擅长的～</p>\n\n<h2 id=\"\">总结</h2>\n\n<p>总的来说，用这篇文章中的方法抓取数据都不是最科学的，因为我们必须要读取所以的HTML，这样效率肯定比较低。最科学的方式还是不用下到本地服务器，直接读取。以后有需求了，还是学下Python和Java的抓取方式～～</p>","image":"/content/images/2016/07/aa-2.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 14:19:55","created_by":1,"updated_at":"2016-07-09 14:27:57","updated_by":1,"published_at":"2013-05-04 14:19:00","published_by":1},{"id":73,"uuid":"8d653c85-9128-4f78-897d-64df8ace5df8","title":"路","slug":"road","markdown":"最近周围各种浮躁。\n\n工作、考研、出国，三择一，似乎每个大三的都要经历。虽然很早就决定了要工作，做喜欢的事，但也不免被这种世风所打扰。考研的寝室静不下，白天补习班，晚上继续游戏。工作的找实习，重拾基础，笔试题做到晚，简历投起。每天忙到晚，最后都不明白自己到底做了什么，曾经的那个梦哪去了？\n\n在夜深的时候，总是空虚的在想，自己到底在干什么，离自己的梦，是越近，还是越远？\n\n在迷茫的时候，总要停顿下来，思考自己所处的位置。\n\n升高中，老师说哪好，就去哪。大学，那个心碎的暑假，好像是老妈，决定了现在这个学校，至于专业更是由分数决定，甚至连是干嘛的都不知道。大一，周围的人都学技术，就跟风的和百川一起开始用DW拖页面，然后写android。一路走来，貌似都是由环境决定自己的路，呵呵，真悲剧。\n\n所幸，嫁对郎。\n\n进了梦飞，才真正认识了前端。很久以前，也和所有人一样，觉得前端就是一堆HTML和CSS、加点脚本的组合体，呵呵。有次和学长聊天，问我以后准备做什么，我说web前端。现在都还能想起他那复杂的表情，甚至有立马把我收入门下，做嵌入式的感觉。我只能呵呵，无力吐槽。不深入了解，就妄做判断的，都是对自己的不负责任。\n\n对于前端，只有深入了解，才能感受她的魅力。她交织着感性与理性，蕴含着广度和深度。要了解她，你必须有细腻的情感，有扎实的基础知识，有不定时发作的强迫症，有非常的逻辑思维，有迷恋新技术的固执，有源源不断的激情。试问，有几个人能做到？\n\n一入前端深似海。当你学习了html、css、js，你会发现还有jQuery、backbone、Bootstrap框架等方便一些，学了框架你会发现还有性能、可维护等比较难办，考虑了这些后你发现模块化、异步I/O等才是真正吸引你的....最后你发现这些离你想要的，所心动的还是那么远，又继续出发。所以，前端是一个你懂的越多，不懂的就越多的行业！\n\n前两天，爸妈和老姐也在询问以后的打算。因为一个亲戚儿子烟酒僧进国企，逆袭为省城人。还有也不知道谁和谁，给他们说考研怎么样怎么样，小本出去一无是处。接着他们便是轮流的教育，外面的世界不是想象的那么简单，继续读研去国企，才有保障。但是，不想和他们解释，这一次，我要自己做决定。\n\n最喜欢高三时不晓得哪个班的横幅：既然选择了远方，便只顾风雨兼程。\n\n回想一路走来，那么多人相伴。微博上Avenir、cohlint、Steve...。UESTC前端群里面一群文艺基情水人，前端乱炖里f2er的千姿百态，dreamfly的基羊、kerry、harold、Eddie、sumous、lmh3、wxp、unasm。还有颖姐，小马。或许10年以后，不会记得名字，但能相识已经满足。\n\n啰嗦了这么多，平静多了。\n\n工作之前，要多看点博客、好的文章，上课看经典的cs、js书，空了多研究点新的东西，有想法了把博客做好看点。","mobiledoc":null,"html":"<p>最近周围各种浮躁。</p>\n\n<p>工作、考研、出国，三择一，似乎每个大三的都要经历。虽然很早就决定了要工作，做喜欢的事，但也不免被这种世风所打扰。考研的寝室静不下，白天补习班，晚上继续游戏。工作的找实习，重拾基础，笔试题做到晚，简历投起。每天忙到晚，最后都不明白自己到底做了什么，曾经的那个梦哪去了？</p>\n\n<p>在夜深的时候，总是空虚的在想，自己到底在干什么，离自己的梦，是越近，还是越远？</p>\n\n<p>在迷茫的时候，总要停顿下来，思考自己所处的位置。</p>\n\n<p>升高中，老师说哪好，就去哪。大学，那个心碎的暑假，好像是老妈，决定了现在这个学校，至于专业更是由分数决定，甚至连是干嘛的都不知道。大一，周围的人都学技术，就跟风的和百川一起开始用DW拖页面，然后写android。一路走来，貌似都是由环境决定自己的路，呵呵，真悲剧。</p>\n\n<p>所幸，嫁对郎。</p>\n\n<p>进了梦飞，才真正认识了前端。很久以前，也和所有人一样，觉得前端就是一堆HTML和CSS、加点脚本的组合体，呵呵。有次和学长聊天，问我以后准备做什么，我说web前端。现在都还能想起他那复杂的表情，甚至有立马把我收入门下，做嵌入式的感觉。我只能呵呵，无力吐槽。不深入了解，就妄做判断的，都是对自己的不负责任。</p>\n\n<p>对于前端，只有深入了解，才能感受她的魅力。她交织着感性与理性，蕴含着广度和深度。要了解她，你必须有细腻的情感，有扎实的基础知识，有不定时发作的强迫症，有非常的逻辑思维，有迷恋新技术的固执，有源源不断的激情。试问，有几个人能做到？</p>\n\n<p>一入前端深似海。当你学习了html、css、js，你会发现还有jQuery、backbone、Bootstrap框架等方便一些，学了框架你会发现还有性能、可维护等比较难办，考虑了这些后你发现模块化、异步I/O等才是真正吸引你的....最后你发现这些离你想要的，所心动的还是那么远，又继续出发。所以，前端是一个你懂的越多，不懂的就越多的行业！</p>\n\n<p>前两天，爸妈和老姐也在询问以后的打算。因为一个亲戚儿子烟酒僧进国企，逆袭为省城人。还有也不知道谁和谁，给他们说考研怎么样怎么样，小本出去一无是处。接着他们便是轮流的教育，外面的世界不是想象的那么简单，继续读研去国企，才有保障。但是，不想和他们解释，这一次，我要自己做决定。</p>\n\n<p>最喜欢高三时不晓得哪个班的横幅：既然选择了远方，便只顾风雨兼程。</p>\n\n<p>回想一路走来，那么多人相伴。微博上Avenir、cohlint、Steve...。UESTC前端群里面一群文艺基情水人，前端乱炖里f2er的千姿百态，dreamfly的基羊、kerry、harold、Eddie、sumous、lmh3、wxp、unasm。还有颖姐，小马。或许10年以后，不会记得名字，但能相识已经满足。</p>\n\n<p>啰嗦了这么多，平静多了。</p>\n\n<p>工作之前，要多看点博客、好的文章，上课看经典的cs、js书，空了多研究点新的东西，有想法了把博客做好看点。</p>","image":"/content/images/2016/07/e.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 14:38:06","created_by":1,"updated_at":"2016-07-10 03:44:14","updated_by":1,"published_at":"2013-03-27 14:38:00","published_by":1},{"id":74,"uuid":"d545923d-05ca-4c0b-8051-22ca217914cb","title":"关于","slug":"about","markdown":"#About\n\n* 瞿宝明，网络中出现'fs21'、'freestyle21' 的地方都有我的足迹\n* 散打、篮球、及各种运动\n* CST@[uestc](http://www.uestc.edu.cn/) -> FE@[Dreamfly](http://dreamfly.org/) -> FE@[alibaba](http://www.alibaba.com/) -> FE@[DiDi](http://www.didichuxing.com)\n\n\n# History\n## #2012\n\n博客最早创建于2012年暑假，基于`github page`和`jekyll`，本以为会有精彩的人才感慨和技术生活，结果一开始就变成无所事事的网站。托管地址，[github](https://github.com/freestyle21/freestyle21.github.com)\n\n\n## #2014\n\n博客迁移到`wordpress`，托管在[庙](http://miao.in/)\n\n## #2016\n\n嫌弃够了`wordpress`的主题，做了迁移`Node`的准备，在[Hexo](https://hexo.io)和[Ghost](https://ghost.org/)中选择了[Ghost](https://ghost.org/)，主题来自 [andydoyle](https://github.com/andydoyle/blog-ghost-theme)，当然修改了不少。","mobiledoc":null,"html":"<h1 id=\"about\">About</h1>\n\n<ul>\n<li>瞿宝明，网络中出现'fs21'、'freestyle21' 的地方都有我的足迹</li>\n<li>散打、篮球、及各种运动</li>\n<li>CST@<a href=\"http://www.uestc.edu.cn/\">uestc</a> -> FE@<a href=\"http://dreamfly.org/\">Dreamfly</a> -> FE@<a href=\"http://www.alibaba.com/\">alibaba</a> -> FE@<a href=\"http://www.didichuxing.com\">DiDi</a></li>\n</ul>\n\n<h1 id=\"history\">History</h1>\n\n<h2 id=\"2012\">#2012</h2>\n\n<p>博客最早创建于2012年暑假，基于<code>github page</code>和<code>jekyll</code>，本以为会有精彩的人才感慨和技术生活，结果一开始就变成无所事事的网站。托管地址，<a href=\"https://github.com/freestyle21/freestyle21.github.com\">github</a></p>\n\n<h2 id=\"2014\">#2014</h2>\n\n<p>博客迁移到<code>wordpress</code>，托管在<a href=\"http://miao.in/\">庙</a></p>\n\n<h2 id=\"2016\">#2016</h2>\n\n<p>嫌弃够了<code>wordpress</code>的主题，做了迁移<code>Node</code>的准备，在<a href=\"https://hexo.io\">Hexo</a>和<a href=\"https://ghost.org/\">Ghost</a>中选择了<a href=\"https://ghost.org/\">Ghost</a>，主题来自 <a href=\"https://github.com/andydoyle/blog-ghost-theme\">andydoyle</a>，当然修改了不少。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-20 00:28:11","created_by":1,"updated_at":"2016-07-21 13:17:54","updated_by":1,"published_at":"2011-07-21 00:28:00","published_by":1},{"id":75,"uuid":"f6359f78-158b-45f0-bb06-bd365bf27708","title":"关于js修改三种css样式的方法","slug":"test-2","markdown":"晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。\n\n## 遇到的问题是：\n最开始在.css文件里面设置了图片的`position：absolute；`, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。\n\n之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。\n\n现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。\n\n## 深入\n怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。\n```\nfunction getDefaultStyle(obj,attribute){\n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n```\n或者：\n```\nfunction getDefault(obj){\n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n```\n例子：\n\n使用javascript更改某个css class的属性:\n```\n.orig {\n    display: none;\n}\n```\n你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：\n```\ndocument.styleSheets[0].rules[0].style.display = \"inline\";\n```\n在firefox里：\n```\ndocument.styleSheets[0].cssRules[0].style.display = \"inline\";\n```\n讨论： 可以做一个函数来搜索特定名字的style对象：\n```\nfunction getstyle(sname) {\n    for (var i=0;i< document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j< rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n```\n然后只要：\n```\ngetstyle(\".orig\").display = \"inline\";\n```\n## 总结：\n前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。\n\n在ie和firefox里面确实可以实现，不过我们不提倡。\n\n在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。\n\n所以，最好的方式还是直接修改dom里面的属性。\n\n弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。","mobiledoc":null,"html":"<p>晚上随便写了一个demo，要用js通过特定的方式来修改图片的定位，还有width和height等，完成预想的动画。</p>\n\n<h2 id=\"\">遇到的问题是：</h2>\n\n<p>最开始在.css文件里面设置了图片的<code>position：absolute；</code>, left等属性，现在想要把他的left设置为left -=left+temp；即要获取元素的left。</p>\n\n<p>之前没有细想，每次都是$(“img”).style.left就可以了，不过这次alert出来的居然是空字符串。</p>\n\n<p>现在想想 .style获取的应该是标签的style属性，然后依次获取其他子属性。所以.style.只能获取行内样式。。于是想方设法的去搞到.css里面的属性。</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>怎么才能获取 head中style的css 或者 .css文件中的属性呢？\nIE中使用的是obj.currentStyle方法，FF是用的是getComputedStyle 方法。  </p>\n\n<pre><code>function getDefaultStyle(obj,attribute){  \n    return obj.currentStyle ? obj.currentStyle[attribute] : document.defaultView.getComputedStyle(obj,false)[attribute];\n}\n</code></pre>\n\n<p>或者：</p>\n\n<pre><code>function getDefault(obj){  \n    return obj.currentStyle ? obj.currentStyle\n        :document.defaultView.getComputedStyle(obj,false);\n}\n</code></pre>\n\n<p>例子：</p>\n\n<p>使用javascript更改某个css class的属性:</p>\n\n<pre><code>.orig {\n    display: none;\n}\n</code></pre>\n\n<p>你想要改变把他的display属性由none改为inline。\n解决办法： \n在IE里：</p>\n\n<pre><code>document.styleSheets[0].rules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>在firefox里：</p>\n\n<pre><code>document.styleSheets[0].cssRules[0].style.display = \"inline\";  \n</code></pre>\n\n<p>讨论： 可以做一个函数来搜索特定名字的style对象：</p>\n\n<pre><code>function getstyle(sname) {  \n    for (var i=0;i&lt; document.styleSheets.length;i++) {\n        var rules;\n        if (document.styleSheets[i].cssRules) {\n            rules = document.styleSheets[i].cssRules;\n        } else {\n            rules = document.styleSheets[i].rules;\n        }\n        for (var j=0;j&lt; rules.length;j++) {\n            if (rules[j].selectorText == sname) {\n                return rules[j].style;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>然后只要：</p>\n\n<pre><code>getstyle(\".orig\").display = \"inline\";  \n</code></pre>\n\n<h2 id=\"\">总结：</h2>\n\n<p>前面说的是怎样查询或修改外链的.css，不过，不行的是，我们不能这样做。</p>\n\n<p>在ie和firefox里面确实可以实现，不过我们不提倡。</p>\n\n<p>在chrome里面的cssRules会是null，stackoverflow里面说的是跨域，不过也不存在吧。</p>\n\n<p>所以，最好的方式还是直接修改dom里面的属性。</p>\n\n<p>弄了一晚上，算是弄得比较明白了。有些细节要去追究一下，才能得到更多的东西。虽然自己想要的没有得到，不过却可以得到很多收获。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-14 15:29:43","created_by":1,"updated_at":"2016-07-19 14:13:59","updated_by":1,"published_at":"2012-10-22 15:30:00","published_by":1},{"id":76,"uuid":"2f69b803-fcce-494d-a7dd-32380a856a75","title":"学会使用chrome的F12","slug":"learn-chrome-f12-2","markdown":"学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~\n\n用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。\n\n折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）\n\n## Network工具\nchrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。\n \n![](/content/images/2016/06/network1.jpg)\n \n![](/content/images/2016/06/network2.jpg)\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。\n\n## Timeline\n注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：\n\n![](/content/images/2016/06/timeline.jpg)\n在上面点击后再点击红色的圆圈就可以了。\n## Profiles\n\n![](/content/images/2016/06/profile-1.jpg)\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU）\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 \n\n后面的学会了在更新~\n","mobiledoc":null,"html":"<p>学习前端以来，chrome一直都是最忠实的朋友，至于firefox和opera等都是传说中的东西，觉得他们的调试功能不太好看（不是不好=；=）。。所以，还是最钟情于chrome~</p>\n\n<p>用F12开发者工具从来都是用那里两个东西，Elements，Resources还有Sources，console这几个。其他的都不咋用。</p>\n\n<p>折腾了一晚上F12，总结一下学到的东西，最有意思的是性能分析的神马东西了。。（刚完的一个项目就是因为加载时间耗了好久，早就想好好学下咯）</p>\n\n<h2 id=\"network\">Network工具</h2>\n\n<p>chrome很智能，他会自动记录各个文件请求返回和等待的时间（貌似大名鼎鼎的firebug也有），不过点击过后需要刷新一下页面。</p>\n\n<p><img src=\"/content/images/2016/06/network1.jpg\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2016/06/network2.jpg\" alt=\"\" />\n上面的4.3s就是从第一个请求道页面全部渲染结束所花费的时间。</p>\n\n<h2 id=\"timeline\">Timeline</h2>\n\n<p>注意这个Timeline的标签页不是指网络请求的时间响应情况哦（这个在Network标签页里查看），这个Timeline指的js执行时间、页面元素渲染时间：</p>\n\n<p><img src=\"/content/images/2016/06/timeline.jpg\" alt=\"\" />\n在上面点击后再点击红色的圆圈就可以了。</p>\n\n<h2 id=\"profiles\">Profiles</h2>\n\n<p><img src=\"/content/images/2016/06/profile-1.jpg\" alt=\"\" />\n这个工具可以分析js中每个函数执行的时间百分比。\n提供了三种：javascript cpu 性能测试 （显示javascript占用了多少CPU）\ncss选择器性能测试（显示处理CSS选择器占用的CPU） <br />\n堆栈快照 （显示javascript对象的内存占用情况）\n使用步骤如下：点击javascript cpu profile然后run。 </p>\n\n<p>后面的学会了在更新~</p>","image":"","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"学习chrome的F12","meta_description":"本文介绍在前端学习工作中，使用到的chrome 控制台的一些调试方法，包括Network工具、timeline、Profiles等。","author_id":1,"created_at":"2016-06-16 15:14:27","created_by":1,"updated_at":"2016-07-19 14:13:48","updated_by":1,"published_at":"2012-12-15 15:21:00","published_by":1},{"id":77,"uuid":"4d6da924-1e41-4473-bd73-de3078d5da99","title":"淘宝UED的前端招聘测试题","slug":"taobao-f2e-test-2","markdown":"## 引言\n\n最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。\n\n中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 \n\n时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。\n\n不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。\n\n小测试是这样的：就是把以前的radio变成图片。\n\n![](/content/images/2016/06/question.jpg)\n\n码代码之前先分析一下：\n\nradio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。\n\n## 实现\n\n下面是具体实现：\n```\n<form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'>\n    <fieldset>\n        <legend>MyValue</legend>\n\n        <div class = 'radioColorParent'>\n            <input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked> 棕色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"> 黄色\n            <input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"> 紫红色\n        </div>\n\n\n    &lt;div class = 'picColor'&gt; \n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;                  \n          &lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n          &lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&gt;   \n          &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n          &lt;/div&gt;\n        &lt;div class = 'picColorImgParent'&gt; \n         &lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&gt;          \n         &lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;input type=\"submit\" value='submit'&gt;\n&lt;/fieldset&gt;\n\n\n</form>\n```\n \n以上就是实现基本的html代码，把几个为radio的input隐藏了。\n`css：`\n```\n.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{\n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{\n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n```\n把radio的input隐藏了，然后设置点边框。 贴下js代码：\n```\n$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();\nusercolorselect.init($('.picColorImgParent'));\nusercolorselect.changeStyle();\nusercolorselect.updateRadio();\n\n\n});\n```\n上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：\n\n![](/content/images/2016/06/final.jpg)\n\n兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~\n\n最后代码都放在了[github](https://github.com/freestyle21/taobaoUEDTest)上面，欢迎吐槽。","mobiledoc":null,"html":"<h2 id=\"\">引言</h2>\n\n<p>最近考试完了，总算有时间做自己喜欢的事情，最嗨皮的是三天学了一学期的，居然全过了，(～ o ～)~zZ，关于上课和学习，从来都不觉得课堂上能够学到能用了，还是自己看最靠谱。。</p>\n\n<p>中午吃完饭后习惯性的浏览收藏夹里面的博客。不过似乎要过年了，F2Eer都变懒了~ taobaoUED有了更新，这个团队都是走在业界的前沿，每次都是最先尝试别人不愿意试的技术，赞~(≧▽≦)/~。 </p>\n\n<p>时光星球那个做的很炫，用SVG画的那些小星星，js控制的opacity。不过性能感觉略低，CPU从来没有下40%；还有下面还报了unsafe Javascript的错误，应该是父窗口有把Domain,protocol,port之类的改了，然后子窗口得不到父窗口的句柄。</p>\n\n<p>不过总体上还是很赞的~ 顺着首页进去，招聘的flash很简洁，很有新意~直接跳过交互和视觉，看了下前端的招聘。</p>\n\n<p>小测试是这样的：就是把以前的radio变成图片。</p>\n\n<p><img src=\"/content/images/2016/06/question.jpg\" alt=\"\" /></p>\n\n<p>码代码之前先分析一下：</p>\n\n<p>radio不能加背景或图片，所以要实现上面这个效果，只能通过js控制dom样式来实现；要保证后端的同学能够得到用户的点击结果，所以带有radio的form又是不能少的，所有这里我们把它隐藏了。稍有难度的就是点击过后的红色边框效果，右下角有一个红色的勾。第一反应是把外围的红色看成一幅图，当成外围div的background。不过这样有一个问题，就是图片会把父div右下角勾挡住。最后决定把右下角的勾单独当成一个图片，然后定位到带有红色border的img右下角。当然也可以用svg或canvas来画出右下角的勾，不过这样兼容性又是各种蛋疼，先还是把图片的实现吧。</p>\n\n<h2 id=\"\">实现</h2>\n\n<p>下面是具体实现：</p>\n\n<pre><code>&lt;form action = \"./test2.html\" method = 'post' name ='userColorForm' class='userColorForm'&gt;  \n    &lt;fieldset&gt;\n        &lt;legend&gt;MyValue&lt;/legend&gt;\n\n        &lt;div class = 'radioColorParent'&gt;\n            &lt;input class = 'radioColor' type = \"radio\" name =  \"userColor\" value = \"brown\" checked&gt; 棕色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"yellow\"&gt; 黄色\n            &lt;input class = 'radioColor' type = \"radio\" name = \"userColor\" value = \"purplishRed\"&gt; 紫红色\n        &lt;/div&gt;\n\n\n    &amp;lt;div class = 'picColor'&amp;gt; \n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;                  \n          &amp;lt;img class = 'picColorTriangle' src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n          &amp;lt;img class = 'picColorImg' src = \"1.jpg\" alt = \"\"&amp;gt;   \n          &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n          &amp;lt;/div&amp;gt;\n        &amp;lt;div class = 'picColorImgParent'&amp;gt; \n         &amp;lt;img class = 'picColorImg' src = \"3.jpg\" alt = \"\"&amp;gt;          \n         &amp;lt;img class = 'picColorTriangle'src=\"picColorTriangle.png\" alt=\"\"&amp;gt;\n        &amp;lt;/div&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;input type=\"submit\" value='submit'&amp;gt;\n&amp;lt;/fieldset&amp;gt;\n\n\n&lt;/form&gt;  \n</code></pre>\n\n<p>以上就是实现基本的html代码，把几个为radio的input隐藏了。\n<code>css：</code></p>\n\n<pre><code>.userColorForm fieldset{\n      border: none;\n}\n.userColorForm legend{\n      display: none;\n}\n\n\n.radioColorParent{\n      display: none;\n}\n.picColor{\n      overflow: hidden;\n}\ndiv.picColorImgParent{  \n      float: left;\n      padding-left: 10px;\n      cursor: pointer;\n      position: relative;\n}\n.picColorImg{\n      width: 32px;\n      height: 32px;\n      border: 1px #c8c9cd solid;\n}\nimg.picColorSelect{  \n      border: 2px #c40008 solid;\n      border-top: 1px #c40008 solid;\n}\n.picColorTriangle{\n      position: absolute;\n      bottom: 4px;\n      right: 0px;\n      display: none;\n}\n</code></pre>\n\n<p>把radio的input隐藏了，然后设置点边框。 贴下js代码：</p>\n\n<pre><code>$(document).ready(function(){\n    var UserColorSelect = function(){};\n    UserColorSelect.prototype = {\n        init: function(obj){\n            this.obj = obj;\n              this.obj.eq(0).find('img').eq(0)\n                    .addClass('picColorSelect');\n\n                    this.obj.eq(0).find('img').eq(1).css('display', 'inline-block');\n        },\n        //传入一个div对象，然后对他的两个img元素进行操作。\n        changeStyle: function(){\n          if(this.obj){\n            this._obj.click(function(){\n             var $OldParent = $('.picColorSelect').parent();\n             if($OldParent !== this){\n                  //处理上一个picColorSelect\n                     $OldParent.find('img').eq(0)\n                          .removeClass('picColorSelect');\n\n\n                 $OldParent.find('img').eq(1)\n                      .css('display','none');\n              //更新现在点的。\n                   $(this).find('img').eq(0)\n                        .addClass('picColorSelect');\n                   $(this).find('img').eq(1)\n                        .css('display','inline-block');    \n          }\n         });\n        }\n    },\n    updateRadio:function(){\n      if(this._obj){\n          this._obj.click(function(){\n            var whichNum = $(this).index();\n              $('.radioColor').eq(whichNum)\n                  .attr('checked','true');\n           });\n      }\n    }\n}\n\nusercolorselect = new UserColorSelect();  \nusercolorselect.init($('.picColorImgParent'));  \nusercolorselect.changeStyle();  \nusercolorselect.updateRadio();\n\n\n});\n</code></pre>\n\n<p>上面的js代码中有一点需要注意，就是在点击事件中，一定要判断当前的div和上一个picColorSelect Div是否一样，可以节约一点点时间和空间。当然if（this._obj）是为了防止代码被乱拷，然后就不知怎么就崩了。。\n在test2.html中可以看到传过去的值是正确的：</p>\n\n<p><img src=\"/content/images/2016/06/final.jpg\" alt=\"\" /></p>\n\n<p>兼容性方面，用的jquery，基本上没有什么问题；css中没有margin，自然也灭有ie6下的双边距。最后再ie6,7,8都测了，都没有问题~</p>\n\n<p>最后代码都放在了<a href=\"https://github.com/freestyle21/taobaoUEDTest\">github</a>上面，欢迎吐槽。</p>","image":"/content/images/2016/06/c.jpeg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-16 15:22:08","created_by":1,"updated_at":"2016-07-19 14:12:53","updated_by":1,"published_at":"2013-01-15 15:26:00","published_by":1},{"id":78,"uuid":"e7a4abc9-8747-45c5-835a-020ab0aba8e2","title":"邂逅Jekyll","slug":"learn-jekyll-2","markdown":"![](/content/images/2016/06/jekyll.png)\n\n### config.yml\n\n保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 \n\n比如里面写:\n```\ndescription:      \"freestyle21\\'s Blog\"\n```\n\n那么我们在源码中就可以通过下面这种方式去访问了：\n```\nsite.description\nincludes\n```\n该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。\n### layouts\n该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。\n\n### posts\n\n该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 `year-month-date-title.markdown`。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。\n\n### site\n\n这里是`Jekyll`用以存放最终代码生成站点的根路径位置。也许把它加到你的`.gitignore`列表中会是个不错的主意。这个文件夹是`Jekyll`自动生成的，所以我们一般不用管。\n\n### 其他文件/目录\n\n除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。\n\n## windows搭建Jekyll本地测试环境\n\n你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。\n\n不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 \n\n于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。\n\n看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：\n\n## 安装Jekyll\n\nJekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。\n\n下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)\n\n下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe\n\nRubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。\n\n解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令\n```\nRuby dk.rb init\nRuby dk.rn install\n```\nDevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。\n\n下面就可以安装Jekyll了：\n```\ngem install Jekyll\n```\n\n等待。。。这个时候不要关闭Git Bash。\n\n最后，我们可以检查一下安装Jekyll成功没有：\n\n```\nJekyll --version\n```\n\n如果输出下面的结果就说明我们成功了。。\n```\nJekyll 0.12.0\n```\n\n接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n`C:\\Users\\Administrator`\n这个目录下面：\n```\ngit clone git://github.com./freestyle21/freestyle21.github.com.git\n```\n然后进入刚才的目录里面：\n```\ncd freestyle21.github.com\n```\n执行：\n```\nJekyll --server --auto\n```\n如下如：\n```\nserverauto\n```\n最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。\n\n一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。\n\n现在记录一下遇到的错误，以后不要在这里耽误时间了。\n\n>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”\n\n编码问题，直接在path里面添加：`LCALL=enUS.UTF-8` 和 `LANG=en_US.UTF-8`然后重启或者注销。\n\n还是不行的话就将 `convertible.rb` 的第29行改为：\n```\nself.content = File.read(File.join(base, name), :encoding => \"utf-8\")\n ```\n>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown\n \n首先可以尝试一下更新`Pygments`， 把python里面的script目录加载path里面，然后就可以直接通过`easy_install Pygments`来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/06/jekyll.png\" alt=\"\" /></p>\n\n<h3 id=\"configyml\">config.yml</h3>\n\n<p>保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。 </p>\n\n<p>比如里面写:</p>\n\n<pre><code>description:      \"freestyle21\\'s Blog\"  \n</code></pre>\n\n<p>那么我们在源码中就可以通过下面这种方式去访问了：</p>\n\n<pre><code>site.description  \nincludes  \n</code></pre>\n\n<p>该目录存放可以与layouts和posts混合、匹配并重用的文件。 用的不多，没有深入接触。</p>\n\n<h3 id=\"layouts\">layouts</h3>\n\n<p>该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。这个用的特多，可以大大减少代码量。</p>\n\n<h3 id=\"posts\">posts</h3>\n\n<p>该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 <code>year-month-date-title.markdown</code>。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。</p>\n\n<h3 id=\"site\">site</h3>\n\n<p>这里是<code>Jekyll</code>用以存放最终代码生成站点的根路径位置。也许把它加到你的<code>.gitignore</code>列表中会是个不错的主意。这个文件夹是<code>Jekyll</code>自动生成的，所以我们一般不用管。</p>\n\n<h3 id=\"\">其他文件/目录</h3>\n\n<p>除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 css ,js,img目录，一个 favicon.ico ，等等等等。</p>\n\n<h2 id=\"windowsjekyll\">windows搭建Jekyll本地测试环境</h2>\n\n<p>你可以修改了代码，然后上传到github上面去，然后在刷新刷新看刚才改动的效果。</p>\n\n<p>不过如果能够坚持调试下来的不是大牛就是高富帅=-=。 </p>\n\n<p>于是在本地测试就师出有名了，改好了再上传到github上面，事半功倍。</p>\n\n<p>看了好多别人写的博客，不过都没有一次成功的，为了方便同仁和自己，把自己的过程记录下来吧。。中间遇到好多问题，反正各种google、stackoverflow。做好过后，那些问题也都忘了怎么解决的了，所以事后写博客质量不是很好，=-=||..好了，少扯蛋，多做事：</p>\n\n<h2 id=\"jekyll\">安装Jekyll</h2>\n\n<p>Jekyll使用Ruby编写的，所以要先配置Ruby环境，通过Ruby安装Jekyll。</p>\n\n<p>下载RubyInstaller，(我下载的是rubyinstaller-1.9.3-p194.exe)</p>\n\n<p>下载 DevKit(下载的是DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</p>\n\n<p>RubyInstaller安装开始的时候，有三个多选按钮，都选上~path神马的都会自动加上，不用担心。</p>\n\n<p>解压DevKit，然后打开cmd，进入刚才的DevKit解压目录，输入以下命令</p>\n\n<pre><code>Ruby dk.rb init  \nRuby dk.rn install  \n</code></pre>\n\n<p>DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。</p>\n\n<p>下面就可以安装Jekyll了：</p>\n\n<pre><code>gem install Jekyll  \n</code></pre>\n\n<p>等待。。。这个时候不要关闭Git Bash。</p>\n\n<p>最后，我们可以检查一下安装Jekyll成功没有：</p>\n\n<pre><code>Jekyll --version  \n</code></pre>\n\n<p>如果输出下面的结果就说明我们成功了。。</p>\n\n<pre><code>Jekyll 0.12.0  \n</code></pre>\n\n<p>接下来读者朋友可以把我的博客clone到本地，一般都clone到在\n<code>C:\\Users\\Administrator</code>\n这个目录下面：</p>\n\n<pre><code>git clone git://github.com./freestyle21/freestyle21.github.com.git  \n</code></pre>\n\n<p>然后进入刚才的目录里面：</p>\n\n<pre><code>cd freestyle21.github.com  \n</code></pre>\n\n<p>执行：</p>\n\n<pre><code>Jekyll --server --auto  \n</code></pre>\n\n<p>如下如：</p>\n\n<pre><code>serverauto  \n</code></pre>\n\n<p>最后就是检验成果的时候了，在浏览器中输入：localhost:4000,就可以看到你的页面在本地跑起来了。。 这样以后调试就方便多了，在代码中修改后，只要ctrl+s保存一下，jekyll就会自动在浏览器里面更新了。。</p>\n\n<p>一般都在github里面写代码的，很久没有在本地调试了，这几天有点想法，想把博客改变一下样子。但是这次居然jekyll居然不听话了，各种报错，然后就是不断的找错误。。</p>\n\n<p>现在记录一下遇到的错误，以后不要在这里耽误时间了。</p>\n\n<blockquote>\n  <p>问题： Liquid error: incompatible character encodings: UTF-8 and IBM437”</p>\n</blockquote>\n\n<p>编码问题，直接在path里面添加：<code>LCALL=enUS.UTF-8</code> 和 <code>LANG=en_US.UTF-8</code>然后重启或者注销。</p>\n\n<p>还是不行的话就将 <code>convertible.rb</code> 的第29行改为：\n<code>\nself.content = File.read(File.join(base, name), :encoding =&gt; \"utf-8\") <br />\n</code></p>\n\n<blockquote>\n  <p>问题： Liquid Exception: No such file or directory - python c:/Ruby193/lib/ruby/gems/1.9.1/gems/pygments.rb-0.3.7/lib/pygments/mentos.py in 2013-01-06-octopress.markdown</p>\n</blockquote>\n\n<p>首先可以尝试一下更新<code>Pygments</code>， 把python里面的script目录加载path里面，然后就可以直接通过<code>easy_install Pygments</code>来安装了。\n其次Pygments是通过python来工作的，所以还要安装python。需要注意的是一定要把python的路径加到path下面。</p>","image":"/content/images/2016/06/cover_2016-6.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"学习jekyll","meta_description":"本文介绍jekyll的配置，用法，和应用。","author_id":1,"created_at":"2016-06-16 15:28:19","created_by":1,"updated_at":"2016-07-19 14:12:36","updated_by":1,"published_at":"2013-03-02 15:34:00","published_by":1},{"id":79,"uuid":"7982dcda-2a88-4e36-a91a-3dd60d99c89c","title":"从jQuery学细节","slug":"learn-from-jquery-2","markdown":"前言\n\n最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。\n\n![](/content/images/2016/06/john.png)\n\n看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~\n\n研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~\n\n现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。\n## jQuery的细节技巧\n\n### 巧用条件运算符\n```\ntrim: trim ?\n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n```\n \n这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：\n\n```\ndata = data === \"true\" ? true :\n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {}\n```\n多用点这种技巧，就不用满屏幕都是if & else 了。代码会变得简洁，轻巧。\n\n### jQuery的循环遍历技巧\n\n下面列出一些自己看出的、常见的、平时代码中常用的循环技巧\n\n1、\n```\n// 简单的for-in（事件） \nfor ( type in events ) { \n}\n```\n\n2、\n```\n// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j < l; j++ ) { \n}\n```\n3、\n```\n// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem; \nfor ( var i = 0; elems[i]; i++ ) { \n    elem = elems[i]; \n    // ... \n}\n```\n4、\n```\n// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j < eventType.length; j++ ) { \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i < results.length; i++ ) { \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n```\n这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！\n\n5、\n```\n// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j < eventType.length; j++ ) { \n}\n```\n6、\n```\n//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) { \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n```\n7、\n```\n// while检查下标i \nvar i = arr.length; \nwhile( i-- ) { \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n```\n通过闭包，返回前一作用域的参数\n```\n// 闭包。返回的函数保持对guid的引用。\nfunction a(){\n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();\n```\n一次实现多种方法\n```\nif ( rfxtypes.test(val) ) {\n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n```\n条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：\n\n```\njQuery.each([\"live\", \"die\"], function( i, name ) {\n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" && !types &&\n                    origSelector && origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n```\n一次性实现两个方法。。\n\n```\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length > 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n```\n通过each方法，实现n多方法。到此，除了惊叹还是惊叹。\n\n### 实例化jQuery对象\n\n先看代码：\n```\njQuery = function( selector, context ) {\n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n```\n这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;\n\n因此可以直接调用jQuery( selector, context )，没有必要使用new关键字\n\n还有一行代码如下：\n\n```\njQuery.fn.init.prototype = jQuery.fn = jQuery.prototype\n```\n\n所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。\n\n这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：\n\n```\n//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {\n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"<a>hello</a>\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError\n```\n在源码中，经常看到这样的代码：\n\n```\nargs = args || [];\n```\n\n这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。\n\n比如我们还可以看到这样的：\n\n```\nisArray: Array.isArray || function( obj ) {\n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;\n```\n \n在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架\n\n```\n(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n```\n \n### 结语\n\n以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~\n\n总之每看一次，都会有很大的收获，成长。\n\n最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。\n\n离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。\n","mobiledoc":null,"html":"<p>前言</p>\n\n<p>最近看了两遍jQuery源码，感觉只是看懂了jQuery的小部分小部分，不过仅此，就已经对john resig佩服的五体投地咯。。\n下面附上这位帅哥的靓照，记住吧，是他改变了世界。</p>\n\n<p><img src=\"/content/images/2016/06/john.png\" alt=\"\" /></p>\n\n<p>看的大多是实现的细节、技巧，整体的架构还是没有看出来。功力不够呀，还得慢慢修炼。jQuery真的是值得去读无数次的东西，每读一次，都会有不一样的收获。以后有空就多看看吧~</p>\n\n<p>研读优秀框架的源码，是从初级jser进阶到中级jser的捷径，可以学到好多优秀代码的风格。从代码可以看出一个程序员的水平呀~</p>\n\n<p>现在把自己看出来的一些帅呆了的技巧，细节记录下来，一起分享。</p>\n\n<h2 id=\"jquery\">jQuery的细节技巧</h2>\n\n<h3 id=\"\">巧用条件运算符</h3>\n\n<pre><code>trim: trim ?  \n        function( text ) {\n            return text == null ?\n                \"\" :\n                trim.call( text );\n        } :\n        function( text ) {\n            return text == null ?\n                \"\" :\n                text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    }\n</code></pre>\n\n<p>这里用了一个条件运算符，如果String.trim存在的话就用，不存在就用自己实现的trim函数。在jQuery的源码中，用了大量的这种技巧,比如：</p>\n\n<pre><code>data = data === \"true\" ? true :  \n    data === \"false\" ? false :\n    data === \"null\" ? null :\n    !jQuery.isNaN( data ) ? parseFloat( data ) :\n        rbrace.test( data ) ? jQuery.parseJSON( data ) : data;\nfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i &lt; max; i++ ) {}  \n</code></pre>\n\n<p>多用点这种技巧，就不用满屏幕都是if &amp; else 了。代码会变得简洁，轻巧。</p>\n\n<h3 id=\"jquery\">jQuery的循环遍历技巧</h3>\n\n<p>下面列出一些自己看出的、常见的、平时代码中常用的循环技巧</p>\n\n<p>1、  </p>\n\n<pre><code>// 简单的for-in（事件） \nfor ( type in events ) {  \n}\n</code></pre>\n\n<p>2、  </p>\n\n<pre><code>// 缓存length属性，避免每次都去查找length属性，稍微提升遍历速度 \nfor ( var j = 0, l = arrow.length; j &lt; l; j++ ) {  \n}\n</code></pre>\n\n<p>3、  </p>\n\n<pre><code>// 不比较下标，直接判断元素是否为true（强制类型转换） \nvar elem;  \nfor ( var i = 0; elems[i]; i++ ) {  \n    elem = elems[i]; \n    // ... \n}\n</code></pre>\n\n<p>4、  </p>\n\n<pre><code>// 遍历动态数组（事件），不能缓存length属性，j++之前先执行j--\nfor ( j = 0; j &lt; eventType.length; j++ ) {  \n    eventType.splice( j--, 1 ); \n} \nfor ( var i = 1; i &lt; results.length; i++ ) {  \n    if ( results[i] === results[ i - 1 ] ) { \n        results.splice( i--, 1 ); \n    } \n}\n</code></pre>\n\n<p>这个细节要注意哈，稍不注意就会在这里折腾很久。动态数组不能缓存！</p>\n\n<p>5、  </p>\n\n<pre><code>// 迭代过程中尽可能减少遍历次数（事件），从pos开始\nfor ( j = pos || 0; j &lt; eventType.length; j++ ) {  \n}\n</code></pre>\n\n<p>6、  </p>\n\n<pre><code>//倒序遍历，有利于浏览器优化，稍微提升遍历速度 \nfor ( var i = this.props.length, prop; i; ) {  \n    prop = this.props[ --i ]; \n    event[ prop ] = originalEvent[ prop ]; \n}\n</code></pre>\n\n<p>7、  </p>\n\n<pre><code>// while检查下标i \nvar i = arr.length;  \nwhile( i-- ) {  \n    obj[ arr[i] ] = deferred[ arr[i] ]; \n}\n</code></pre>\n\n<p>通过闭包，返回前一作用域的参数</p>\n\n<pre><code>// 闭包。返回的函数保持对guid的引用。\nfunction a(){  \n    var guid = 1;\n    return function(){\n        return guid++;\n    }\n}\nvar defer = a();  \n</code></pre>\n\n<p>一次实现多种方法</p>\n\n<pre><code>if ( rfxtypes.test(val) ) {  \n    // 如果是toggle，则判断当前是否hidden，如果hidden则show，否则hide\n    // 如果不是toggle，说明val是hide/show之一\n    e val === \"toggle\" ? (hidden ? \"show\" : \"hide\") : val ;\n\n} else {。。。}\n</code></pre>\n\n<p>条件运算符 + 关联数组 一次实现三种方法，帅呆了！不过貌似这种方法平时用的不多。\n同样的思想还有一处：</p>\n\n<pre><code>jQuery.each([\"live\", \"die\"], function( i, name ) {  \n    jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {\n        if ( name === \"die\" &amp;&amp; !types &amp;&amp;\n                    origSelector &amp;&amp; origSelector.charAt(0) === \".\" ) {\n            context.unbind( origSelector );\n            return this;\n        }\n        //....\n        return this;\n    };\n});\n</code></pre>\n\n<p>一次性实现两个方法。。</p>\n\n<pre><code>jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +  \n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) {\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n       return arguments.length &gt; 0 ?\n           this.bind( name, data, fn ) :\n           this.trigger( name );\n    };\n    // 将事件名注册（添加）到jQuery.attrFn，当遇到对同名属性的操作时，转换为对事件接口的调用\n    if ( jQuery.attrFn ) {\n       jQuery.attrFn[ name ] = true;\n    }\n});\n</code></pre>\n\n<p>通过each方法，实现n多方法。到此，除了惊叹还是惊叹。</p>\n\n<h3 id=\"jquery\">实例化jQuery对象</h3>\n\n<p>先看代码：</p>\n\n<pre><code>jQuery = function( selector, context ) {  \n    return new jQuery.fn.init( selector, context, rootjQuery );\n}\n</code></pre>\n\n<p>这里jQuery对象就是jQuery.fn.init对象\n如果执行new jQuery(),生成的jQuery对象会被抛弃，最后返回 \njQuery.fn.init对象;</p>\n\n<p>因此可以直接调用jQuery( selector, context )，没有必要使用new关键字</p>\n\n<p>还有一行代码如下：</p>\n\n<pre><code>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype  \n</code></pre>\n\n<p>所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery 函数上（一开始的 jQuery = function( selector, context ) ），但是最后都相当于挂载到了 \njQuery.fn.init.prototype，即相当于挂载到了一开始的jQuery 函数返回的对象上，即挂载到了我们最终使用的jQuery对象上。</p>\n\n<p>这里的init函数里面执行了，我们平时接触具多的选择器。简单分析如下：</p>\n\n<pre><code>//如果传入一个DOM元素。。包装成jQuery对象，直接返回。\nif ( selector.nodeType ) {  \n    this.context = this[0] = selector;\n    this.length = 1;\n    return this;\n}\n//如果传入一个字符串\n    //如果字符串时一个类似\"&lt;a&gt;hello&lt;/a&gt;\"样子的，直接生成。\n    //传入ID，直接document.getElementById()，然后包装成jQuery对象。\n//选择器表达式，find...\n//如果传入函数，则为ready开始\njQuery 巧妙避免ReferenceError  \n</code></pre>\n\n<p>在源码中，经常看到这样的代码：</p>\n\n<pre><code>args = args || [];  \n</code></pre>\n\n<p>这样可以确保args可用，一个避免null，underfined造成的ReferenceError的常见技巧。</p>\n\n<p>比如我们还可以看到这样的：</p>\n\n<pre><code>isArray: Array.isArray || function( obj ) {  \n    return jQuery.type(obj) === \"array\";\n}//这里和上面的条件运算符效果差不多。\nname = jQuery.cssProps[ origName ] || origName;  \n</code></pre>\n\n<p>在很多需要传入选项对象的函数中，如果用户自己传入，就用用户传进的；如果用户没有传值，则用开发者默认的参数。这样的代码很帅气有木有！\njQuery的实现框架</p>\n\n<pre><code>(function( window, undefined ) {\n\n    // 构造jQuery对象\n    var jQuery = function( selector, context ) {\n            return new jQuery.fn.init( selector, context, rootjQuery );\n        }\n    // 工具函数 Utilities\n    // 异步队列 Deferred\n    // 浏览器测试 Support\n    // 数据缓存 Data\n    // 队列 queue\n    // 属性操作 Attribute\n    // 事件处理 Event\n    // 选择器 Sizzle\n    // DOM遍历\n    // DOM操作\n    // CSS操作\n    // 异步请求 Ajax\n    // 动画 FX\n    // 坐标和大小\n    window.jQuery = window.$ = jQuery;\n\n\n})(window);\n</code></pre>\n\n<h3 id=\"\">结语</h3>\n\n<p>以上分析，都只是jQuery的一些皮毛，还有很多很多没有发现，以后有时间，有机会再研究咯~</p>\n\n<p>总之每看一次，都会有很大的收获，成长。</p>\n\n<p>最近状态不好，做事效率很低。以后看书码代码的时候，要关了qq，微博，河畔。。。</p>\n\n<p>离开用心，新的开始。虽然很多不舍，但必须面对，做出选择。对于有些人，应该就是永远不见，有些人，真舍不得。\n做喜欢的事，做好喜欢的事。</p>","image":"/content/images/2016/06/road-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"从jQuery学习细节","meta_description":"本文从jQuery源码中分析精华部分，学习作者的写作思路，代码风格等。","author_id":1,"created_at":"2016-06-16 15:51:22","created_by":1,"updated_at":"2016-07-19 14:14:21","updated_by":1,"published_at":"2012-10-15 15:26:00","published_by":1},{"id":80,"uuid":"9081bf24-12eb-41ec-becf-28b6ca9902e8","title":"浅谈JavaScript的语言特性","slug":"javascript-feature-2","markdown":"## 前言\n\n在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。\n\n本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下[权威指南](http://book.douban.com/subject/10549733)~\n\n参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：\n\n[http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/](http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/)\n\n[http://benalman.com/news/2010/11/immediately-invoked-function-expression/](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n[http://dmitrysoshnikov.com/ecmascript/javascript-the-core/](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)\n\n## 语言特性\n\n### 函数表达式\n\n先看代码段：\n\n```\nvar f = function foo(){\n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"\nf(); // \"function\"</pre>\n```\n\n这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。\n\n### json \n\n很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。\n\nJSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。\n\n`{ \"prop\": \"val\" }` 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。\n\n如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。\n\n```\n// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };\n```\n\n还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。\n\n老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。\n\n### 原型 \n\n```\nfunction Animal (){ \n// ...\n}\nfunction cat (){ \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。\ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;\n```\n如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：\n\n```\nfunction A() {}\n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // false!\n```\n\n让我们一起看下MDN上关于constructor的 [解释](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor)\n\n```\nprototype：Returns a reference to the Object function that created the instance's prototype.\n```\n因此，对函数的原型引用需要手工恢复：\n\n```\nfunction A() {}\n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();\nalert(a.x); // 10\nalert(a.constructor === A); // true\n```\n\n然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。\n\n```\nfunction A() {}\nA.prototype.x = 10;\n\nvar a = new A();\nalert(a.x); // 10\n\nA.prototype = {\n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10\nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20\nalert(b.y) // 30\n\n```\n\n因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。\n\n这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。\n\n### 变量对象 \n\n在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。\n\n活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：\n\n```\nfunction foo(x, y, z) {\n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n```\n\n当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：\n\n1. 函数的所有形参(如果我们是在函数执行上下文中)；\n2. 所有函数声明(FunctionDeclaration, FD)；\n3. 所有变量声明(var, VariableDeclaration)；\n\n另一个经典例子：\n\n```\nalert(x); // function\nvar x = 10;\nalert(x); // 10\nx = 20;\nfunction x() {};\nalert(x); // 20\n```\n\n根据规范函数声明是在当进入上下文时填入的; \n\n在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，**变量声明在顺序上跟在函数声明和形式参数声明之后**，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。\n\n变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。\n\n```\na = 10;\nalert(window.a); // 10\nalert(delete a); // true\nalert(window.a); // undefined\n\nvar b = 20;\nalert(window.b); // 20\nalert(delete b); // false\nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10\nalert(b); // 全局变量 \"b\" 没有声明.\n```\n\n### this\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。\n\n```\n(function () {\n    alert(this); // null =&gt; global\n})();\n```\n\n在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。\n\n```\nvar foo = {\n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&gt; foo\n(foo.bar)(); // Reference, OK =&gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n```\n\n问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。\n\n第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。\n\n在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。\n\n第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。\n\n第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。\n\n正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。\n\n```\nfunction foo() {\n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n```\n\n活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。\n\n这里我们再次回到上面描述的例子，this设置为全局对象。\n\n### 作用域链\n\n通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。\n\n一个重要的例外，它涉及到通过函数构造函数创建的函数。\n```\nvar x = 10;\nfunction foo() {\n\tvar y = 20;\n\tfunction barFD() { // 函数声明\n\t    alert(x);\n\t    alert(y);\n\t}\n\tvar barFn = Function('alert(x); alert(y);');\n\tbarFD(); // 10, 20\n\tbarFn(); // 10, \"y\" is not defined\n}\nfoo();</pre><p>还有：</p><pre class=\"brush:javascript\">var x = 10, y = 10;\nwith ({x: 20}) {\n\tvar x = 30, y = 30;\n\t//这里的 x = 30 覆盖了x = 20；\n\talert(x); // 30\n\talert(y); // 30\n}\n\nalert(x); // 10\nalert(y); // 30\n```\n在进入上下文时发生了什么？\n\n标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：\n```\nx = 10, y = 10;\n```\n对象`{x:20}`添加到作用域的前端;\n\n在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;\n\n在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;\n\n同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;\n\n此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。\n\n在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。\n\n### 函数\n\n关于圆括号的问题\n\n让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。\n\n按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：\n\n```\nfunction () {\n...\n}();\n\n// 即便有名称\n\nfunction foo() {\n...\n}();\n```\n\n我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。\n\n如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。\n\n第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：\n\n```\n// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数\nfunction foo(x) {\n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10\n```\n创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）\n\n```\n(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n```\n上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。\n\n注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。\n```\nvar foo = {\n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'\n```\n就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。\n\n因此，”关于圆括号”问题完整的答案如下：\n\n当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。\n\n由变量：\n```\nfunction testFn() {\n\tvar localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n\tfunction innerFn(innerParam) {\n\t\talert(innerParam + localVar);\n\t}\n\treturn innerFn;\n}\n\n```\n闭包的静态作用域：\n```\nvar z = 10;\n\nfunction foo() {\n    alert(z);\n}</pre><pre class=\"brush:javascript\">foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n\tvar z = 20;\n\tfoo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n\tvar z = 30;\n\tfunArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n```\n**理论**：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。\n\n**从实践角度**：以下函数才算是闭包：\n\n即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n\n在代码中引用了自由变量\n\n## 最后： \n\nECMAScript是一种面向对象语言，支持基于原型的委托式继承。","mobiledoc":null,"html":"<h2 id=\"\">前言</h2>\n\n<p>在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级jser来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。</p>\n\n<p>本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下<a href=\"http://book.douban.com/subject/10549733\">权威指南</a>~</p>\n\n<p>参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：</p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/\">http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/</a></p>\n\n<p><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\">http://benalman.com/news/2010/11/immediately-invoked-function-expression/</a></p>\n\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/\">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>\n\n<h2 id=\"\">语言特性</h2>\n\n<h3 id=\"\">函数表达式</h3>\n\n<p>先看代码段：</p>\n\n<pre><code>var f = function foo(){  \n    return typeof foo; // foo是在内部作用域内有效\n};\n// foo在外部用于是不可见的\ntypeof foo; // \"undefined\"  \nf(); // \"function\"&lt;/pre&gt;  \n</code></pre>\n\n<p>这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。</p>\n\n<h3 id=\"json\">json</h3>\n\n<p>很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。</p>\n\n<p>JSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。</p>\n\n<p><code>{ \"prop\": \"val\" }</code> 这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。</p>\n\n<p>如果是用在string上下文(用单引号或双引号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。</p>\n\n<pre><code>// 这是JSON字符串\nvar foo = '{ \"prop\": \"val\" }';\n\n// 这是对象字面量\nvar bar = { \"prop\": \"val\" };  \n</code></pre>\n\n<p>还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。</p>\n\n<p>老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。</p>\n\n<h3 id=\"\">原型</h3>\n\n<pre><code>function Animal (){  \n// ...\n}\nfunction cat (){  \n// ...\n} \ncat.prototype = new Animal();//这种方式会继承构造函数里面的。  \ncat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。\n\n//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！\ncat.prototype.constructor = cat;  \n</code></pre>\n\n<p>如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // false!  \n</code></pre>\n\n<p>让我们一起看下MDN上关于constructor的 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor\">解释</a></p>\n\n<pre><code>prototype：Returns a reference to the Object function that created the instance's prototype.  \n</code></pre>\n\n<p>因此，对函数的原型引用需要手工恢复：</p>\n\n<pre><code>function A() {}  \n    A.prototype = {\n    constructor: A,\n    x: 10\n};\n\nvar a = new A();  \nalert(a.x); // 10  \nalert(a.constructor === A); // true  \n</code></pre>\n\n<p>然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。</p>\n\n<pre><code>function A() {}  \nA.prototype.x = 10;\n\nvar a = new A();  \nalert(a.x); // 10\n\nA.prototype = {  \n    constructor: A,\n    x: 20\n    y: 30\n};\n\n// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值\nalert(a.x); // 10  \nalert(a.y) // undefined\n\nvar b = new A();\n\n// 但新对象是从新原型上获取的值\nalert(b.x); // 20  \nalert(b.y) // 30\n</code></pre>\n\n<p>因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。</p>\n\n<p>这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。</p>\n\n<h3 id=\"\">变量对象</h3>\n\n<p>在函数执行上下文中，VO(variable object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。</p>\n\n<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：</p>\n\n<pre><code>function foo(x, y, z) {  \n    // 声明的函数参数数量arguments (x, y, z)\n    alert(foo.length); // 3\n    // 真正传进来的参数个数(only x, y)\n    alert(arguments.length); // 2\n    // 参数的callee是函数自身\n    alert(arguments.callee === foo); // true\n}\n</code></pre>\n\n<p>当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：</p>\n\n<ol>\n<li>函数的所有形参(如果我们是在函数执行上下文中)；  </li>\n<li>所有函数声明(FunctionDeclaration, FD)；  </li>\n<li>所有变量声明(var, VariableDeclaration)；</li>\n</ol>\n\n<p>另一个经典例子：</p>\n\n<pre><code>alert(x); // function  \nvar x = 10;  \nalert(x); // 10  \nx = 20;  \nfunction x() {};  \nalert(x); // 20  \n</code></pre>\n\n<p>根据规范函数声明是在当进入上下文时填入的; </p>\n\n<p>在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，<strong>变量声明在顺序上跟在函数声明和形式参数声明之后</strong>，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。</p>\n\n<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。</p>\n\n<pre><code>a = 10;  \nalert(window.a); // 10  \nalert(delete a); // true  \nalert(window.a); // undefined\n\nvar b = 20;  \nalert(window.b); // 20  \nalert(delete b); // false  \nalert(window.b); // still 20。b is variable,not property!\n\nvar a = 10; // 全局上下文中的变量\n\n(function () {\n    var b = 20; // function上下文中的局部变量\n})();\nalert(a); // 10  \nalert(b); // 全局变量 \"b\" 没有声明.  \n</code></pre>\n\n<h3 id=\"this\">this</h3>\n\n<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。</p>\n\n<pre><code>(function () {\n    alert(this); // null =&amp;gt; global\n})();\n</code></pre>\n\n<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。</p>\n\n<pre><code>var foo = {  \n    bar: function () {\n        alert(this);\n    }\n};\n\nfoo.bar(); // Reference, OK =&amp;gt; foo  \n(foo.bar)(); // Reference, OK =&amp;gt; foo\n\n(foo.bar = foo.bar)(); // global\n(false || foo.bar)(); // global\n(foo.bar, foo.bar)(); // global\n</code></pre>\n\n<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。</p>\n\n<p>第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。</p>\n\n<p>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。</p>\n\n<p>第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。</p>\n\n<p>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。</p>\n\n<p>正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。</p>\n\n<pre><code>function foo() {  \n    function bar() {\n        alert(this); // global\n    }\n    bar(); // the same as AO.bar()\n}\n</code></pre>\n\n<p>活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。</p>\n\n<p>这里我们再次回到上面描述的例子，this设置为全局对象。</p>\n\n<h3 id=\"\">作用域链</h3>\n\n<p>通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。</p>\n\n<p>一个重要的例外，它涉及到通过函数构造函数创建的函数。</p>\n\n<pre><code>var x = 10;  \nfunction foo() {  \n    var y = 20;\n    function barFD() { // 函数声明\n        alert(x);\n        alert(y);\n    }\n    var barFn = Function('alert(x); alert(y);');\n    barFD(); // 10, 20\n    barFn(); // 10, \"y\" is not defined\n}\nfoo();&lt;/pre&gt;&lt;p&gt;还有：&lt;/p&gt;&lt;pre class=\"brush:javascript\"&gt;var x = 10, y = 10;  \nwith ({x: 20}) {  \n    var x = 30, y = 30;\n    //这里的 x = 30 覆盖了x = 20；\n    alert(x); // 30\n    alert(y); // 30\n}\n\nalert(x); // 10  \nalert(y); // 30  \n</code></pre>\n\n<p>在进入上下文时发生了什么？</p>\n\n<p>标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：</p>\n\n<pre><code>x = 10, y = 10;  \n</code></pre>\n\n<p>对象<code>{x:20}</code>添加到作用域的前端;</p>\n\n<p>在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;</p>\n\n<p>在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;</p>\n\n<p>同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;</p>\n\n<p>此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。</p>\n\n<p>在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。</p>\n\n<h3 id=\"\">函数</h3>\n\n<p>关于圆括号的问题</p>\n\n<p>让我们看下这个问题：‘ 为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。</p>\n\n<p>按照标准，表达式语句不能以一个大括号 { 开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：</p>\n\n<pre><code>function () {  \n...\n}();\n\n// 即便有名称\n\nfunction foo() {  \n...\n}();\n</code></pre>\n\n<p>我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。</p>\n\n<p>如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。</p>\n\n<p>第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：</p>\n\n<pre><code>// \"foo\" 是一个函数声明，在进入上下文的时候创建\nalert(foo); // 函数  \nfunction foo(x) {  \n    alert(x);\n}(1); // 这只是一个分组操作符，不是函数调用！\nfoo(10); // 这才是一个真正的函数调用，结果是10  \n</code></pre>\n\n<p>创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）</p>\n\n<pre><code>(function foo(x) {\n    alert(x);\n})(1); // 这才是调用，不是分组操作符\n</code></pre>\n\n<p>上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。</p>\n\n<p>注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。</p>\n\n<pre><code>var foo = {  \n    bar: function (x) {\n        return x % 2 != 0 ? 'yes' : 'no';\n    }(1)\n};\n\nalert(foo.bar); // 'yes'  \n</code></pre>\n\n<p>就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。</p>\n\n<p>因此，”关于圆括号”问题完整的答案如下：</p>\n\n<p>当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。<br /> 如果解析器知道它处理的是FE，就没必要用圆括号。</p>\n\n<p>由变量：</p>\n\n<pre><code>function testFn() {  \n    var localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。\n    function innerFn(innerParam) {\n        alert(innerParam + localVar);\n    }\n    return innerFn;\n}\n</code></pre>\n\n<p>闭包的静态作用域：</p>\n\n<pre><code>var z = 10;\n\nfunction foo() {  \n    alert(z);\n}&lt;/pre&gt;&lt;pre class=\"brush:javascript\"&gt;foo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n    var z = 20;\n    foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n    var z = 30;\n    funArg(); // 10 – 静态作用域, 30 – 动态作用域\n})(foo);\n</code></pre>\n\n<p><strong>理论</strong>：因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。</p>\n\n<p><strong>从实践角度</strong>：以下函数才算是闭包：</p>\n\n<p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>\n\n<p>在代码中引用了自由变量</p>\n\n<h2 id=\"\">最后：</h2>\n\n<p>ECMAScript是一种面向对象语言，支持基于原型的委托式继承。</p>","image":"/content/images/2016/06/g.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"浅谈JavaScript的语言特性","meta_description":"浅谈JavaScript的语言特性，作用域、上下文、闭包、函数，前端进阶。","author_id":1,"created_at":"2016-06-17 15:40:57","created_by":1,"updated_at":"2016-07-19 14:12:02","updated_by":1,"published_at":"2013-03-22 16:00:00","published_by":1},{"id":81,"uuid":"2de288af-1cb9-4d6a-889b-980cb05dec50","title":"Javascript中的括号哲学","slug":"welcome-to-ghost-2-2","markdown":"平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。\n\n最近刚好在看ECMAScript262，又遇到这些问题。整理一下：\n\n## 引入\n\n先上一段代码:\n\n```\nalert(foo);\nfunction foo(x) {\n    alert(x);\n}(1);\nfoo(10);\n```\n\n这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.\n\ngoogle了一下Group Operation：\n\n```\na means of controlling precedence(优先级) of evaluation in expressions.\n```\n难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？\n\n## 深入\n\n再看两个表达式：\n```\nfunction () { ... }();\nfunction foo() { ... }();\n```\n\n在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 \n\n在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 \n\n第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 \n\n这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 \n\n最常规例子：\n\n```\n(function(){\n    alert(\"cftea\");\n})();\n```\n\n这个可以理解为：\n```\nfunction foo(){\n    alert(1);\n}\nfoo();\n```\n这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：\n```\n(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){\n    alert(\"cftea\");\n}()\n```\n以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。\n\n## 括号对上下文作用域的影响\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();\n```\n这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。\n```\nfunction Foo() {\n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n})();\n```\n这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。\n```\nfunction Foo() {\n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();\n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n```","mobiledoc":null,"html":"<p>平时总是遇到很多小括号跟在函数后面，没有机会深究。正如丁小倪所说，前端是一个涉足很深的职业，一个标签或一个属性都可以引申出很多东西。对每一个细节都要认真对待。</p>\n\n<p>最近刚好在看ECMAScript262，又遇到这些问题。整理一下：</p>\n\n<h2 id=\"\">引入</h2>\n\n<p>先上一段代码:</p>\n\n<pre><code>alert(foo);  \nfunction foo(x) {  \n    alert(x);\n}(1);\nfoo(10);  \n</code></pre>\n\n<p>这里的(1)有点不懂。第一个alert（）把foo打印出来，里面没有(1)！ 他上面解释的是Group Operation.</p>\n\n<p>google了一下Group Operation：</p>\n\n<pre><code>a means of controlling precedence(优先级) of evaluation in expressions.  \n</code></pre>\n\n<p>难道只是改变优先级？把括号去了只剩下1，结果也没有变化。所以，(1)应该和foo没有关系，即使放在很远的地方。是不是1之类的呢？</p>\n\n<h2 id=\"\">深入</h2>\n\n<p>再看两个表达式：</p>\n\n<pre><code>function () { ... }();  \nfunction foo() { ... }();  \n</code></pre>\n\n<p>在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，函数声明必须有name，否则编译器会报错。它看到了是以function开始的。 </p>\n\n<p>在第一个中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。 </p>\n\n<p>第二个中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 组操作符内部缺少表达式。 </p>\n\n<p>这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。不过如果给他加上void就不一样了哦。 </p>\n\n<p>最常规例子：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n</code></pre>\n\n<p>这个可以理解为：</p>\n\n<pre><code>function foo(){  \n    alert(1);\n}\nfoo();  \n</code></pre>\n\n<p>这里只是让function先执行，也就是上面说的优先级吧。 还有可能的用法：</p>\n\n<pre><code>(function(){\n    alert(\"cftea\");\n})();\n(function(){\n    alert(\"cftea\");\n}());\nvoid function(){  \n    alert(\"cftea\");\n}()\n</code></pre>\n\n<p>以上的括号，或者void的作用只是告诉编译器把函数当成FE（函数表达式）来处理而已 函数表达式中的函数名称在哪保存，可以去看下ECMAScript262-5中函数的部分。</p>\n\n<h2 id=\"\">括号对上下文作用域的影响</h2>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n    })();\n}\nvar f = new Foo();  \n</code></pre>\n\n<p>这里var a给Foo的活动对象增加了一个变量，this.a给Foo的base值增加了一个属性。 注意，在匿名函数中，this永远指向global。只有this指向global，他们之间的变量相互独立，都是相当于块级作用域的东西。</p>\n\n<pre><code>function Foo() {  \n    var a = 123;\n    this.a = 456;\n    (function() {\n        alert(a); // 123\n        alert(this.a); // undefined\n        this.b = 789;\n    })();\n    (function() {\n       alert(this.b); // 789\n    })();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n})();\n</code></pre>\n\n<p>这说明用两个小括号括起来的都是位于一个执行上下文中的，都是在global中。 下面这里查找不到b变量，因为和前面的var b不是同一个，在不懂得”块级作用域里面“，查找不到后就在原型里面找，最终找到属性。</p>\n\n<pre><code>function Foo() {  \n(function() {\n    this.b = 789;\n})();\n(function() {\n    alert(this.b); // 789\n    var b = 0;\n    alert(b); // 0\n})();\n}\nvar f = new Foo();  \n(function() {\n    alert(this.b); // 789\n    alert(b); // 789\n})();\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-06-13 15:39:49","created_by":1,"updated_at":"2016-07-19 14:14:09","updated_by":1,"published_at":"2012-10-15 15:39:00","published_by":1},{"id":82,"uuid":"97d04f9f-b346-462f-baf2-75a278ad37cc","title":"高效css","slug":"efficient-css-2","markdown":"## 译言：\n\n原文地址在[这里](http://csswizardry.com/2011/09/writing-efficient-css-selectors)，由于第一次翻译文章，有不准确的地方欢迎留言讨论\n\n## 译文：\n\n高效的CSS已经不是一个新的话题了，也不是我一个非得重拾的话题，但它却是我在Sky公司工作之时，所感兴趣的，关注已久的话题。\n\n有很多人都忘记了，或在简单的说没有意识到，CSS在我们手中，既能很高效，也可以变得很低能。这很容易被忘记，尤其是当你意识到你会的太少，CSS代码效率很低的时候。\n\n下面的规则只真正被应用到那些速度要求很高，有成百上千的DOM元素被绘制在页面上的大型网站。但是，实践出真理，这和你是在创建下一个Facebook，还是写一个本地的展示页面都没有关系，多知道一点总是好的。\n\n### CSS选择器：\n\n对我们大多数人来说，CSS选择器并不陌生。最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。\n\n一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，[class ^= “grid-”].\n\nCSS选择器具有高效的继承性，引用Steve Souders的话， CSS选择器效率从高到低的排序如下：\n```\n<ol>\n\t<li>ID选择器 比如#header</li>\n\t<li>类选择器 比如.promo</li>\n\t<li>元素选择器 比如 div</li>\n\t<li>兄弟选择器 比如 h2 + p</li>\n\t<li>子选择器 比如 li &gt; ul</li>\n\t<li>后代选择器 比如 ul a</li>\n\t<li>通用选择器 比如 \\*</li>\n\t<li>属性选择器 比如 [type = “text”]</li>\n\t<li>伪类/伪元素选择器 比如 a:hover</li>\n</ol>\n```\n以上引用自[Steve Souders](http://stevesouders.com)的Even Faster网站。\n\n我们不得不提的是，纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出ID选择器和类选择器在速度上的差异很小很小。\n\n在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。\n\nID选择器和类选择器在速度上的差异基本上没有关系。\n\n在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了很多。在一个嵌套很深的后代选择器的测试上，显示数据为440左右!\n\n从这里我们可以看出ID/类选择器 和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。\n\n**注意：** 这些数据可能在不同计算机和浏览器中间的差异较大。强烈地建议大家在自己的机子上测试一下。\n\n### 组合选择器\n\n你可以有一个标准的选择器比如 #nav，来选择任何带有ID为\"nav\"的元素，或在你可以有一个组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素\n\n此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。\n\n在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。这些细微的差异对选择器的效率有很大的影响，同时学这些差异也是很有价值的。\n\n如果想要知道更多浏览器这样解析的原因，请看[Stack Overflow](http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left)上的讨论\n\n浏览器从最右边的元素开始（它想要渲染的元素），然后用它的方式回溯DOM树比从DOM树的最高层开始选择向下寻找，甚至可能达不到最右边的选择器—关键的选择器要高效。\n\n这些对CSS选择器的效率有很大的影响。\n\n### 关键选择器\n\n关键选择器，正如前面讨论的一样，是一个复杂的CSS选择器中最右边部分。它是浏览器最先寻找的。\n\n现在我们回到讨论开始的地方，哪类选择器是最高效的？哪个是会影响选择器效率的关键选择器；写CSS代码的时候，关键选择器是能否高效的决定因素。\n一个关键CSS选择器像这样：\n```\n#content .intro {\n}\n```\n是不是高效选择器比如类选择器天生就高效？浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。\n\n但是，下面的选择器就表现的不是那么好了：\n```\n#content * {\n}\n```\n\n这个选择器所做的是选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个 #content 的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。\n\n运用这些知识我们就可以在分类和选择元素的时候做出更好的选择。\n\n假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的 a 标签。它还有一个小的社交链接区域放在一个ID为#social的Ul里面。我们假设它们是Twitter，Facebook，Dribbble还有Google+的链接吧。在这个页面上我们有四个社交链接和成百上千的其他链接。\n下面的这个选择器就自然的不是那么高效和合理了：\n\n```\n#social a {\n}\n```\n\n这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。\n\n为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器 .social-link ,\n但是这好像有点违背我们的认知：当我们能用组合选择器的时候就不要放不必要的类标示在元素上。\n\n这就是为什么我对选择器的性能如此感兴趣的原因了：必须在web 标准最佳实践和速度之间的保持平衡。\n\n通常我们有：\n\n```\n<ul id=\"social\">;\n\t<li><a href=\"#\" class=\"twitter\" >Twitter</a></li>\n\t<li><a href=\"#\" class=\"facebook\">Facebook</a></li>\n\t<li><a href=\"#\" class=\"dribble\">Dribbble</a></li>\n\t<li><a href=\"#\" class=\"gplus\">Google+</a></li>\n</ul>\n```\n\nCSS:\n\n```\n#social a {\n}\n```\n\n我们现在最好有：\n\n```\n<ul id=\"social\">\n\t<li><a href=\"#\" class=\"social-link twitter\">Twitter</a></li>\n\t<li><a href=\"#\" class=\"social-link facebook\">Facebook</a></li>\n\t<li><a href=\"#\" class=\"social-link dribble\">Dribbble</a></li>\n\t<li><a href=\"#\" class=\"social-link gplus\">Google+</a></li>\n</ul>\n```\n\n加上CSS：\n\n```\n#social .social-link {\n}\n```\n\n这个新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式，然后专注于下一件事。\n\n另外，事实上我们可以用.social-link{}更清晰的选择，而不是过分限制它。阅读下一部分你会原因…\n\n简单的重述一次，你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器\n\n### 过度限制选择器\n\n现在我们知道了什么是关键选择器，还有它是大部分工作的来源，但是我们可以更乐观一点。拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器。一个过度限制选择器可能像：\n\n```\n.wrapper #content a {\n}\n```\n\n这里的写的太多了，至少3个选择器是完全不需要的。它可以最多像这个样子：\n\n```\n#content a {\n}\n```\n\n这会发生什么呢？\n\n首先第一个意味着浏览器不得不寻找所有的 a 元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。了解了这个，我们得到一些更现实的例子：\n\n```\n#nav li a{\n}\n```\n\n变成这个：\n\n```\n#nav a {\n}\n```\n\n我们知道如果a在li里面，它也必定在#nav里面，所有我们可以马上把li从选择器组中拿掉。然后，既然我们知道在页面中只有一个ID为nav的元素，那么它依附的元素就是完全没有关系得了，我们也可以拿掉ul\n\n过度限制选择器使浏览器工作比它实际需要的更繁重，花费的时间更多。我们可以删掉不必需的限制，来使我们的选择器更简单和高效。\n\n### 这些真的需要吗？\n\n最短的答案是:或许不是。\n\n最长的答案是：它取决于你正在搭建的站点。如果你正在为你的晋升而努力，那么就好好写出简单、高效的CSS代码吧，因为你可能不会感觉到它给你带来的改变。\n如果你正在搭建下一个每个页面都以毫秒计算的Amazon网站，这样有时速度会很快，但有时可能不是。\n\n浏览器将会在解析CSS的速度上变得更好，甚至在手机端。在一个网站上，你不太可能会觉察到一个低效的CSS选择器，但是….\n\n### 但是\n\n它确实发生了，浏览器还是不得不去做我们讨论的所有工作，无论它们变得多快。即使你不需要或者甚至不想实践任何一个，但是它都是我们值得学习的知识。请记住选择器可能会让你付出很大代价，你应该避免盯着一个看。这意味着如果你发现你自己在写像这样的：\n\n```\ndiv:nth-of-type(3) ul:last-child li:nth-of-type(odd) * { \n    font-weight:bold \n}\n```\n\n这时，你可能就做错了。\n\n现在，在高效选择器的世界我还是一个新人。所以如果我忘记了什么，或者你有需要补充的，请在评论里面留言。\n\n### 更多高效选择器\n\n我还不能完全介绍Steve Souders的网站和书籍，它们是如此之好，以至于值得你花更多时间来阅读和推荐。这个家伙只有他自己才了解自己！","mobiledoc":null,"html":"<h2 id=\"\">译言：</h2>\n\n<p>原文地址在<a href=\"http://csswizardry.com/2011/09/writing-efficient-css-selectors\">这里</a>，由于第一次翻译文章，有不准确的地方欢迎留言讨论</p>\n\n<h2 id=\"\">译文：</h2>\n\n<p>高效的CSS已经不是一个新的话题了，也不是我一个非得重拾的话题，但它却是我在Sky公司工作之时，所感兴趣的，关注已久的话题。</p>\n\n<p>有很多人都忘记了，或在简单的说没有意识到，CSS在我们手中，既能很高效，也可以变得很低能。这很容易被忘记，尤其是当你意识到你会的太少，CSS代码效率很低的时候。</p>\n\n<p>下面的规则只真正被应用到那些速度要求很高，有成百上千的DOM元素被绘制在页面上的大型网站。但是，实践出真理，这和你是在创建下一个Facebook，还是写一个本地的展示页面都没有关系，多知道一点总是好的。</p>\n\n<h3 id=\"css\">CSS选择器：</h3>\n\n<p>对我们大多数人来说，CSS选择器并不陌生。最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。</p>\n\n<p>一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，[class ^= “grid-”].</p>\n\n<p>CSS选择器具有高效的继承性，引用Steve Souders的话， CSS选择器效率从高到低的排序如下：  </p>\n\n<pre><code>&lt;ol&gt;  \n    &lt;li&gt;ID选择器 比如#header&lt;/li&gt;\n    &lt;li&gt;类选择器 比如.promo&lt;/li&gt;\n    &lt;li&gt;元素选择器 比如 div&lt;/li&gt;\n    &lt;li&gt;兄弟选择器 比如 h2 + p&lt;/li&gt;\n    &lt;li&gt;子选择器 比如 li &amp;gt; ul&lt;/li&gt;\n    &lt;li&gt;后代选择器 比如 ul a&lt;/li&gt;\n    &lt;li&gt;通用选择器 比如 \\*&lt;/li&gt;\n    &lt;li&gt;属性选择器 比如 [type = “text”]&lt;/li&gt;\n    &lt;li&gt;伪类/伪元素选择器 比如 a:hover&lt;/li&gt;\n&lt;/ol&gt;  \n</code></pre>\n\n<p>以上引用自<a href=\"http://stevesouders.com\">Steve Souders</a>的Even Faster网站。</p>\n\n<p>我们不得不提的是，纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出ID选择器和类选择器在速度上的差异很小很小。</p>\n\n<p>在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。</p>\n\n<p>ID选择器和类选择器在速度上的差异基本上没有关系。</p>\n\n<p>在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了很多。在一个嵌套很深的后代选择器的测试上，显示数据为440左右!</p>\n\n<p>从这里我们可以看出ID/类选择器 和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。</p>\n\n<p><strong>注意：</strong> 这些数据可能在不同计算机和浏览器中间的差异较大。强烈地建议大家在自己的机子上测试一下。</p>\n\n<h3 id=\"\">组合选择器</h3>\n\n<p>你可以有一个标准的选择器比如 #nav，来选择任何带有ID为\"nav\"的元素，或在你可以有一个组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素</p>\n\n<p>此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。</p>\n\n<p>在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。这些细微的差异对选择器的效率有很大的影响，同时学这些差异也是很有价值的。</p>\n\n<p>如果想要知道更多浏览器这样解析的原因，请看<a href=\"http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left\">Stack Overflow</a>上的讨论</p>\n\n<p>浏览器从最右边的元素开始（它想要渲染的元素），然后用它的方式回溯DOM树比从DOM树的最高层开始选择向下寻找，甚至可能达不到最右边的选择器—关键的选择器要高效。</p>\n\n<p>这些对CSS选择器的效率有很大的影响。</p>\n\n<h3 id=\"\">关键选择器</h3>\n\n<p>关键选择器，正如前面讨论的一样，是一个复杂的CSS选择器中最右边部分。它是浏览器最先寻找的。</p>\n\n<p>现在我们回到讨论开始的地方，哪类选择器是最高效的？哪个是会影响选择器效率的关键选择器；写CSS代码的时候，关键选择器是能否高效的决定因素。\n一个关键CSS选择器像这样：</p>\n\n<pre><code>#content .intro {\n}\n</code></pre>\n\n<p>是不是高效选择器比如类选择器天生就高效？浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。</p>\n\n<p>但是，下面的选择器就表现的不是那么好了：</p>\n\n<pre><code>#content * {\n}\n</code></pre>\n\n<p>这个选择器所做的是选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个 #content 的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。</p>\n\n<p>运用这些知识我们就可以在分类和选择元素的时候做出更好的选择。</p>\n\n<p>假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的 a 标签。它还有一个小的社交链接区域放在一个ID为#social的Ul里面。我们假设它们是Twitter，Facebook，Dribbble还有Google+的链接吧。在这个页面上我们有四个社交链接和成百上千的其他链接。\n下面的这个选择器就自然的不是那么高效和合理了：</p>\n\n<pre><code>#social a {\n}\n</code></pre>\n\n<p>这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。</p>\n\n<p>为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器 .social-link ,\n但是这好像有点违背我们的认知：当我们能用组合选择器的时候就不要放不必要的类标示在元素上。</p>\n\n<p>这就是为什么我对选择器的性能如此感兴趣的原因了：必须在web 标准最佳实践和速度之间的保持平衡。</p>\n\n<p>通常我们有：</p>\n\n<pre><code>&lt;ul id=\"social\"&gt;;  \n    &lt;li&gt;&lt;a href=\"#\" class=\"twitter\" &gt;Twitter&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"facebook\"&gt;Facebook&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"dribble\"&gt;Dribbble&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"gplus\"&gt;Google+&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;  \n</code></pre>\n\n<p>CSS:</p>\n\n<pre><code>#social a {\n}\n</code></pre>\n\n<p>我们现在最好有：</p>\n\n<pre><code>&lt;ul id=\"social\"&gt;  \n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link twitter\"&gt;Twitter&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link facebook\"&gt;Facebook&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link dribble\"&gt;Dribbble&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#\" class=\"social-link gplus\"&gt;Google+&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;  \n</code></pre>\n\n<p>加上CSS：</p>\n\n<pre><code>#social .social-link {\n}\n</code></pre>\n\n<p>这个新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式，然后专注于下一件事。</p>\n\n<p>另外，事实上我们可以用.social-link{}更清晰的选择，而不是过分限制它。阅读下一部分你会原因…</p>\n\n<p>简单的重述一次，你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器</p>\n\n<h3 id=\"\">过度限制选择器</h3>\n\n<p>现在我们知道了什么是关键选择器，还有它是大部分工作的来源，但是我们可以更乐观一点。拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器。一个过度限制选择器可能像：</p>\n\n<pre><code>.wrapper #content a {\n}\n</code></pre>\n\n<p>这里的写的太多了，至少3个选择器是完全不需要的。它可以最多像这个样子：</p>\n\n<pre><code>#content a {\n}\n</code></pre>\n\n<p>这会发生什么呢？</p>\n\n<p>首先第一个意味着浏览器不得不寻找所有的 a 元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。了解了这个，我们得到一些更现实的例子：</p>\n\n<pre><code>#nav li a{\n}\n</code></pre>\n\n<p>变成这个：</p>\n\n<pre><code>#nav a {\n}\n</code></pre>\n\n<p>我们知道如果a在li里面，它也必定在#nav里面，所有我们可以马上把li从选择器组中拿掉。然后，既然我们知道在页面中只有一个ID为nav的元素，那么它依附的元素就是完全没有关系得了，我们也可以拿掉ul</p>\n\n<p>过度限制选择器使浏览器工作比它实际需要的更繁重，花费的时间更多。我们可以删掉不必需的限制，来使我们的选择器更简单和高效。</p>\n\n<h3 id=\"\">这些真的需要吗？</h3>\n\n<p>最短的答案是:或许不是。</p>\n\n<p>最长的答案是：它取决于你正在搭建的站点。如果你正在为你的晋升而努力，那么就好好写出简单、高效的CSS代码吧，因为你可能不会感觉到它给你带来的改变。\n如果你正在搭建下一个每个页面都以毫秒计算的Amazon网站，这样有时速度会很快，但有时可能不是。</p>\n\n<p>浏览器将会在解析CSS的速度上变得更好，甚至在手机端。在一个网站上，你不太可能会觉察到一个低效的CSS选择器，但是….</p>\n\n<h3 id=\"\">但是</h3>\n\n<p>它确实发生了，浏览器还是不得不去做我们讨论的所有工作，无论它们变得多快。即使你不需要或者甚至不想实践任何一个，但是它都是我们值得学习的知识。请记住选择器可能会让你付出很大代价，你应该避免盯着一个看。这意味着如果你发现你自己在写像这样的：</p>\n\n<pre><code>div:nth-of-type(3) ul:last-child li:nth-of-type(odd) * {  \n    font-weight:bold \n}\n</code></pre>\n\n<p>这时，你可能就做错了。</p>\n\n<p>现在，在高效选择器的世界我还是一个新人。所以如果我忘记了什么，或者你有需要补充的，请在评论里面留言。</p>\n\n<h3 id=\"\">更多高效选择器</h3>\n\n<p>我还不能完全介绍Steve Souders的网站和书籍，它们是如此之好，以至于值得你花更多时间来阅读和推荐。这个家伙只有他自己才了解自己！</p>","image":"/content/images/2016/06/css.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"高效css，css技巧，css效率","meta_description":"本文讲解css的效率方面问题，各种css选择器的浏览器实现原理，使用注意等。","author_id":1,"created_at":"2016-06-27 14:13:42","created_by":1,"updated_at":"2016-07-19 14:12:18","updated_by":1,"published_at":"2013-03-08 14:18:00","published_by":1},{"id":83,"uuid":"0225b252-29d3-4373-901a-e53fb214518d","title":"微信开发的一些总结","slug":"weixin-develop-2","markdown":"最近有机会，尝试了一次微信开发，中间遇到很多比较容易踩得坑，记录一下。\n\n主要功能是\n\n1. 微信网页认证\n2. 转盘抽奖\n3. 微信公共号发红包给当前登录用户\n4. 分享给好友和分享到朋友圈\n\n## 微信限制\n\n涉及到的资源:\n\n微信公众平台： [https://mp.weixin.qq.com/](https://mp.weixin.qq.com/)\n\n微信商户平台： [https://pay.weixin.qq.com/](https://pay.weixin.qq.com/)\n\n微信API：[http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)\n\n微信开发者论坛: [http://qydev.weixin.qq.com/qa/index.php?qa=questions](http://qydev.weixin.qq.com/qa/index.php?qa=questions)\n\n## 过程记录\n\n### 微信网页认证\n\n**条件：**\n\n1. 服务号\n\n2. 通过微信认证\n\n接口文档：[http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html](http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html)\n\n过程是获取用户授权的`code`，通过`code`获取`access_code`，然后通过`access_code`获取用户信息。\n\n#### 其中第一个坑\n\n第一步获取用户授权的`code`，`redirect_uri`经常会报错`redirect_uri参数错误`，可能的原因是：\n\n1. 公众平台后台设置授权回调域名\n2. 回调页面有端口，授权也需端口\n3. redirect_uri urlencode\n4. 绑定已备案域名，主要域名必须是二级或二级以上域名\n\n如果以上问题都注意到后，还是有问题，便可以等几个小时，很可能是微信接口抽风了，我就是用着用着这个接口挂了，等了好几个小时自己好了。\n\n#### 第二个坑\n\n有时候报错”不能访问链接“，原因是微信后台设置的回调域名不对，有时候自己切换host后，域名不对，所以修改回调域名就好了。\n\n#### 第三个坑\n\n`access_token`会过期，用的时候建议每次都通过`refresh_token`去重新获取`access_token`\n\n#### 第四个坑\n\n用户授权后回跳的页面的时候，控制台报错\n\n\t`Resource interpreted as Document but transferred with MIME type application/octet-stream: \"https://open.weixin.qq.com/connect/oauth2/..`\n\n解决办法是，回调页面的url设置为`http://xxx.com`，而不是`xxx.com`\n\n#### 第五个坑\n\n授权回调页面，url会带有`?code=xxx`，不能直接分享这个url，会导致后面的用户授权不了。因为这个问题纠结了很久。\n\n解决方式是，在node端解析code，然后写入cookie，通过`url redirect`到没有code的页面。另一种方式是，通过微信api，定制分享内容和分享的链接。\n\n### 公众号微信发红包给用户\n\n条件：\n\n1. 通过微信认证\n2. 通过微信支付认证\n\n接口地址：[https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1](https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1)\n\n#### 第一个坑\n\n就是有时候会报错`签名错误`，可能原因及解决办法是：\n\n1. 生成签名的密匙过期，重新去后台设置一下即可。\n2. 加密的字符串需要按照ASCII排序\n3. 如果还是没解决，可以去掉中文试试\n4. 还是不正确，可以通过签名工具，把参数都输入后看输出的和自己的哪一步不对。\n5. 最后，post请求传过去的body应该是xml格式，且xml格式需要严格按照xml语法，顺序最好和文档的一样。\n\n\n#### 第二个坑\n\n证书的使用。\n官方下载会下载到三个证书，node用.p12后缀的，使用方式是在请求头设置 agent，然后设置密码。具体见文末的代码链接。\n\n#### 第三个坑\n\n红包的描述和祝福语之类的设置中文会出现红包发送不出去的情况，解决方式是对中文进行unicode编码。\n\n\n### 分享给好友和分享到朋友圈\n\n第一步，在微信后台设置`js接口安全域名`\n\n第二步，引入js文件\n\n第三步，通过config接口注入验证配置\n\t\n **坑**: `signature`签名获取方式是先获取 jsapi_ticket，通过access_token获取jsapi_ticket时总是报错，同一个未过期的access_token获取用户信息是可以的，获取jsapi_ticket就不行。\n\n第四部，配置onMenuShareTimeline方法。可以自定义分享内容和链接。\n\t\n\n---\n\n最后，推荐html5的一些组件库\n\nfrozenUI： [http://frozenui.github.io/](http://frozenui.github.io/)\n\n很出色的h5制作网站：[http://h5.baidu.com/](http://h5.baidu.com/)\n\n源代码仓库链接：[https://github.com/freestyle21/orange-plus](https://github.com/freestyle21/orange-plus)","mobiledoc":null,"html":"<p>最近有机会，尝试了一次微信开发，中间遇到很多比较容易踩得坑，记录一下。</p>\n\n<p>主要功能是</p>\n\n<ol>\n<li>微信网页认证  </li>\n<li>转盘抽奖  </li>\n<li>微信公共号发红包给当前登录用户  </li>\n<li>分享给好友和分享到朋友圈</li>\n</ol>\n\n<h2 id=\"\">微信限制</h2>\n\n<p>涉及到的资源:</p>\n\n<p>微信公众平台： <a href=\"https://mp.weixin.qq.com/\">https://mp.weixin.qq.com/</a></p>\n\n<p>微信商户平台： <a href=\"https://pay.weixin.qq.com/\">https://pay.weixin.qq.com/</a></p>\n\n<p>微信API：<a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\">http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html</a></p>\n\n<p>微信开发者论坛: <a href=\"http://qydev.weixin.qq.com/qa/index.php?qa=questions\">http://qydev.weixin.qq.com/qa/index.php?qa=questions</a></p>\n\n<h2 id=\"\">过程记录</h2>\n\n<h3 id=\"\">微信网页认证</h3>\n\n<p><strong>条件：</strong></p>\n\n<ol>\n<li><p>服务号</p></li>\n<li><p>通过微信认证</p></li>\n</ol>\n\n<p>接口文档：<a href=\"http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html\">http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html</a></p>\n\n<p>过程是获取用户授权的<code>code</code>，通过<code>code</code>获取<code>access_code</code>，然后通过<code>access_code</code>获取用户信息。</p>\n\n<h4 id=\"\">其中第一个坑</h4>\n\n<p>第一步获取用户授权的<code>code</code>，<code>redirect_uri</code>经常会报错<code>redirect_uri参数错误</code>，可能的原因是：</p>\n\n<ol>\n<li>公众平台后台设置授权回调域名  </li>\n<li>回调页面有端口，授权也需端口  </li>\n<li>redirect_uri urlencode  </li>\n<li>绑定已备案域名，主要域名必须是二级或二级以上域名</li>\n</ol>\n\n<p>如果以上问题都注意到后，还是有问题，便可以等几个小时，很可能是微信接口抽风了，我就是用着用着这个接口挂了，等了好几个小时自己好了。</p>\n\n<h4 id=\"\">第二个坑</h4>\n\n<p>有时候报错”不能访问链接“，原因是微信后台设置的回调域名不对，有时候自己切换host后，域名不对，所以修改回调域名就好了。</p>\n\n<h4 id=\"\">第三个坑</h4>\n\n<p><code>access_token</code>会过期，用的时候建议每次都通过<code>refresh_token</code>去重新获取<code>access_token</code></p>\n\n<h4 id=\"\">第四个坑</h4>\n\n<p>用户授权后回跳的页面的时候，控制台报错</p>\n\n<pre><code>`Resource interpreted as Document but transferred with MIME type application/octet-stream: \"https://open.weixin.qq.com/connect/oauth2/..`\n</code></pre>\n\n<p>解决办法是，回调页面的url设置为<code>http://xxx.com</code>，而不是<code>xxx.com</code></p>\n\n<h4 id=\"\">第五个坑</h4>\n\n<p>授权回调页面，url会带有<code>?code=xxx</code>，不能直接分享这个url，会导致后面的用户授权不了。因为这个问题纠结了很久。</p>\n\n<p>解决方式是，在node端解析code，然后写入cookie，通过<code>url redirect</code>到没有code的页面。另一种方式是，通过微信api，定制分享内容和分享的链接。</p>\n\n<h3 id=\"\">公众号微信发红包给用户</h3>\n\n<p>条件：</p>\n\n<ol>\n<li>通过微信认证  </li>\n<li>通过微信支付认证</li>\n</ol>\n\n<p>接口地址：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_1\">https://pay.weixin.qq.com/wiki/doc/api/tools/cash<em>coupon.php?chapter=13</em>1</a></p>\n\n<h4 id=\"\">第一个坑</h4>\n\n<p>就是有时候会报错<code>签名错误</code>，可能原因及解决办法是：</p>\n\n<ol>\n<li>生成签名的密匙过期，重新去后台设置一下即可。  </li>\n<li>加密的字符串需要按照ASCII排序  </li>\n<li>如果还是没解决，可以去掉中文试试  </li>\n<li>还是不正确，可以通过签名工具，把参数都输入后看输出的和自己的哪一步不对。  </li>\n<li>最后，post请求传过去的body应该是xml格式，且xml格式需要严格按照xml语法，顺序最好和文档的一样。</li>\n</ol>\n\n<h4 id=\"\">第二个坑</h4>\n\n<p>证书的使用。\n官方下载会下载到三个证书，node用.p12后缀的，使用方式是在请求头设置 agent，然后设置密码。具体见文末的代码链接。</p>\n\n<h4 id=\"\">第三个坑</h4>\n\n<p>红包的描述和祝福语之类的设置中文会出现红包发送不出去的情况，解决方式是对中文进行unicode编码。</p>\n\n<h3 id=\"\">分享给好友和分享到朋友圈</h3>\n\n<p>第一步，在微信后台设置<code>js接口安全域名</code></p>\n\n<p>第二步，引入js文件</p>\n\n<p>第三步，通过config接口注入验证配置</p>\n\n<p><strong>坑</strong>: <code>signature</code>签名获取方式是先获取 jsapi<em>ticket，通过access</em>token获取jsapi<em>ticket时总是报错，同一个未过期的access</em>token获取用户信息是可以的，获取jsapi_ticket就不行。</p>\n\n<p>第四部，配置onMenuShareTimeline方法。可以自定义分享内容和链接。</p>\n\n<hr />\n\n<p>最后，推荐html5的一些组件库</p>\n\n<p>frozenUI： <a href=\"http://frozenui.github.io/\">http://frozenui.github.io/</a></p>\n\n<p>很出色的h5制作网站：<a href=\"http://h5.baidu.com/\">http://h5.baidu.com/</a></p>\n\n<p>源代码仓库链接：<a href=\"https://github.com/freestyle21/orange-plus\">https://github.com/freestyle21/orange-plus</a></p>","image":"/content/images/2016/07/1-16030GQ0241E.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":"微信开发的一些总结","meta_description":"本文总结微信支付开发的一些细节，遇到的坑，以及解决方案。","author_id":1,"created_at":"2016-07-05 13:57:07","created_by":1,"updated_at":"2016-07-19 13:53:33","updated_by":1,"published_at":"2016-04-17 14:02:00","published_by":1},{"id":84,"uuid":"251c97f0-ce41-408d-b934-2c601a951e8a","title":"前端性能调优","slug":"f2e-performance-optimization-2","markdown":"> 前几天，对九霄项目进行了一次大范围的性能优化，效果还不错，<strong>首屏从最开始的899个请求4.98s加载，到最后29个请求998ms加载，提升了79%以上。</strong>这里记录一下优化的过程，方便有需要的朋友。\n\n## 开篇\n新工作已经4个多月，从0开始到现在三个子系统并行，每个子系统负责滴滴业务线的数据分析，业务量和业务逻辑相当复杂。不过随着业务的扩展，性能也随之会成为阻碍系统运转的瓶颈，性能优化势在必行。\n\n## 现状\n目前前端技术架构是:\n     \n[seajs](http://seajs.org) + [arale](http://aralejs.org/docs/about-arale.html) + [koa](http://koajs.com/) + [gulp](http://gulpjs.com/) + [less](http://lesscss.org/)\n\n页面部署是：\n\n     + router.js\n          - entry[入口]\n          - express[快车]\n          - hitch[顺风车]\n          - daijia[代驾]\n\n页面是由路由依次进入四个页面。由于是单页面应用，所以资源文件都是一次加载，导致子系统越多，加载文件越多，网站也越来越慢。\n\n![](/content/images/2016/07/a--1-.png)\n\n## 优化\n\n### 优化一: 按需加载\n\n从上面的架构来看，seajs模块combo在一起，合成一个 `nsky.min.js` 的原始发布方案已经不能满足需求了，需要划分子系统按需加载。\n\n\n按需加载的意思是，进入首页时加载首页必须依赖的模块，不加载其他页面(快车，顺风车，代驾)所需资源。\n\n\nseajs请求资源的原理是正则扫描每个模块中`require`的字符串，从而提取模块的依赖。加载模块时，首先加载其依赖文件，因此我们能够通过 combo 的方式把模块合并到一个文件。另外，seajs中提供 `require.async` 来实现异步加载。\n\n\n因此，我们在router里面转发到不同页面的时候使用 require.async，从而实现分子系统按需加载。\n\n\n优化结果如下：\n\n![](/content/images/2016/07/b.png)\n\n首屏请求数量直接从899个优化到57个，结果还是可喜。\n\n### 优化二：请求合并\n\n观察请求瀑布流，发现请求文件还是太多，比如系统资源加载（class.js/events.js/overlay.js等)，还有业务代码较多，我们可以把这些资源合并在一起，发出combo请求。\n\n比如发出 \n   \n    http://d.kuaidadi.com/path/??class.js,events.js,overlay.js,xxx.js\n\n然后服务端响应此 combo 请求，返回 `class.js`, `events.js`, `overlay.js`, `xxx.js`的合集，这样就可以实现请求合并。\n\n首先，需要浏览器发出类似 `??a.js,b.js,c.js` 的combo请求。seajs发出combo请求很简单，通过[seajs combo插件](https://github.com/seajs/seajs-combo/issues/3)就可以了:\n\n     seajs.config({\n        preload: \"seajs-combo\"\n     });\n\n其次，需要服务器端响应类似 `??a.js,b.js,c.js` 的combo请求。\n\n[seajs combo插件中文文档](https://github.com/seajs/seajs-combo/issues/3)中提到，服务端实现combo请求是通过[Nginx-Http-Concat](https://github.com/taobao/nginx-http-concat)实现。\n\n但是由于线上服务器是通过 Nginx 来实现数台生产机器间负载均衡，通过 `Nginx Proxy Pass`实现非80端转发到80端口。经过试验发现，Nginx的 `Proxy Pass` 和 `Nginx-Http-Concat`不能同时使用，其作者也说过[暂时不支持。](https://www.zhihu.com/question/21313870/answer/17853844)，所以此路不通。\n\n因此，只能自己实现Node Combo。于是又找了不少node-combo项目(比如[node-combo](https://github.com/xuexb/node-combo))，研究其实现思路，准备自己写koa-node-combo插件了。\n\n后来搜索npm仓库，发现有多个这样的插件，尝试发现[koa-combo-parse](https://www.npmjs.com/package/koa-combo-parse)可行：\n\n    app.use(comboParse({\n        base: path.resolve(__dirname, '../client/')\n    }));\n\n\n但是，问题又来了。combo到一起后系统仍然不能运行，因为文件之间没有识别的id。需要寻找工具来对每个模版补全id和依赖(deps)，combo后就能互相识别了。即需要从：\n\n    define(function(require, exports, module){\n        var a = require('a'),\n            b = require('b'); \n        module.exports = {};\n    });\n\n变成：\n \n\n    define('moduleId', ['a', 'b'], function(require, exports, module){\n        var a = require('a'),\n            b = require('b');\n        module.exports = {};\n    });\n\n\n在此过程中调研了 [spm](https://github.com/spmjs/spm)、[gulp-seajs-combo](https://github.com/chenmnkken/gulp-seajs-combo)等，发现都不满足需求。\n\n于是自己实现了node小工具 [iddeps](https://www.npmjs.com/package/iddeps)，并写成了gulp插件[gulp-ids-deps](https://www.npmjs.com/package/gulp-ids-deps)。\n\n最终，前端发出combo请求后，后端响应combo请求，效果如下：\n\n![](/content/images/2016/07/c-2.png)\n\n请求数量从57减少到37，请求时间从1.4s减少到了1.18s。\n\n### 优化三：模版文件预编译\n\n从上面的瀑布流能看出，tpl文件既大又多，占用不少请求时间。\n\n在handlebars中，有预编译的思想，可以在运行前把模版文件预编译成为 js 文件。\n\n业界没有相应的工具，于是自己写了一个node小工具[tpl-2-js](https://www.npmjs.com/package/tpl-2-js)，并改写成gulp插件[gulp-tpl-2-js](https://www.npmjs.com/package/gulp-tpl-2-js)。\n\nHandlebars预编译的过程是：\n       \n       //  node\n       var preCompileData = handlebars.precompile(data);\n\n\n       // web \n       var Handlebars = require('handlebars'),\n        template = Handlebars.template;\n    \n       template(preCompileData)({data});\n   \n预编译的过程，是`Handlebars precompile`创建了一个函数，把每个template存储在 Handlebars.templates里面。\n\n更多详细请看：[gulp-tpl-2-js](https://github.com/freestyle21/gulp-tpl-2-js)\n    \n\n经过模版预编译后、Combo后，效果如下：\n\n![](/content/images/2016/07/d.png)\n\n可以看到，请求结果从上次的37减少到29，请求时间从1.18s减少到998ms\n\n## 后续\n\n整体结果优化的效果差不多了，请求数变到最小，时间首屏时间也符合期望。\n\n后续的优化，可以考虑通过 html5 的 appcache 缓存不经常的更新资源文件，把 200 的资源文件变成 302。\n\n本文是记录自己优化系统的心路历程，有不同意见或者有所收获的可以留言讨论。","mobiledoc":null,"html":"<blockquote>\n  <p>前几天，对九霄项目进行了一次大范围的性能优化，效果还不错，<strong>首屏从最开始的899个请求4.98s加载，到最后29个请求998ms加载，提升了79%以上。</strong>这里记录一下优化的过程，方便有需要的朋友。</p>\n</blockquote>\n\n<h2 id=\"\">开篇</h2>\n\n<p>新工作已经4个多月，从0开始到现在三个子系统并行，每个子系统负责滴滴业务线的数据分析，业务量和业务逻辑相当复杂。不过随着业务的扩展，性能也随之会成为阻碍系统运转的瓶颈，性能优化势在必行。</p>\n\n<h2 id=\"\">现状</h2>\n\n<p>目前前端技术架构是:</p>\n\n<p><a href=\"http://seajs.org\">seajs</a> + <a href=\"http://aralejs.org/docs/about-arale.html\">arale</a> + <a href=\"http://koajs.com/\">koa</a> + <a href=\"http://gulpjs.com/\">gulp</a> + <a href=\"http://lesscss.org/\">less</a></p>\n\n<p>页面部署是：</p>\n\n<pre><code> + router.js\n      - entry[入口]\n      - express[快车]\n      - hitch[顺风车]\n      - daijia[代驾]\n</code></pre>\n\n<p>页面是由路由依次进入四个页面。由于是单页面应用，所以资源文件都是一次加载，导致子系统越多，加载文件越多，网站也越来越慢。</p>\n\n<p><img src=\"/content/images/2016/07/a--1-.png\" alt=\"\" /></p>\n\n<h2 id=\"\">优化</h2>\n\n<h3 id=\"\">优化一: 按需加载</h3>\n\n<p>从上面的架构来看，seajs模块combo在一起，合成一个 <code>nsky.min.js</code> 的原始发布方案已经不能满足需求了，需要划分子系统按需加载。</p>\n\n<p>按需加载的意思是，进入首页时加载首页必须依赖的模块，不加载其他页面(快车，顺风车，代驾)所需资源。</p>\n\n<p>seajs请求资源的原理是正则扫描每个模块中<code>require</code>的字符串，从而提取模块的依赖。加载模块时，首先加载其依赖文件，因此我们能够通过 combo 的方式把模块合并到一个文件。另外，seajs中提供 <code>require.async</code> 来实现异步加载。</p>\n\n<p>因此，我们在router里面转发到不同页面的时候使用 require.async，从而实现分子系统按需加载。</p>\n\n<p>优化结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/b.png\" alt=\"\" /></p>\n\n<p>首屏请求数量直接从899个优化到57个，结果还是可喜。</p>\n\n<h3 id=\"\">优化二：请求合并</h3>\n\n<p>观察请求瀑布流，发现请求文件还是太多，比如系统资源加载（class.js/events.js/overlay.js等)，还有业务代码较多，我们可以把这些资源合并在一起，发出combo请求。</p>\n\n<p>比如发出 </p>\n\n<pre><code>http://d.kuaidadi.com/path/??class.js,events.js,overlay.js,xxx.js\n</code></pre>\n\n<p>然后服务端响应此 combo 请求，返回 <code>class.js</code>, <code>events.js</code>, <code>overlay.js</code>, <code>xxx.js</code>的合集，这样就可以实现请求合并。</p>\n\n<p>首先，需要浏览器发出类似 <code>??a.js,b.js,c.js</code> 的combo请求。seajs发出combo请求很简单，通过<a href=\"https://github.com/seajs/seajs-combo/issues/3\">seajs combo插件</a>就可以了:</p>\n\n<pre><code> seajs.config({\n    preload: \"seajs-combo\"\n });\n</code></pre>\n\n<p>其次，需要服务器端响应类似 <code>??a.js,b.js,c.js</code> 的combo请求。</p>\n\n<p><a href=\"https://github.com/seajs/seajs-combo/issues/3\">seajs combo插件中文文档</a>中提到，服务端实现combo请求是通过<a href=\"https://github.com/taobao/nginx-http-concat\">Nginx-Http-Concat</a>实现。</p>\n\n<p>但是由于线上服务器是通过 Nginx 来实现数台生产机器间负载均衡，通过 <code>Nginx Proxy Pass</code>实现非80端转发到80端口。经过试验发现，Nginx的 <code>Proxy Pass</code> 和 <code>Nginx-Http-Concat</code>不能同时使用，其作者也说过<a href=\"https://www.zhihu.com/question/21313870/answer/17853844\">暂时不支持。</a>，所以此路不通。</p>\n\n<p>因此，只能自己实现Node Combo。于是又找了不少node-combo项目(比如<a href=\"https://github.com/xuexb/node-combo\">node-combo</a>)，研究其实现思路，准备自己写koa-node-combo插件了。</p>\n\n<p>后来搜索npm仓库，发现有多个这样的插件，尝试发现<a href=\"https://www.npmjs.com/package/koa-combo-parse\">koa-combo-parse</a>可行：</p>\n\n<pre><code>app.use(comboParse({\n    base: path.resolve(__dirname, '../client/')\n}));\n</code></pre>\n\n<p>但是，问题又来了。combo到一起后系统仍然不能运行，因为文件之间没有识别的id。需要寻找工具来对每个模版补全id和依赖(deps)，combo后就能互相识别了。即需要从：</p>\n\n<pre><code>define(function(require, exports, module){\n    var a = require('a'),\n        b = require('b'); \n    module.exports = {};\n});\n</code></pre>\n\n<p>变成：</p>\n\n<pre><code>define('moduleId', ['a', 'b'], function(require, exports, module){\n    var a = require('a'),\n        b = require('b');\n    module.exports = {};\n});\n</code></pre>\n\n<p>在此过程中调研了 <a href=\"https://github.com/spmjs/spm\">spm</a>、<a href=\"https://github.com/chenmnkken/gulp-seajs-combo\">gulp-seajs-combo</a>等，发现都不满足需求。</p>\n\n<p>于是自己实现了node小工具 <a href=\"https://www.npmjs.com/package/iddeps\">iddeps</a>，并写成了gulp插件<a href=\"https://www.npmjs.com/package/gulp-ids-deps\">gulp-ids-deps</a>。</p>\n\n<p>最终，前端发出combo请求后，后端响应combo请求，效果如下：</p>\n\n<p><img src=\"/content/images/2016/07/c-2.png\" alt=\"\" /></p>\n\n<p>请求数量从57减少到37，请求时间从1.4s减少到了1.18s。</p>\n\n<h3 id=\"\">优化三：模版文件预编译</h3>\n\n<p>从上面的瀑布流能看出，tpl文件既大又多，占用不少请求时间。</p>\n\n<p>在handlebars中，有预编译的思想，可以在运行前把模版文件预编译成为 js 文件。</p>\n\n<p>业界没有相应的工具，于是自己写了一个node小工具<a href=\"https://www.npmjs.com/package/tpl-2-js\">tpl-2-js</a>，并改写成gulp插件<a href=\"https://www.npmjs.com/package/gulp-tpl-2-js\">gulp-tpl-2-js</a>。</p>\n\n<p>Handlebars预编译的过程是：</p>\n\n<pre><code>   //  node\n   var preCompileData = handlebars.precompile(data);\n\n\n   // web \n   var Handlebars = require('handlebars'),\n    template = Handlebars.template;\n\n   template(preCompileData)({data});\n</code></pre>\n\n<p>预编译的过程，是<code>Handlebars precompile</code>创建了一个函数，把每个template存储在 Handlebars.templates里面。</p>\n\n<p>更多详细请看：<a href=\"https://github.com/freestyle21/gulp-tpl-2-js\">gulp-tpl-2-js</a></p>\n\n<p>经过模版预编译后、Combo后，效果如下：</p>\n\n<p><img src=\"/content/images/2016/07/d.png\" alt=\"\" /></p>\n\n<p>可以看到，请求结果从上次的37减少到29，请求时间从1.18s减少到998ms</p>\n\n<h2 id=\"\">后续</h2>\n\n<p>整体结果优化的效果差不多了，请求数变到最小，时间首屏时间也符合期望。</p>\n\n<p>后续的优化，可以考虑通过 html5 的 appcache 缓存不经常的更新资源文件，把 200 的资源文件变成 302。</p>\n\n<p>本文是记录自己优化系统的心路历程，有不同意见或者有所收获的可以留言讨论。</p>","image":"/content/images/2016/07/aa.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:35:25","created_by":1,"updated_at":"2016-07-19 14:30:14","updated_by":1,"published_at":"2015-12-29 23:35:00","published_by":1},{"id":85,"uuid":"61b6396b-b06e-42bc-8548-0091e467df91","title":"怎样选择前端框架","slug":"how-to-choose-f2e-framework-2","markdown":"## 怎样选择前端框架 \n>怎样选择适合自己的前端框架，并在高产但良莠不齐的前端社区中保持理性\n\n>翻译自：[http://fse.guru/](http://fse.guru/)\n\n\n## 介绍\n\nHello，开发朋友们！\n\n下面你将看到一些比较主观的工具和框架。\n\n但不要害怕！\n\n你可以选择任何你所熟悉的，或者忽略他们直接用你自己喜欢的就好了。\n\n本文希望帮助你了解前端社区中海量的工具。\n\n当然，这些只是一些可选的列表，当你需要做出选择的时候帮助你抉择。 \n\n## 我自己使用它吗？\n\n是的，当我需要开始项目的时候，我用它来作为提醒。\n\n同时，每当有人问“我该使用什么框架呢？”的时候，我就会把这篇文章给他看。\n\n因为，正如你明白的，事情没有绝对的对与错，但是有一些优质的框架能够帮助做出我们更好的选择。\n\n另外，我也会不时的更新本文，因为有时候当我学习更多后也会改变当初的想法。\n\n## 我应该怎样开始?\n\n如果你的项目不是很小，你应该需要下面几件事：\n\n1. 项目模块化 我个人比较喜欢 [Component-based architecture](http://benmccormick.org/2014/08/07/component-based-development/)，因为他适用于 [various-frameworks](http://derickbailey.com/2015/08/26/building-a-component-based-web-ui-with-modern-javascript-frameworks/)\n\n   同时，考虑一些其他的例子，比如 [BOT](http://www.chris-granger.com/2013/01/24/the-ide-as-data/) 、 [Elm Architecture](https://github.com/evancz/elm-architecture-tutorial/) 或者 [re-frame](https://github.com/Day8/re-frame) 或者 [CycleJS](http://cycle.js.org/)\n   \n2. 模块加载器([RequireJS](http://requirejs.org/)，[Browserify](http://requirejs.org/), [Webpack](https://webpack.github.io/), [ComponentJS](http://componentjs.com/), [SystemJS](https://github.com/systemjs/systemjs))\n\n   这些东西能够帮助我们保持Javascript(或者components)彼此独立和可维护。\n   \n3. 包管理器([npm](http://www.fse.guru/npmjs.org), [jspm](http://jspm.io/), [bower](http://bower.io/))\n   \n   我个人一直比较喜欢 npm ，似乎他是javascript和nodejs真正的标准。另外我会考虑bower来做补足，因为他是一个很好的下载静态资源的工具，但它在管理组件和依赖又不如npm强大。 \n\n4. 自动部署/编译/构建流水线([grunt](http://gruntjs.com/)/[gulp](http://gulpjs.com/)/[brunch](http://brunch.io/)/[broccoli](http://broccolijs.com/))\n   \n   因为，如果一直做重复的事情的话生命是很短暂的。\n\n5. CSS预处理([jss](https://github.com/kof/jss)/[stylus](http://learnboost.github.io/stylus/)/[sass](http://sass-lang.com/)/[css-modules](https://github.com/css-modules/css-modules))和 postprocessors([css0](http://css.github.io/csso/), [autoprefixer](https://github.com/postcss/autoprefixer), [postcss](https://github.com/postcss/postcss))\n  \n   这些工具使css更美好，去除了一些浏览器兼容的问题。是的，我是从2015知道这些的，但是不论如何，它在过去[确实是痛点](http://caniuse.com/#search=svg)。\n   \n6. 构建框架([Bootstrap](http://getbootstrap.com/), [Zurb Foundation](http://foundation.zurb.com/), [Elemental UI](http://elemental-ui.com/), [Material Lite](http://www.getmdl.io/))\n   \n   这些框架让很多web开发者合作，它们会帮助你处理基本的布局和样式。\n   \n   尽管，你可以考虑构建你自己的[解决方案](http://styleguides.io/)，如果你感觉构建很厉害或者希望成为前端专家，或者你需要为你的公司构建基本的[视觉元素](https://uxmag.com/articles/anchoring-your-design-language-in-a-live-style-guide)。\n   \n   如果是这样的话，建议你尽快使用方法论([BEM](https://en.bem.info/), [OOCSS](http://oocss.org/))，它们可以帮助你节约时间。\n   \n   我个人比较喜欢 BEM 命名方式和基本工作流，你能够从 [styleguide for Brainly.com](https://github.com/brainly/style-guide#methodology)找到一些可以帮助你的灵感。\n   \n   如果你不构建基本的组成，建议看一看 [HTML5 Boilerplate](https://html5boilerplate.com/)\n   \n\n7. 测试工具([jasmine](http://jasmine.github.io/), [karma](http://karma-runner.github.io/0.13/index.html), [mocha](https://mochajs.org/), [tape](https://github.com/substack/tape), [itern](https://theintern.github.io/))\n \n    任何人都需要测试，没有例外的。\n\n8. 代码质量监控工具([eslint](http://eslint.org/), [husky](https://medium.com/software-and-beyond), [editorconfig](http://editorconfig.org/))  \n\n9. 可以获取帮助的社区([chats](https://github.com/mr-mig/ru-it-chats), IRC, meetups, twitter)\n\n\n## 好了，下一步呢？\n\n在选择你的工具前有一些值得思考的问题需要解决。\n\n准备好了吗？\n\n\n1. 我需要和其他人合作吗？他们是谁？他们想要什么？\n   \n   这个问题会帮助你选择语言和工作流，这对你和你的伙伴都有帮助。\n   \n2. 我最关注什么？质量，开发速度，还是可维护性？\n\n   这样你可以决定是否试验一些新工具，以及是否能承担失败的风险。\n  \n3. 是否需要开放给第三方？\n   \n   面向的团队不同可能会限制我们语言的选择。\n \n4. 我是否在处理核心的项目  \n   \n   如果你处理核心项目，请最好选择高稳定性的语言和框架，这更安全，让你睡得更好。\n   \n5. 是一个可交互的app还是基本的文档页面。 \n\n   结果很可能是你仅仅需要基本的HTML ＋CSS ＋ tools，或者静态网站生成器或者CMS。\n\n6. 这是一个单一的项目还是其他项目的相关项目？\n   \n   即使你有一系列项目，你也应该用一些组件和样式引导，这些有不错的文档。\n   \n  直接减少代码重用，保持一致性。\n  \n  另外，考虑SEO，和服务端渲染。\n  \n\n## 语言列表\n\n当你回答完上面这些问题后，就可以和你的队友聊聊，然后选择一个语言了。\n\n因为这里有很多的东西，而不是[糟糕的Javascript](https://www.destroyallsoftware.com/talks/wat)，你可以选择\n\n1. 是否有js开发团队\n   \n   考虑[ES6](https://gist.github.com/getify/7ae82fdc2e86bf66bcba#file-gistfile1-md)([babel](https://babeljs.io/)兼容)\n   \n   这会让你的生活简单一些。\n   \n2. 你是否偏爱typed语言？开发typed是否可以？ \n   \n   考虑 [typescript](http://www.typescriptlang.org/)\n   \n3. 函数式编程是否接受？\n   \n   你可以从简单ES6库开始，比如 [lo-dash](https://lodash.com/) 或者 [ramda](http://ramdajs.com/docs/)。\n   \n   这里有一些[教程](http://reactivex.io/learnrx/)和[书](https://leanpub.com/javascript-allonge)来[帮助你](https://github.com/MostlyAdequate/mostly-adequate-guide)开始美好的旅行。\n \n4. 你是否尝试过函数式编程，想要更好的东西？\n   \n   试试 [elm](http://elm-lang.org/) ，很酷的！\n   \n5. 你是否能够全栈？\n  \n   试试 [clojurescript](https://github.com/clojure/clojurescript)，很酷很酷的\n  \n  \n6. 你喜欢沙拉吗？\n\n   试试[scalaJS](http://www.scala-js.org/)\n   \n   \n7. 你知道Haskell吗?\n   \n   试试 [purescript](http://www.purescript.org/)，真的很酷\n   \n8. 想要更多疯狂的？\n   \n   这里有一个可以编译成javascript的语言列表，选一个然后享受吧。\n   \n   \n## 框架列表\n\n1. 你仅仅需要基本的可运行的app？\n   \n   没有时间做更复杂的工作？\n   \n   试试 [angular](https://angularjs.org/). [start looking for help imediately](http://www.fse.guru/2-years-with-angular)\n   \n2. 你是否经常需要快速的原型开发？\n   \n     是否能在未来修复一些问题？\n     \n     试试 [angular](https://angularjs.org/). 一些[问题](http://www.fse.guru/2-years-with-angular)\n     \n3. 你是尝试前端开发的后端？\n   \n   试试 [angular](https://angularjs.org/). 寻找一些[前端开发者](http://www.fse.guru/2-years-with-angular)\n   \n4. 你是否需要很快的进行开发和构建，但是同时会丢失一些特点？\n   \n   试试  [ampersand](http://ampersandjs.com/)/[backbone](http://backbonejs.org/+)\n \n5. 同样的技术选型，怎样从中型到大型？\n\n   把 [marionette](http://marionettejs.com/)/[chaplin](http://chaplinjs.org/)添加到你的backbone里面去，另外可以考虑 [Reackjs](https://facebook.github.io/react/)\n   \n6. 你是否有一些时间来实验，同时得到很大的性能提升？\n   \n   试试[mithril](http://mithril.js.org/)/[knockout](http://knockoutjs.com/)/[aurelia](http://aurelia.io/)+\n   \n7. 你是否有不错的前端实验精神，对函数式编程熟悉？\n\n   试试 [ReactJS](https://facebook.github.io/react/)＋[Redux](https://github.com/rackt/redux)＋[ImmutableJS](https://facebook.github.io/immutable-js/)+\n   \n8. 更多函数式编程技巧？或者偏好交互性强的应用？ \n\n   使用 reactive streams([bacon](https://baconjs.github.io/), [rxJS](http://reactivex.io/)) 或者试试 [Cycle.js](http://cycle.js.org/)(实验性) \n   \n   注意1:  [add streams](http://www.felienne.com/archives/3724) any会是很好的选择，可以推荐别人使用。\n   \n   注意2: 请不要[拒绝使用 FRP的reactive streams ](https://youtu.be/Agu6jipKfYw?list=PLZlJZzHmx31XvgT96DfbXQ4IMb1ryztbp)\n   \n9. 你想要使用严格的验证和通用处理方式？\n\n   你的应用会越来越大？\n   \n   你计划扩充你的团队？\n   \n   你有时间学习新东西？\n   \n   建议花时间学习 [EmberJS](http://emberjs.com/)，他将会是很好的投资!\n   \n\n10. 你是否需要“类桌面应用”？\n \n     你的应用有表格，图例，或者其他分析功能？你在构建企业应用？\n     \n     试试 [ExtJS](http://emberjs.com/)\n     \n11. 你们是一个为其他开发者提供服务的工作室？\n \n     你最好有一个不错的工具集，另外，同事之间最好有一些公共用例。\n     \n     \n12. 你是一个为他人提供工具的自由开发者？\n \n     适应他们的选择。\n \n     尝试angular，这将不会造成多大麻烦，让其他人得到他们想要的。\n     \n     注意：如果别人付费，请不要改变客户的需求\n     \n13. 你正在构建一个有吸引力的产品，它将会很多人使用？\n\n    有了明确的需求后我们就从上面的列表中选择一个合适的框架。\n    \n14. 关于开发什么样的应用你有明确的需求（比如10屏的移动应用) \n\n    花两周时间来试验特定的需求（[ionic](http://ionicframework.com/), [famous](http://famous.org/), [Sencha Touch](https://www.sencha.com/products/touch/))\n    \n    \n## 怎样开始编码？\n\n1. 花一些时间阅读你所选择框架或者工具的文档。\n2. 在社区里面询问一些经验开发者怎样算是优秀项目的开端。\n3. 准备所有的工具。\n4. 极客精神。但是我建议更加[工程化](http://www.fse.guru/software-engineering-101-preface)一点。\n5. ...\n6. 成功。\n\n#### 不知道怎么用我介绍的一些不常见框架？\n\n看看 [TodoMVC Examples](https://github.com/tastejs/todomvc)，找到你选择的框架。\n\n但是记住，这些项目只是示例，大多数情况下他们不适合大中型项目。\n\n## 我不想做决定，告诉我怎么办？\n\n好，好，冷静下来。\n\n如果你不想做决定，你可以选择 EmberJS。或者你胆大，可以尝试 ReactJS + Redux + ES6 + webpack + npm + jss + autoprefixer + eslint + Elemental UI + karma，读[这篇文章](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html)。\n\n\n## 我看到了很多关于ReactJS的讨论，为什么？\n\n这是web开发的未来。\n\n这里有一片很好的[文章](http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome)，来解释这个现象。\n\n\n同时，很多优秀的开发者在使用它，你可以找出一些好的项目，这一定很棒，我保证！\n\n如果不是，你可以任何时候回到这篇文章，在评论里面留下你的话。\n\n\n如果你对怎样成为一名前端开发师感兴趣，可以看看[这里](https://news.ycombinator.com/item?id=10392731)","mobiledoc":null,"html":"<h2 id=\"\">怎样选择前端框架</h2>\n\n<blockquote>\n  <p>怎样选择适合自己的前端框架，并在高产但良莠不齐的前端社区中保持理性</p>\n  \n  <p>翻译自：<a href=\"http://fse.guru/\">http://fse.guru/</a></p>\n</blockquote>\n\n<h2 id=\"\">介绍</h2>\n\n<p>Hello，开发朋友们！</p>\n\n<p>下面你将看到一些比较主观的工具和框架。</p>\n\n<p>但不要害怕！</p>\n\n<p>你可以选择任何你所熟悉的，或者忽略他们直接用你自己喜欢的就好了。</p>\n\n<p>本文希望帮助你了解前端社区中海量的工具。</p>\n\n<p>当然，这些只是一些可选的列表，当你需要做出选择的时候帮助你抉择。 </p>\n\n<h2 id=\"\">我自己使用它吗？</h2>\n\n<p>是的，当我需要开始项目的时候，我用它来作为提醒。</p>\n\n<p>同时，每当有人问“我该使用什么框架呢？”的时候，我就会把这篇文章给他看。</p>\n\n<p>因为，正如你明白的，事情没有绝对的对与错，但是有一些优质的框架能够帮助做出我们更好的选择。</p>\n\n<p>另外，我也会不时的更新本文，因为有时候当我学习更多后也会改变当初的想法。</p>\n\n<h2 id=\"\">我应该怎样开始?</h2>\n\n<p>如果你的项目不是很小，你应该需要下面几件事：</p>\n\n<ol>\n<li><p>项目模块化 我个人比较喜欢 <a href=\"http://benmccormick.org/2014/08/07/component-based-development/\">Component-based architecture</a>，因为他适用于 <a href=\"http://derickbailey.com/2015/08/26/building-a-component-based-web-ui-with-modern-javascript-frameworks/\">various-frameworks</a></p>\n\n<p>同时，考虑一些其他的例子，比如 <a href=\"http://www.chris-granger.com/2013/01/24/the-ide-as-data/\">BOT</a> 、 <a href=\"https://github.com/evancz/elm-architecture-tutorial/\">Elm Architecture</a> 或者 <a href=\"https://github.com/Day8/re-frame\">re-frame</a> 或者 <a href=\"http://cycle.js.org/\">CycleJS</a></p></li>\n<li><p>模块加载器(<a href=\"http://requirejs.org/\">RequireJS</a>，<a href=\"http://requirejs.org/\">Browserify</a>, <a href=\"https://webpack.github.io/\">Webpack</a>, <a href=\"http://componentjs.com/\">ComponentJS</a>, <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>)</p>\n\n<p>这些东西能够帮助我们保持Javascript(或者components)彼此独立和可维护。</p></li>\n<li><p>包管理器(<a href=\"http://www.fse.guru/npmjs.org\">npm</a>, <a href=\"http://jspm.io/\">jspm</a>, <a href=\"http://bower.io/\">bower</a>)</p>\n\n<p>我个人一直比较喜欢 npm ，似乎他是javascript和nodejs真正的标准。另外我会考虑bower来做补足，因为他是一个很好的下载静态资源的工具，但它在管理组件和依赖又不如npm强大。 </p></li>\n<li><p>自动部署/编译/构建流水线(<a href=\"http://gruntjs.com/\">grunt</a>/<a href=\"http://gulpjs.com/\">gulp</a>/<a href=\"http://brunch.io/\">brunch</a>/<a href=\"http://broccolijs.com/\">broccoli</a>)</p>\n\n<p>因为，如果一直做重复的事情的话生命是很短暂的。</p></li>\n<li><p>CSS预处理(<a href=\"https://github.com/kof/jss\">jss</a>/<a href=\"http://learnboost.github.io/stylus/\">stylus</a>/<a href=\"http://sass-lang.com/\">sass</a>/<a href=\"https://github.com/css-modules/css-modules\">css-modules</a>)和 postprocessors(<a href=\"http://css.github.io/csso/\">css0</a>, <a href=\"https://github.com/postcss/autoprefixer\">autoprefixer</a>, <a href=\"https://github.com/postcss/postcss\">postcss</a>)</p>\n\n<p>这些工具使css更美好，去除了一些浏览器兼容的问题。是的，我是从2015知道这些的，但是不论如何，它在过去<a href=\"http://caniuse.com/#search=svg\">确实是痛点</a>。</p></li>\n<li><p>构建框架(<a href=\"http://getbootstrap.com/\">Bootstrap</a>, <a href=\"http://foundation.zurb.com/\">Zurb Foundation</a>, <a href=\"http://elemental-ui.com/\">Elemental UI</a>, <a href=\"http://www.getmdl.io/\">Material Lite</a>)</p>\n\n<p>这些框架让很多web开发者合作，它们会帮助你处理基本的布局和样式。</p>\n\n<p>尽管，你可以考虑构建你自己的<a href=\"http://styleguides.io/\">解决方案</a>，如果你感觉构建很厉害或者希望成为前端专家，或者你需要为你的公司构建基本的<a href=\"https://uxmag.com/articles/anchoring-your-design-language-in-a-live-style-guide\">视觉元素</a>。</p>\n\n<p>如果是这样的话，建议你尽快使用方法论(<a href=\"https://en.bem.info/\">BEM</a>, <a href=\"http://oocss.org/\">OOCSS</a>)，它们可以帮助你节约时间。</p>\n\n<p>我个人比较喜欢 BEM 命名方式和基本工作流，你能够从 <a href=\"https://github.com/brainly/style-guide#methodology\">styleguide for Brainly.com</a>找到一些可以帮助你的灵感。</p>\n\n<p>如果你不构建基本的组成，建议看一看 <a href=\"https://html5boilerplate.com/\">HTML5 Boilerplate</a></p></li>\n<li><p>测试工具(<a href=\"http://jasmine.github.io/\">jasmine</a>, <a href=\"http://karma-runner.github.io/0.13/index.html\">karma</a>, <a href=\"https://mochajs.org/\">mocha</a>, <a href=\"https://github.com/substack/tape\">tape</a>, <a href=\"https://theintern.github.io/\">itern</a>)</p>\n\n<p>任何人都需要测试，没有例外的。</p></li>\n<li><p>代码质量监控工具(<a href=\"http://eslint.org/\">eslint</a>, <a href=\"https://medium.com/software-and-beyond\">husky</a>, <a href=\"http://editorconfig.org/\">editorconfig</a>)  </p></li>\n<li><p>可以获取帮助的社区(<a href=\"https://github.com/mr-mig/ru-it-chats\">chats</a>, IRC, meetups, twitter)</p></li>\n</ol>\n\n<h2 id=\"\">好了，下一步呢？</h2>\n\n<p>在选择你的工具前有一些值得思考的问题需要解决。</p>\n\n<p>准备好了吗？</p>\n\n<ol>\n<li><p>我需要和其他人合作吗？他们是谁？他们想要什么？</p>\n\n<p>这个问题会帮助你选择语言和工作流，这对你和你的伙伴都有帮助。</p></li>\n<li><p>我最关注什么？质量，开发速度，还是可维护性？</p>\n\n<p>这样你可以决定是否试验一些新工具，以及是否能承担失败的风险。</p></li>\n<li><p>是否需要开放给第三方？</p>\n\n<p>面向的团队不同可能会限制我们语言的选择。</p></li>\n<li><p>我是否在处理核心的项目  </p>\n\n<p>如果你处理核心项目，请最好选择高稳定性的语言和框架，这更安全，让你睡得更好。</p></li>\n<li><p>是一个可交互的app还是基本的文档页面。 </p>\n\n<p>结果很可能是你仅仅需要基本的HTML ＋CSS ＋ tools，或者静态网站生成器或者CMS。</p></li>\n<li><p>这是一个单一的项目还是其他项目的相关项目？</p>\n\n<p>即使你有一系列项目，你也应该用一些组件和样式引导，这些有不错的文档。</p>\n\n<p>直接减少代码重用，保持一致性。</p>\n\n<p>另外，考虑SEO，和服务端渲染。</p></li>\n</ol>\n\n<h2 id=\"\">语言列表</h2>\n\n<p>当你回答完上面这些问题后，就可以和你的队友聊聊，然后选择一个语言了。</p>\n\n<p>因为这里有很多的东西，而不是<a href=\"https://www.destroyallsoftware.com/talks/wat\">糟糕的Javascript</a>，你可以选择</p>\n\n<ol>\n<li><p>是否有js开发团队</p>\n\n<p>考虑<a href=\"https://gist.github.com/getify/7ae82fdc2e86bf66bcba#file-gistfile1-md\">ES6</a>(<a href=\"https://babeljs.io/\">babel</a>兼容)</p>\n\n<p>这会让你的生活简单一些。</p></li>\n<li><p>你是否偏爱typed语言？开发typed是否可以？ </p>\n\n<p>考虑 <a href=\"http://www.typescriptlang.org/\">typescript</a></p></li>\n<li><p>函数式编程是否接受？</p>\n\n<p>你可以从简单ES6库开始，比如 <a href=\"https://lodash.com/\">lo-dash</a> 或者 <a href=\"http://ramdajs.com/docs/\">ramda</a>。</p>\n\n<p>这里有一些<a href=\"http://reactivex.io/learnrx/\">教程</a>和<a href=\"https://leanpub.com/javascript-allonge\">书</a>来<a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\">帮助你</a>开始美好的旅行。</p></li>\n<li><p>你是否尝试过函数式编程，想要更好的东西？</p>\n\n<p>试试 <a href=\"http://elm-lang.org/\">elm</a> ，很酷的！</p></li>\n<li><p>你是否能够全栈？</p>\n\n<p>试试 <a href=\"https://github.com/clojure/clojurescript\">clojurescript</a>，很酷很酷的</p></li>\n<li><p>你喜欢沙拉吗？</p>\n\n<p>试试<a href=\"http://www.scala-js.org/\">scalaJS</a></p></li>\n<li><p>你知道Haskell吗?</p>\n\n<p>试试 <a href=\"http://www.purescript.org/\">purescript</a>，真的很酷</p></li>\n<li><p>想要更多疯狂的？</p>\n\n<p>这里有一个可以编译成javascript的语言列表，选一个然后享受吧。</p></li>\n</ol>\n\n<h2 id=\"\">框架列表</h2>\n\n<ol>\n<li><p>你仅仅需要基本的可运行的app？</p>\n\n<p>没有时间做更复杂的工作？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. <a href=\"http://www.fse.guru/2-years-with-angular\">start looking for help imediately</a></p></li>\n<li><p>你是否经常需要快速的原型开发？</p>\n\n<p>是否能在未来修复一些问题？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. 一些<a href=\"http://www.fse.guru/2-years-with-angular\">问题</a></p></li>\n<li><p>你是尝试前端开发的后端？</p>\n\n<p>试试 <a href=\"https://angularjs.org/\">angular</a>. 寻找一些<a href=\"http://www.fse.guru/2-years-with-angular\">前端开发者</a></p></li>\n<li><p>你是否需要很快的进行开发和构建，但是同时会丢失一些特点？</p>\n\n<p>试试  <a href=\"http://ampersandjs.com/\">ampersand</a>/<a href=\"http://backbonejs.org/+\">backbone</a></p></li>\n<li><p>同样的技术选型，怎样从中型到大型？</p>\n\n<p>把 <a href=\"http://marionettejs.com/\">marionette</a>/<a href=\"http://chaplinjs.org/\">chaplin</a>添加到你的backbone里面去，另外可以考虑 <a href=\"https://facebook.github.io/react/\">Reackjs</a></p></li>\n<li><p>你是否有一些时间来实验，同时得到很大的性能提升？</p>\n\n<p>试试<a href=\"http://mithril.js.org/\">mithril</a>/<a href=\"http://knockoutjs.com/\">knockout</a>/<a href=\"http://aurelia.io/\">aurelia</a>+</p></li>\n<li><p>你是否有不错的前端实验精神，对函数式编程熟悉？</p>\n\n<p>试试 <a href=\"https://facebook.github.io/react/\">ReactJS</a>＋<a href=\"https://github.com/rackt/redux\">Redux</a>＋<a href=\"https://facebook.github.io/immutable-js/\">ImmutableJS</a>+</p></li>\n<li><p>更多函数式编程技巧？或者偏好交互性强的应用？ </p>\n\n<p>使用 reactive streams(<a href=\"https://baconjs.github.io/\">bacon</a>, <a href=\"http://reactivex.io/\">rxJS</a>) 或者试试 <a href=\"http://cycle.js.org/\">Cycle.js</a>(实验性) </p>\n\n<p>注意1:  <a href=\"http://www.felienne.com/archives/3724\">add streams</a> any会是很好的选择，可以推荐别人使用。</p>\n\n<p>注意2: 请不要<a href=\"https://youtu.be/Agu6jipKfYw?list=PLZlJZzHmx31XvgT96DfbXQ4IMb1ryztbp\">拒绝使用 FRP的reactive streams </a></p></li>\n<li><p>你想要使用严格的验证和通用处理方式？</p>\n\n<p>你的应用会越来越大？</p>\n\n<p>你计划扩充你的团队？</p>\n\n<p>你有时间学习新东西？</p>\n\n<p>建议花时间学习 <a href=\"http://emberjs.com/\">EmberJS</a>，他将会是很好的投资!</p></li>\n<li><p>你是否需要“类桌面应用”？</p>\n\n<p>你的应用有表格，图例，或者其他分析功能？你在构建企业应用？</p>\n\n<p>试试 <a href=\"http://emberjs.com/\">ExtJS</a></p></li>\n<li><p>你们是一个为其他开发者提供服务的工作室？</p>\n\n<p>你最好有一个不错的工具集，另外，同事之间最好有一些公共用例。</p></li>\n<li><p>你是一个为他人提供工具的自由开发者？</p>\n\n<p>适应他们的选择。</p>\n\n<p>尝试angular，这将不会造成多大麻烦，让其他人得到他们想要的。</p>\n\n<p>注意：如果别人付费，请不要改变客户的需求</p></li>\n<li><p>你正在构建一个有吸引力的产品，它将会很多人使用？</p>\n\n<p>有了明确的需求后我们就从上面的列表中选择一个合适的框架。</p></li>\n<li><p>关于开发什么样的应用你有明确的需求（比如10屏的移动应用) </p>\n\n<p>花两周时间来试验特定的需求（<a href=\"http://ionicframework.com/\">ionic</a>, <a href=\"http://famous.org/\">famous</a>, <a href=\"https://www.sencha.com/products/touch/\">Sencha Touch</a>)</p></li>\n</ol>\n\n<h2 id=\"\">怎样开始编码？</h2>\n\n<ol>\n<li>花一些时间阅读你所选择框架或者工具的文档。  </li>\n<li>在社区里面询问一些经验开发者怎样算是优秀项目的开端。  </li>\n<li>准备所有的工具。  </li>\n<li>极客精神。但是我建议更加<a href=\"http://www.fse.guru/software-engineering-101-preface\">工程化</a>一点。  </li>\n<li>...  </li>\n<li>成功。</li>\n</ol>\n\n<h4 id=\"\">不知道怎么用我介绍的一些不常见框架？</h4>\n\n<p>看看 <a href=\"https://github.com/tastejs/todomvc\">TodoMVC Examples</a>，找到你选择的框架。</p>\n\n<p>但是记住，这些项目只是示例，大多数情况下他们不适合大中型项目。</p>\n\n<h2 id=\"\">我不想做决定，告诉我怎么办？</h2>\n\n<p>好，好，冷静下来。</p>\n\n<p>如果你不想做决定，你可以选择 EmberJS。或者你胆大，可以尝试 ReactJS + Redux + ES6 + webpack + npm + jss + autoprefixer + eslint + Elemental UI + karma，读<a href=\"http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html\">这篇文章</a>。</p>\n\n<h2 id=\"reactjs\">我看到了很多关于ReactJS的讨论，为什么？</h2>\n\n<p>这是web开发的未来。</p>\n\n<p>这里有一片很好的<a href=\"http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome\">文章</a>，来解释这个现象。</p>\n\n<p>同时，很多优秀的开发者在使用它，你可以找出一些好的项目，这一定很棒，我保证！</p>\n\n<p>如果不是，你可以任何时候回到这篇文章，在评论里面留下你的话。</p>\n\n<p>如果你对怎样成为一名前端开发师感兴趣，可以看看<a href=\"https://news.ycombinator.com/item?id=10392731\">这里</a></p>","image":"/content/images/2016/07/intro-bg.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:44:50","created_by":1,"updated_at":"2016-07-19 13:54:13","updated_by":1,"published_at":"2015-12-21 23:44:00","published_by":1},{"id":86,"uuid":"f9118686-14ec-4c44-aa36-48c31ca25b4b","title":"前端地图截屏方案","slug":"map-screenshot-2","markdown":"截屏一直以来，都是客户端的专利，对于浏览器端可谓无能为力。\n\n不过，自从canvas出来以后，就不一样了。\n\nHTML5中canvas的方法，`toDataURL()` 可将canvas的内容保存为图片。\n\n简单保存canvas图片的代码如下：\n\n    function convertCanvasToImage(canvas) {\n        var image = new Image();\n        image.src = canvas.toDataURL(\"image/png\");\n        return image;\n    }\n\n对于普通canvas截图没有问题，甚至对于整个DOM树也可以先转换成canvas，然后转换成截图。业界有成熟的类似的类库 <a href=\"http://html2canvas.hertzen.com/\" title=\"http://html2canvas.hertzen.com/\" target=\"_blank\">html2canvas</a> 。\n\n### 问题\n\n工作中，需要对地图截图，遇到不少问题，折腾了很久，在此记录。\n\n原图：\n\n![](/content/images/2016/07/canvas_a.png)\n\n最后的截图代码：\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/jevisixezi/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n\n### 问题一 跨域\n\n截图失败，浏览器提示：`Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.`\n\n为什么会出现跨域问题呢？仔细一想，地图上有一些图片，存储在地图服务商的服务器，当我们toDataURL的时候取不到图片数据，跨域也就能够想通了。\n\n解决方式，暂时不获取跨域图片，直接try catch掉。暂时能够截图，看到的效果:\n \n\n![](/content/images/2016/07/canvas_b.png)\n\n### 问题二 圆角模糊\n\n如上图中，圆形中间多了一个叉，暂时不知道原因，解决方式是在截图前去除圆角。\n\n![](/content/images/2016/07/canvas_c.png)\n\n### 问题三 图片不显示\n\n其实是问题一留下的问题，截图左下角，有个高德的图片没有显示，问题一解决方式是绕过，但问题还是要解决。\n\n在服务器端，是不存在跨域。所以，问题三的解决方式，我们可以在本地起一个代理服务器，代理通过获取图片，然后设置setHeader('Access-Control-Allow-Headers', '*’); 然后给本地浏览器使用。\n\n代理服务器代码：\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fakizitulu/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n通过服务器跨域，然后允许所有访问图片，就可以跨域了。\n\n### 问题四 地理名称不显示\n\n通过上图可以看到，地图截图所有的地理位置名称都没有。打开log后可以看到，问题还是出在跨域上。地图所有的地理位置名称也是通过图片实现，图片存在地图服务商的服务器上，通过canvas渲染，和问题三的单纯的图片不太一样。\n\n要解决这个问题，必须地图服务器设置Header为”Access-Control-Allow-Headers: *”。通过公司关系，和高德产品经理、开发联系过，对方回答没办法设置这个，处于安全考虑。于是，这个问题无解。\n\n最后效果：\n\n![](/content/images/2016/07/canvas_e.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","mobiledoc":null,"html":"<p>截屏一直以来，都是客户端的专利，对于浏览器端可谓无能为力。</p>\n\n<p>不过，自从canvas出来以后，就不一样了。</p>\n\n<p>HTML5中canvas的方法，<code>toDataURL()</code> 可将canvas的内容保存为图片。</p>\n\n<p>简单保存canvas图片的代码如下：</p>\n\n<pre><code>function convertCanvasToImage(canvas) {\n    var image = new Image();\n    image.src = canvas.toDataURL(\"image/png\");\n    return image;\n}\n</code></pre>\n\n<p>对于普通canvas截图没有问题，甚至对于整个DOM树也可以先转换成canvas，然后转换成截图。业界有成熟的类似的类库 <a href=\"http://html2canvas.hertzen.com/\" title=\"http://html2canvas.hertzen.com/\" target=\"_blank\">html2canvas</a> 。</p>\n\n<h3 id=\"\">问题</h3>\n\n<p>工作中，需要对地图截图，遇到不少问题，折腾了很久，在此记录。</p>\n\n<p>原图：</p>\n\n<p><img src=\"/content/images/2016/07/canvas_a.png\" alt=\"\" /></p>\n\n<p>最后的截图代码：</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/jevisixezi/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<h3 id=\"\">问题一 跨域</h3>\n\n<p>截图失败，浏览器提示：<code>Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.</code></p>\n\n<p>为什么会出现跨域问题呢？仔细一想，地图上有一些图片，存储在地图服务商的服务器，当我们toDataURL的时候取不到图片数据，跨域也就能够想通了。</p>\n\n<p>解决方式，暂时不获取跨域图片，直接try catch掉。暂时能够截图，看到的效果:</p>\n\n<p><img src=\"/content/images/2016/07/canvas_b.png\" alt=\"\" /></p>\n\n<h3 id=\"\">问题二 圆角模糊</h3>\n\n<p>如上图中，圆形中间多了一个叉，暂时不知道原因，解决方式是在截图前去除圆角。</p>\n\n<p><img src=\"/content/images/2016/07/canvas_c.png\" alt=\"\" /></p>\n\n<h3 id=\"\">问题三 图片不显示</h3>\n\n<p>其实是问题一留下的问题，截图左下角，有个高德的图片没有显示，问题一解决方式是绕过，但问题还是要解决。</p>\n\n<p>在服务器端，是不存在跨域。所以，问题三的解决方式，我们可以在本地起一个代理服务器，代理通过获取图片，然后设置setHeader('Access-Control-Allow-Headers', '*’); 然后给本地浏览器使用。</p>\n\n<p>代理服务器代码：</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/fakizitulu/embed?js\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<p>通过服务器跨域，然后允许所有访问图片，就可以跨域了。</p>\n\n<h3 id=\"\">问题四 地理名称不显示</h3>\n\n<p>通过上图可以看到，地图截图所有的地理位置名称都没有。打开log后可以看到，问题还是出在跨域上。地图所有的地理位置名称也是通过图片实现，图片存在地图服务商的服务器上，通过canvas渲染，和问题三的单纯的图片不太一样。</p>\n\n<p>要解决这个问题，必须地图服务器设置Header为”Access-Control-Allow-Headers: *”。通过公司关系，和高德产品经理、开发联系过，对方回答没办法设置这个，处于安全考虑。于是，这个问题无解。</p>\n\n<p>最后效果：</p>\n\n<p><img src=\"/content/images/2016/07/canvas_e.png\" alt=\"\" /></p>","image":"/content/images/2016/07/g.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:47:29","created_by":1,"updated_at":"2016-07-19 13:55:25","updated_by":1,"published_at":"2015-10-08 23:47:00","published_by":1},{"id":87,"uuid":"ecc110e1-fa76-4b4c-a1af-f9d1d1e4b02e","title":"不一样的山顶角","slug":"san-ding-jiao-2","markdown":"说到“山顶角”，相信大多数前端人都能够在几秒内想到实现方式、兼容方式。\n\n如果不清楚山顶角的同学，请点这里: [https://css-tricks.com/snippets/css/css-triangle](https://css-tricks.com/snippets/css/css-triangle)\n\n但是，如果要实现下面这样的带阴影的山顶角，border的实现方式就无能为力了。\n\n![](/content/images/2016/07/sanjiao1.png)\n\n上图中的小三角，其阴影和整个弹窗的阴影大小要一样。\n\n实现\n--------\n\n###方案一 图片\n\n最省力，最直接，但是最不优雅。\n\n### 方案二 Unicode\n\n使用unicode生成一个三角，然后text-shadow实现阴影\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/jiromanopo/embed?html,css,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n\n可以通过 scaleX实现大小，通过text-shadow实现阴影范围。\n\n\n### 方案三 Rotate\n\n小矩形定位到需要的位置\n\n![](/content/images/2016/07/sanjiao3.png)\n\n然后旋转45度:  \n\n```\n-webkit-transform: translateY(-15px) rotate(45deg);\n```\n\n![](/content/images/2016/07/sanjiao4.png)\n\n缺点就是，兼容浏览器比较麻烦，ie里面还要动用 滤镜。\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/nexeqaxula/embed?html,css,output\">带阴影的山顶角 on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script>\n","mobiledoc":null,"html":"<p>说到“山顶角”，相信大多数前端人都能够在几秒内想到实现方式、兼容方式。</p>\n\n<p>如果不清楚山顶角的同学，请点这里: <a href=\"https://css-tricks.com/snippets/css/css-triangle\">https://css-tricks.com/snippets/css/css-triangle</a></p>\n\n<p>但是，如果要实现下面这样的带阴影的山顶角，border的实现方式就无能为力了。</p>\n\n<p><img src=\"/content/images/2016/07/sanjiao1.png\" alt=\"\" /></p>\n\n<p>上图中的小三角，其阴影和整个弹窗的阴影大小要一样。</p>\n\n<h2 id=\"\">实现</h2>\n\n<h3 id=\"\">方案一 图片</h3>\n\n<p>最省力，最直接，但是最不优雅。</p>\n\n<h3 id=\"unicode\">方案二 Unicode</h3>\n\n<p>使用unicode生成一个三角，然后text-shadow实现阴影</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/jiromanopo/embed?html,css,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>\n\n<p>可以通过 scaleX实现大小，通过text-shadow实现阴影范围。</p>\n\n<h3 id=\"rotate\">方案三 Rotate</h3>\n\n<p>小矩形定位到需要的位置</p>\n\n<p><img src=\"/content/images/2016/07/sanjiao3.png\" alt=\"\" /></p>\n\n<p>然后旋转45度:  </p>\n\n<pre><code>-webkit-transform: translateY(-15px) rotate(45deg);\n</code></pre>\n\n<p><img src=\"/content/images/2016/07/sanjiao4.png\" alt=\"\" /></p>\n\n<p>缺点就是，兼容浏览器比较麻烦，ie里面还要动用 滤镜。</p>\n\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/nexeqaxula/embed?html,css,output\">带阴影的山顶角 on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.0\"></script></p>","image":"/content/images/2016/07/a.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-05 23:54:52","created_by":1,"updated_at":"2016-07-19 13:55:38","updated_by":1,"published_at":"2015-10-07 23:54:00","published_by":1},{"id":88,"uuid":"e52962a4-ceab-48b3-bc72-0a47966298d5","title":"前后端分离场景下的另类登录认证方案","slug":"f2e-another-auth-2","markdown":"在我们日常开发中，通常会接入第三方的登录，比如QQ、微信、微博等。在公司内部，也会介入公司的内网登录。通常情况下，我们的方案是：\n\n![](/content/images/2016/07/a.png)\n\n当应用检测到没有用户信息时，就会跳转到(302)第三方服务，用户在第三方服务登录后返回应用时会带上用户的信息(Session)，这就是一般情况下我们的登录认证过程。\n\n<hr>\n\n在前后端分离的场景下，一般做法是中间层(Node)检查用户请求的Header中是否存在用户信息，如果不存在则向第三方服务请求认证(302)，认证成功后返回当前的登录用户的信息，再进行其他业务逻辑的处理。\n\n既然标题有另类一词，我们肯定不能局限于“一般做法”。在我们的前后端分离场景中，由Node充当中间层，Java提供HTTP Restful接口，我们场景不同点在于**第三方服务（通常是集团登录认证服务）不支持Node接口**，只提供Java接口。所以我们必须通过 Node去请求Java，由Java去请求认证服务然后返回Node。方案如下：\n\n![](/content/images/2016/07/b--1-.png)\n\n看上面流程图，我们的方案不过是在Node和Auth Server中增加了Java Server，并没有其他异处。只因这个方案和一般前后端分离场景的认证不太一样，里面的需要注意的细节较多，可以记录一下。\n\n首先是用户通过url的输入，访问页面的过程，流程如下：\n\n![](/content/images/2016/07/c--1-.png)\n\n**讲解之前注意：**\n\n>在我们的场景中：\n\n>Node与Java Web的Ajax要么带有效cookie，要么带tickets(一次有效)。\n\n>我们的页面是 http://localhost\n\n浏览器通过url访问Node服务器(即页面请求)，Node会检测用户的请求里面是否带有用户信息的Cookie。如果没有，则向Java Web发出用户信息的请求，由于没有有效cookie，Java Web判定当前用户未登录，返回 `{code:302, url: xxx}`。Node接收到302后，直接 redirect 到刚才的url上。这个url通常是: `http://www.xxx.com?redirect=http://localhost`\n\n用户在Home(第三方登录认证服务)完成登录过程后，会返回我们的localhost，并且带有tickets: `http://localhost?tickets=asdfasdfasdfasdf。`\n\n第二次，我们又回到了页面请求的步骤，同理Node检测不到用户请求中的用户信息有效Cookie，会向Java Web出用户信息的请求，不同之处在于会带上刚才Home返回的url上的tickets。Java Web发现请求中没有cookie但是有tickets，于是拿着tickets去向Home认证，此tickets是否有效，有效Home会返回用户信息，Java Web存储此用户信息并且返回给Node。Node拿到用户信息后，立即往response里面写入用户cookie，同时redirect到/(作用是，去掉url上的tickets)。\n\n第三次浏览器向Node发出页面请求，由于Node检测到请求中有cookie，就会直接返回页面给浏览器。之后用户的所有行为操作的ajax请求，都会带上cookie，所以都是合法的。\n\n---\n\n**思考：**\n\n上面认证方案中，其实只需要发出两次页面请求，也就是访问两次 localhost。我们第三次redirect的原因是，去掉url的tickets。如果不去掉也没有影响，但是会出现用户手动去刷新页面的情况，手动刷新页面的tickets是不可用的，java会返回403，影响用户使用。\n\n**总结：**\n\n我们的认证登录方案，和传统的方案并无差别，不过多了中间Node和Java的交互而已。需要注意的就是cookie的写入时机和tickets的去除。","mobiledoc":null,"html":"<p>在我们日常开发中，通常会接入第三方的登录，比如QQ、微信、微博等。在公司内部，也会介入公司的内网登录。通常情况下，我们的方案是：</p>\n\n<p><img src=\"/content/images/2016/07/a.png\" alt=\"\" /></p>\n\n<p>当应用检测到没有用户信息时，就会跳转到(302)第三方服务，用户在第三方服务登录后返回应用时会带上用户的信息(Session)，这就是一般情况下我们的登录认证过程。</p>\n\n<hr>\n\n<p>在前后端分离的场景下，一般做法是中间层(Node)检查用户请求的Header中是否存在用户信息，如果不存在则向第三方服务请求认证(302)，认证成功后返回当前的登录用户的信息，再进行其他业务逻辑的处理。</p>\n\n<p>既然标题有另类一词，我们肯定不能局限于“一般做法”。在我们的前后端分离场景中，由Node充当中间层，Java提供HTTP Restful接口，我们场景不同点在于<strong>第三方服务（通常是集团登录认证服务）不支持Node接口</strong>，只提供Java接口。所以我们必须通过 Node去请求Java，由Java去请求认证服务然后返回Node。方案如下：</p>\n\n<p><img src=\"/content/images/2016/07/b--1-.png\" alt=\"\" /></p>\n\n<p>看上面流程图，我们的方案不过是在Node和Auth Server中增加了Java Server，并没有其他异处。只因这个方案和一般前后端分离场景的认证不太一样，里面的需要注意的细节较多，可以记录一下。</p>\n\n<p>首先是用户通过url的输入，访问页面的过程，流程如下：</p>\n\n<p><img src=\"/content/images/2016/07/c--1-.png\" alt=\"\" /></p>\n\n<p><strong>讲解之前注意：</strong></p>\n\n<blockquote>\n  <p>在我们的场景中：</p>\n  \n  <p>Node与Java Web的Ajax要么带有效cookie，要么带tickets(一次有效)。</p>\n  \n  <p>我们的页面是 <a href=\"http://localhost\">http://localhost</a></p>\n</blockquote>\n\n<p>浏览器通过url访问Node服务器(即页面请求)，Node会检测用户的请求里面是否带有用户信息的Cookie。如果没有，则向Java Web发出用户信息的请求，由于没有有效cookie，Java Web判定当前用户未登录，返回 <code>{code:302, url: xxx}</code>。Node接收到302后，直接 redirect 到刚才的url上。这个url通常是: <code>http://www.xxx.com?redirect=http://localhost</code></p>\n\n<p>用户在Home(第三方登录认证服务)完成登录过程后，会返回我们的localhost，并且带有tickets: <code>http://localhost?tickets=asdfasdfasdfasdf。</code></p>\n\n<p>第二次，我们又回到了页面请求的步骤，同理Node检测不到用户请求中的用户信息有效Cookie，会向Java Web出用户信息的请求，不同之处在于会带上刚才Home返回的url上的tickets。Java Web发现请求中没有cookie但是有tickets，于是拿着tickets去向Home认证，此tickets是否有效，有效Home会返回用户信息，Java Web存储此用户信息并且返回给Node。Node拿到用户信息后，立即往response里面写入用户cookie，同时redirect到/(作用是，去掉url上的tickets)。</p>\n\n<p>第三次浏览器向Node发出页面请求，由于Node检测到请求中有cookie，就会直接返回页面给浏览器。之后用户的所有行为操作的ajax请求，都会带上cookie，所以都是合法的。</p>\n\n<hr />\n\n<p><strong>思考：</strong></p>\n\n<p>上面认证方案中，其实只需要发出两次页面请求，也就是访问两次 localhost。我们第三次redirect的原因是，去掉url的tickets。如果不去掉也没有影响，但是会出现用户手动去刷新页面的情况，手动刷新页面的tickets是不可用的，java会返回403，影响用户使用。</p>\n\n<p><strong>总结：</strong></p>\n\n<p>我们的认证登录方案，和传统的方案并无差别，不过多了中间Node和Java的交互而已。需要注意的就是cookie的写入时机和tickets的去除。</p>","image":"/content/images/2016/07/c--1--1.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-06 00:13:57","created_by":1,"updated_at":"2016-07-19 13:55:52","updated_by":1,"published_at":"2015-10-07 00:13:00","published_by":1},{"id":89,"uuid":"fed36067-13f7-493f-9540-6c06f40914f4","title":"React Diff 算法","slug":"react-diff-2","markdown":"## React介绍\n\nReact是Facebook开发的一款JS库，用于构建用户界面的类库。\n\n它采用声明式范例，可以传递声明代码，最大限度地减少与DOM的交互。\n\n特点：\n\n1. 声明式设计：React采用声明范式，你可以轻松描述你的应用\n2. 高效：React通过对DOM的模拟表现，最大限度地较少与DOM的交互。\n3. 灵活：React可以与你所知道的库或框架很好地工作。\n\n在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而**复杂或频繁的DOM操作通常是性能瓶颈产生的原因**。\n\n\nReact为此引入了虚拟DOM（Virtual DOM）的机制：\n\n**在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的虚拟DOM树进行对比，得到虚拟DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。**\n\n## React Diff 算法\n\n虚拟DOM作为React的一大核心技术，了解其实现原理对于灵活应用有着很大帮助。\n\n#### Javascript 虚拟DOM对象\n\n在我们项目中申明一个组件是这样的：\n\n    \n    react.createElement('div', null, [\n        // 创建一个img\n        react.createElement('img', { src: \"avatar.png\", class: \"profile\" }),\n        // 或者\n        react.createElement('h1', null, [[user.firstName, user.lastName].join(' ')])\n    ]);\n\n最后，React都会转换成类似这样的基本对象：\n    \n    {\n        tagName: 'div',\n        // 节点包含的属性\n        properties: {\n            style: {\n                color: '#fff'\n            }\n        },\n        // 子节点\n        children: [],\n        // 节点的唯一标识\n        key: 1\n    }\n\n#### Javascript DOM节点树\n然后，React把Javascript DOM模对象 转换成 Javascript DOM节点树：\n    \n    function create(vds, parent) {\n      !Array.isArray(vds) && (vds = [vds]);\n      // 如果没有父元素则创建个fragment来当父元素\n      parent = parent || document.createDocumentFragment();\n      var node;\n      vds.forEach(function (vd) {\n        // 如果是文字节点\n        if (isText(vd)) {\n          // 创建文字节点\n          node = document.createTextNode(vd.text);\n        } else {\n          // 创建元素\n          node = document.createElement(vd.tag);\n        }\n        // 将元素塞入父容器\n        parent.appendChild(node);\n        // 看看有没有子VNode，有孩子则处理孩子VNode\n        vd.children && vd.children.length &&\n          create(vd.children, node);\n        // 看看有没有属性，有则处理属性\n        vd.properties &&\n          setProps({ style: {} }, vd.properties, node);\n      });\n      return parent;\n    }\n\n#### Diff\n\n现在我们得到的是Javascript 实现的虚拟DOM树，在一个事件循环中，当state或者preps变化时，React会创建一个新的虚拟DOM树，最后进行差异渲染。\n\ndiff(previous:VTree, current:VTree) -> PatchObject\n\nReact分三种情景：\n\n<br>\n\n**1. 分层对比**\n\n![](/content/images/2016/07/layer.png)\n\nReact 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。\n\n**2. 基于key匹配**\n\n![](/content/images/2016/07/key.png)\n\nKeys是一个VNode的唯一识别，用于对两个不同的VTree中的VNode做匹配的。通过key锁定某个组件后，React就可以直接对比这两个差异DOM节点树，复杂度为O(n)。\n\n\n所以这里有个性能优化的技巧。假设你有一个key组件，他的key属性为foo，后续又将它改为bar，那么React就会掉过DOM diff，同时完全弃置div所有自元素，从头渲染。在渲染大型子树以避免diff计算时，这样的设计很有用，因为我们知道这种计算就是在浪费时间。\n\n**3. 基于自定义元素做优化**\n\n![](/content/images/2016/07/component.png)\n\nReact提供自定义元素，所以匹配很简单。React 只会匹配相同 class 的 component。\n\n比如, 如果有个`<Header>`被`<ExampleBlock>`替换掉了,\nReact 会删除掉 header 再创建一个`example block`。我们不需要化宝贵的时间去匹配两个不大可能有相似之处的 component。\n\n## 结束\n\nReact在你调用 component 的 setState 方法的时候, 将其标记为 dirty，到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。每次调用 setState 会重新计算整个子树.如果你想要提高性能, 尽量少调用 setState。\n\n\n最后, 你还有可能去掉一些子树的重新渲染，如果你在 component 上实现function shouldComponentUpdate(nextProps, nextState) 的话，你根据 component 的前一个和下一个 props/state，告诉 React 这个 component 没有更新, 也不需要重新绘制。\n\n","mobiledoc":null,"html":"<h2 id=\"react\">React介绍</h2>\n\n<p>React是Facebook开发的一款JS库，用于构建用户界面的类库。</p>\n\n<p>它采用声明式范例，可以传递声明代码，最大限度地减少与DOM的交互。</p>\n\n<p>特点：</p>\n\n<ol>\n<li>声明式设计：React采用声明范式，你可以轻松描述你的应用  </li>\n<li>高效：React通过对DOM的模拟表现，最大限度地较少与DOM的交互。  </li>\n<li>灵活：React可以与你所知道的库或框架很好地工作。</li>\n</ol>\n\n<p>在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而<strong>复杂或频繁的DOM操作通常是性能瓶颈产生的原因</strong>。</p>\n\n<p>React为此引入了虚拟DOM（Virtual DOM）的机制：</p>\n\n<p><strong>在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的虚拟DOM树进行对比，得到虚拟DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。</strong></p>\n\n<h2 id=\"reactdiff\">React Diff 算法</h2>\n\n<p>虚拟DOM作为React的一大核心技术，了解其实现原理对于灵活应用有着很大帮助。</p>\n\n<h4 id=\"javascriptdom\">Javascript 虚拟DOM对象</h4>\n\n<p>在我们项目中申明一个组件是这样的：</p>\n\n<pre><code>react.createElement('div', null, [\n    // 创建一个img\n    react.createElement('img', { src: \"avatar.png\", class: \"profile\" }),\n    // 或者\n    react.createElement('h1', null, [[user.firstName, user.lastName].join(' ')])\n]);\n</code></pre>\n\n<p>最后，React都会转换成类似这样的基本对象：</p>\n\n<pre><code>{\n    tagName: 'div',\n    // 节点包含的属性\n    properties: {\n        style: {\n            color: '#fff'\n        }\n    },\n    // 子节点\n    children: [],\n    // 节点的唯一标识\n    key: 1\n}\n</code></pre>\n\n<h4 id=\"javascriptdom\">Javascript DOM节点树</h4>\n\n<p>然后，React把Javascript DOM模对象 转换成 Javascript DOM节点树：</p>\n\n<pre><code>function create(vds, parent) {\n  !Array.isArray(vds) &amp;&amp; (vds = [vds]);\n  // 如果没有父元素则创建个fragment来当父元素\n  parent = parent || document.createDocumentFragment();\n  var node;\n  vds.forEach(function (vd) {\n    // 如果是文字节点\n    if (isText(vd)) {\n      // 创建文字节点\n      node = document.createTextNode(vd.text);\n    } else {\n      // 创建元素\n      node = document.createElement(vd.tag);\n    }\n    // 将元素塞入父容器\n    parent.appendChild(node);\n    // 看看有没有子VNode，有孩子则处理孩子VNode\n    vd.children &amp;&amp; vd.children.length &amp;&amp;\n      create(vd.children, node);\n    // 看看有没有属性，有则处理属性\n    vd.properties &amp;&amp;\n      setProps({ style: {} }, vd.properties, node);\n  });\n  return parent;\n}\n</code></pre>\n\n<h4 id=\"diff\">Diff</h4>\n\n<p>现在我们得到的是Javascript 实现的虚拟DOM树，在一个事件循环中，当state或者preps变化时，React会创建一个新的虚拟DOM树，最后进行差异渲染。</p>\n\n<p>diff(previous:VTree, current:VTree) -> PatchObject</p>\n\n<p>React分三种情景：</p>\n\n<p><br></p>\n\n<p><strong>1. 分层对比</strong></p>\n\n<p><img src=\"/content/images/2016/07/layer.png\" alt=\"\" /></p>\n\n<p>React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。</p>\n\n<p><strong>2. 基于key匹配</strong></p>\n\n<p><img src=\"/content/images/2016/07/key.png\" alt=\"\" /></p>\n\n<p>Keys是一个VNode的唯一识别，用于对两个不同的VTree中的VNode做匹配的。通过key锁定某个组件后，React就可以直接对比这两个差异DOM节点树，复杂度为O(n)。</p>\n\n<p>所以这里有个性能优化的技巧。假设你有一个key组件，他的key属性为foo，后续又将它改为bar，那么React就会掉过DOM diff，同时完全弃置div所有自元素，从头渲染。在渲染大型子树以避免diff计算时，这样的设计很有用，因为我们知道这种计算就是在浪费时间。</p>\n\n<p><strong>3. 基于自定义元素做优化</strong></p>\n\n<p><img src=\"/content/images/2016/07/component.png\" alt=\"\" /></p>\n\n<p>React提供自定义元素，所以匹配很简单。React 只会匹配相同 class 的 component。</p>\n\n<p>比如, 如果有个<code>&lt;Header&gt;</code>被<code>&lt;ExampleBlock&gt;</code>替换掉了,\nReact 会删除掉 header 再创建一个<code>example block</code>。我们不需要化宝贵的时间去匹配两个不大可能有相似之处的 component。</p>\n\n<h2 id=\"\">结束</h2>\n\n<p>React在你调用 component 的 setState 方法的时候, 将其标记为 dirty，到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。每次调用 setState 会重新计算整个子树.如果你想要提高性能, 尽量少调用 setState。</p>\n\n<p>最后, 你还有可能去掉一些子树的重新渲染，如果你在 component 上实现function shouldComponentUpdate(nextProps, nextState) 的话，你根据 component 的前一个和下一个 props/state，告诉 React 这个 component 没有更新, 也不需要重新绘制。</p>","image":"/content/images/2016/07/download.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:20:52","created_by":1,"updated_at":"2016-07-19 13:56:30","updated_by":1,"published_at":"2015-06-21 13:20:00","published_by":1},{"id":90,"uuid":"232ca5e3-dffc-469b-8325-82a6131e3bab","title":"纯css实现Magicline Navigation(下划线动画导航菜单)","slug":"magicline-navigation-2","markdown":"![](/content/images/2016/07/a1.jpg)\n\n看别人网站的时候，看到一种导航菜单的动画，觉得很有意思，就仔细研究起来。\n\n目前见过的动画有三种：水平下划线动画导航、水平背景动画导航、垂直动画导航，他们实现思路都是一样的，都是依赖 css3的同级通用选择器 \"~\" 。\n\n自己实现了一遍，本文简要记录实现的思想。\n\n大家可以先看看最后实现的效果：<a href=\"http://output.jsbin.com/legipibayi\" target=\"_blank\">Demo点我</a>\n\n## 实现思路\n\n#### HTML 结构\n\nHTML结构没有特殊，就是 ul -> li:\n\n    <ul class=\"a\">\n      <li class=\"n1\"><a href=\"#\">Navigator A</a></li>\n      <li class=\"n2\"><a href=\"#\">Navigator B</a></li>\n      <li class=\"n3 selected\"><a href=\"#\">Navigator C</a></li>\n      <li class=\"n4\"><a href=\"#\">Navigator D</a></li>\n      <li class=\"quebec\">&nbsp;</li>\n    </ul>\n\n最后一个li空着，留着后面有用。\n\n\n#### CSS 布局\n\n实现基本样式，不多解释：\n        \n            \n      ul {\n        position: relative;\n        overflow: hidden;\n        padding-left: 0px;\n      }\n      li {\n            list-style: none outside;\n            position: relative;\n            z-index: 1;\n            float: left;\n            padding: 0 0 0 0;\n            margin-right: 10px;\n        }\n        li a {\n            position: relative;\n            width: 100px;\n            color:#333 ;\n            display: block;\n            margin: 0 0;\n            border-bottom: 5px solid transparent;\n            padding: 10px 0;\n            text-align: center;\n            text-decoration: none;\n        }\n        .selected a {\n            border-bottom: 5px solid #cfd0d0;\n            color: #511d7f;\n        }\n\n#### 实现导航下划线\n\n下面实现动画部分。\n\n下方紫色滚动条是通过，刚才留着的最后一个li元素实现。\n\n     .quebec {\n          position: absolute;\n          bottom: 0px;\n          left: -100px;\n          z-index: 3;\n          margin: 0;\n          border: 0;\n          width: 5px;\n          height: 5px;\n          padding: 0;\n          overflow: hidden;\n          background: #511d7f;\n\n         -webkit-transition-property: left, width;\n         -moz-transition-property: left, width;\n         -ms-transition-property: left, width;\n         -o-transition-property: left, width;\n         transition-property: left, width;\n\n         -webkit-transition-duration: .5s;\n         -moz-transition-duration: .5s;\n         -ms-transition-duration: .5s;\n         -o-transition-duration: .5s;\n         transition-duration: .5s;\n      }\n\n通过绝对定位，把最后一个 li.quebec 定位到导航下方，设置宽度高度。设置 transition，当我们改变 left, width的时候就能实现动画。\n\n#### 动起来\n\n当hover到导航上面的时候，li.quebec 就定位left到其下面。实现这个效果的是css3的同级通用选择器 “～”\n\n比如 A ~ B 匹配的是 **任何在A元素之后的同级B元素**。\n\n          \n      .n1:hover ~ li.quebec { left: 5px; width: 110px; }\n      .n2:hover ~ li.quebec { left: 115px; width: 110px; }\n      .n3:hover ~ li.quebec { left: 225px; width: 110px; }\n      .n4:hover ~ li.quebec { left: 335px; width: 110px; }\n\n这里就完成了一个 纯css的下划线动画导航。 \n\n## 扩展\n\n当我们会实现水平的下划线动画导航后，实现 背景移动动画导航 思路也是一样，不过是li.quebec高度宽度的变化，背景透明度的变化。\n\n\n垂直的动画导航 亦是如此，改变 li.quebec 的高度宽度，通过 translateY 控制其在垂直方向的位置。\n\n\n为了效果更炫一点，我们还可以在hover不同li的时候，改变li.quebec的颜色、背景、透明度等。\n\n\n","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/07/a1.jpg\" alt=\"\" /></p>\n\n<p>看别人网站的时候，看到一种导航菜单的动画，觉得很有意思，就仔细研究起来。</p>\n\n<p>目前见过的动画有三种：水平下划线动画导航、水平背景动画导航、垂直动画导航，他们实现思路都是一样的，都是依赖 css3的同级通用选择器 \"~\" 。</p>\n\n<p>自己实现了一遍，本文简要记录实现的思想。</p>\n\n<p>大家可以先看看最后实现的效果：<a href=\"http://output.jsbin.com/legipibayi\" target=\"_blank\">Demo点我</a></p>\n\n<h2 id=\"\">实现思路</h2>\n\n<h4 id=\"html\">HTML 结构</h4>\n\n<p>HTML结构没有特殊，就是 ul -> li:</p>\n\n<pre><code>&lt;ul class=\"a\"&gt;\n  &lt;li class=\"n1\"&gt;&lt;a href=\"#\"&gt;Navigator A&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n2\"&gt;&lt;a href=\"#\"&gt;Navigator B&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n3 selected\"&gt;&lt;a href=\"#\"&gt;Navigator C&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"n4\"&gt;&lt;a href=\"#\"&gt;Navigator D&lt;/a&gt;&lt;/li&gt;\n  &lt;li class=\"quebec\"&gt;&amp;nbsp;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>最后一个li空着，留着后面有用。</p>\n\n<h4 id=\"css\">CSS 布局</h4>\n\n<p>实现基本样式，不多解释：</p>\n\n<pre><code>  ul {\n    position: relative;\n    overflow: hidden;\n    padding-left: 0px;\n  }\n  li {\n        list-style: none outside;\n        position: relative;\n        z-index: 1;\n        float: left;\n        padding: 0 0 0 0;\n        margin-right: 10px;\n    }\n    li a {\n        position: relative;\n        width: 100px;\n        color:#333 ;\n        display: block;\n        margin: 0 0;\n        border-bottom: 5px solid transparent;\n        padding: 10px 0;\n        text-align: center;\n        text-decoration: none;\n    }\n    .selected a {\n        border-bottom: 5px solid #cfd0d0;\n        color: #511d7f;\n    }\n</code></pre>\n\n<h4 id=\"\">实现导航下划线</h4>\n\n<p>下面实现动画部分。</p>\n\n<p>下方紫色滚动条是通过，刚才留着的最后一个li元素实现。</p>\n\n<pre><code> .quebec {\n      position: absolute;\n      bottom: 0px;\n      left: -100px;\n      z-index: 3;\n      margin: 0;\n      border: 0;\n      width: 5px;\n      height: 5px;\n      padding: 0;\n      overflow: hidden;\n      background: #511d7f;\n\n     -webkit-transition-property: left, width;\n     -moz-transition-property: left, width;\n     -ms-transition-property: left, width;\n     -o-transition-property: left, width;\n     transition-property: left, width;\n\n     -webkit-transition-duration: .5s;\n     -moz-transition-duration: .5s;\n     -ms-transition-duration: .5s;\n     -o-transition-duration: .5s;\n     transition-duration: .5s;\n  }\n</code></pre>\n\n<p>通过绝对定位，把最后一个 li.quebec 定位到导航下方，设置宽度高度。设置 transition，当我们改变 left, width的时候就能实现动画。</p>\n\n<h4 id=\"\">动起来</h4>\n\n<p>当hover到导航上面的时候，li.quebec 就定位left到其下面。实现这个效果的是css3的同级通用选择器 “～”</p>\n\n<p>比如 A ~ B 匹配的是 <strong>任何在A元素之后的同级B元素</strong>。</p>\n\n<pre><code>  .n1:hover ~ li.quebec { left: 5px; width: 110px; }\n  .n2:hover ~ li.quebec { left: 115px; width: 110px; }\n  .n3:hover ~ li.quebec { left: 225px; width: 110px; }\n  .n4:hover ~ li.quebec { left: 335px; width: 110px; }\n</code></pre>\n\n<p>这里就完成了一个 纯css的下划线动画导航。 </p>\n\n<h2 id=\"\">扩展</h2>\n\n<p>当我们会实现水平的下划线动画导航后，实现 背景移动动画导航 思路也是一样，不过是li.quebec高度宽度的变化，背景透明度的变化。</p>\n\n<p>垂直的动画导航 亦是如此，改变 li.quebec 的高度宽度，通过 translateY 控制其在垂直方向的位置。</p>\n\n<p>为了效果更炫一点，我们还可以在hover不同li的时候，改变li.quebec的颜色、背景、透明度等。</p>","image":"/content/images/2016/07/a1-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:44:39","created_by":1,"updated_at":"2016-07-19 13:56:44","updated_by":1,"published_at":"2015-04-29 13:44:00","published_by":1},{"id":91,"uuid":"50a044b7-de16-4bcb-ac5e-0bd1841bebae","title":"Tinymce  Group Plugin","slug":"tinymce-group-plugin-2","markdown":"\n本文介绍一个tinymce插件，用来组合显示下拉的按钮。\n\n>本文tinymce基于4.x，不兼容3.x。\n\n## 以前\n\n### 配置toolbar功能按钮\n\n需要\n\n    toolbar1: \"code undo redo fullscreen\"\n    plugins: \"code, fullscreen\"\n\n页面就能显示\n\n![](/content/images/2016/07/a-1.png)\n\n### 配置 toolbar下拉的功能按钮集合，需要新写一个插件\n\n插件核心源码：\n\n    editor.addButton('undoRedo', {\n        type: 'menubutton',\n        icon: 'mceIcon mce-i-undo',\n\t     menu: [\n            {\n                text: ed.getLang('Undo'),\n                icon: 'mceIcon mce-i-bold',\n                onclick: function() {\n                    ed.execCommand('Undo');\n                }\n            },\n            {\n                text: ed.getLang('Redo'),\n                icon: 'mceIcon mce-i-redo',\n                onclick: function() {\n                    ed.execCommand('Redo');\n                }\n            }\n        ]\n    });\n\n就能看到\n\n![](/content/images/2016/07/e.png)\n\n## 现在\n\n现在我们想要实现这类下拉功能菜单：\n\n![](/content/images/2016/07/c-3.png)\n\n当然作为备选方案，可以使用使用上面提到的add menuButton的方式。不过这样的缺点是，我们如果需要5个下拉功能菜单，就不得不写五个插件，而都是重复的工作。\n\n当一件事开始重复的时候，就一定有方法可以让其变的简单。\n\n我们的解决办法是，通过一个插件，来配置多个下拉功能菜单。\n\ntalk is chip, show you the code:\n\n####使用配置：\n    \n    toolbar1: 'undo redo | group group group group group | fullscreen',\n    group_set: [{\n        icon: 'alignleft',\n        buttons: 'alignleft,aligncenter,alignright',\n        title: 'Align center'\n    }, {\n        icon: 'bullist',\n        buttons: 'bullist,numlist',\n        title: 'advanced.bullist_desc'\n    }, {\n        icon: 'indent',\n        buttons: 'indent,outdent',\n        title: 'advanced.indent_desc'\n    }, {\n        icon: 'subscript',\n        buttons: 'superscript,subscript',\n        title: 'advanced.sup_desc'\n    },{\n        icon: 'image',\n        buttons: 'alitophotobank,image, aliphotobank',\n        title: 'advanced.sup_desc'\n    }]\n\n效果:\n\n![](/content/images/2016/07/c-4.png)\n\n### plugin group实现\n\n#### 修改 toolbar 配置\ntoolbar1配置了5个group占位符，但是addButton的第一个参数name一定要和toolbar上的占位配置一致，所以第一步是修改  settings.toolbar上的group占位符。\n   \n    // 修改 setting中toolbar上的group，group为group1，group2\n    modifySettingToolbar: function(ed) {\n        var index = 1;\n        var settings = ed.settings;\n        if(!settings.toolbar1 && !settings.toolbar2 && !settings.toolbar3) return false;\n\n        var toolbar1 = settings.toolbar1.split(' '),\n            toolbar2 = settings.toolbar2.split(' '),\n            toolbar3 = settings.toolbar3.split(' ');\n\n        [toolbar1, toolbar2, toolbar3].forEach(function(item) {\n            for (var i = 0; i < item.length; i++) {\n                if(item[i] == 'group') {\n                    item[i] = 'group' + index;\n                    index ++;\n                }\n            };\n        });\n        this.toolbarNum = index;\n        settings.toolbar1 = toolbar1.join(' ');\n        settings.toolbar2 = toolbar2.join(' ');\n        settings.toolbar3 = toolbar3.join(' ');\n    },\n\n#### 插件核心代码\n\n    //编辑器初始化后将初始化一个插件实例\n    init: function(ed, url) {\n        //在这个实例中我们保存一些编辑器的公用信息\n        this.ed = ed;\n        //保留配置信息\n        this.settings = ed.settings;\n        // 注意 4.x 没有3.x的 ed.onInit 方法\n        ed.on('init', function() {\n            this.createControl(ed);\n        }.bind(this));\n    },\n    // 创建 group button\n    createControl: function(ed) {\n        var _set = this.settings;\n\n        this.modifySettingToolbar(ed);\n        for (var i = 1; i < this.toolbarNum; i++) {\n\n            var _item = _set.group_set[i-1]; //获取多组信息\n            if(!_item) return false;\n            var _buttons = _item ? _item.buttons.split(',') : [],\n                subItem = [];\n\n            for (var j = 0, l = _buttons.length; j < l; j++) {\n\n                btn  = _buttons[j] && _buttons[j].trim();\n\n                subItem.push({\n                    //配置标题信息则需要考虑到语言和主题\n                    text: ed.getLang(BUTTONS_MAP[btn] && BUTTONS_MAP[btn][0]),\n                    //图标类自己创建的话则需要注意格式\n                    icon: 'mceIcon mce-i-' + btn,\n                    //执行的命令 闭包传入当前btn\n                    onclick: (function(btn) {\n                       var cmd = BUTTONS_MAP[btn] && BUTTONS_MAP[btn][1];\n                       return function(e) {\n                          ed.execCommand(cmd);\n                       }\n                   })(btn)\n                });\n            }\n            ed.addButton('group' + i, {\n                type: 'menubutton',\n                icon: _item.icon || '',\n                menu: subItem\n            });\n        }\n        return false;\n    },\n\n\n注释已经很详细了，就不讲解代码了。\n\n其中的BUTTONS_MAP是我配置的一个title&cmd的map：\n\n    // 目前 plugin group支持的一些功能map\n    var BUTTONS_MAP = {\n      bold : ['Bold', 'Bold'],\n      italic : ['Italic', 'Italic'],\n      underline : ['Underline', 'Underline'],\n      strikethrough : ['Strikethrough', 'Strikethrough'],\n      alignleft : ['Align left', 'JustifyLeft'],\n      aligncenter : ['Align center', 'JustifyCenter'],\n      alignright : ['Align right', 'JustifyRight'],\n      alignjustify : ['Alignment', 'JustifyFull'],\n      bullist : ['Bullet list', 'InsertUnorderedList'],\n      numlist : ['Numbered list', 'InsertOrderedList'],\n      outdent : ['Decrease indent', 'Outdent'],\n      indent : ['Increase indent', 'Indent'],\n      cut : ['Cut', 'Cut'],\n      copy : ['Copy', 'Copy'],\n      paste : ['Paste', 'Paste'],\n      undo : ['Undo', 'Undo'],\n      redo : ['Redo', 'Redo'],\n      link : ['Insert link', 'mceLink'],\n      unlink : ['Remove link', 'unlink'],\n      image : ['Insert image', 'mceImage'],\n      removeformat : ['Clear formatting', 'mceCleanup'],\n      help : ['help', 'mceHelp'],\n      code : ['Source code', 'mceCodeEditor'],\n      hr : ['Horizontal line', 'InsertHorizontalRule'],\n      superscript : ['Subscript', 'subscript'],\n      subscript : ['Superscript', 'superscript'],\n      newdocument : ['New document', 'mceNewDocument'],\n      blockquote : ['Blockquote', 'mceBlockQuote']\n     };\n\n\n以上就是group的使用方式和源码解释，希望能帮到你。\n\n源码托管在github:  <a href=\"https://github.com/freestyle21/tinymce_plugin_group\" target=\"_blank\"><code>点我下载</code></a>\n","mobiledoc":null,"html":"<p>本文介绍一个tinymce插件，用来组合显示下拉的按钮。</p>\n\n<blockquote>\n  <p>本文tinymce基于4.x，不兼容3.x。</p>\n</blockquote>\n\n<h2 id=\"\">以前</h2>\n\n<h3 id=\"toolbar\">配置toolbar功能按钮</h3>\n\n<p>需要</p>\n\n<pre><code>toolbar1: \"code undo redo fullscreen\"\nplugins: \"code, fullscreen\"\n</code></pre>\n\n<p>页面就能显示</p>\n\n<p><img src=\"/content/images/2016/07/a-1.png\" alt=\"\" /></p>\n\n<h3 id=\"toolbar\">配置 toolbar下拉的功能按钮集合，需要新写一个插件</h3>\n\n<p>插件核心源码：</p>\n\n<pre><code>editor.addButton('undoRedo', {\n    type: 'menubutton',\n    icon: 'mceIcon mce-i-undo',\n     menu: [\n        {\n            text: ed.getLang('Undo'),\n            icon: 'mceIcon mce-i-bold',\n            onclick: function() {\n                ed.execCommand('Undo');\n            }\n        },\n        {\n            text: ed.getLang('Redo'),\n            icon: 'mceIcon mce-i-redo',\n            onclick: function() {\n                ed.execCommand('Redo');\n            }\n        }\n    ]\n});\n</code></pre>\n\n<p>就能看到</p>\n\n<p><img src=\"/content/images/2016/07/e.png\" alt=\"\" /></p>\n\n<h2 id=\"\">现在</h2>\n\n<p>现在我们想要实现这类下拉功能菜单：</p>\n\n<p><img src=\"/content/images/2016/07/c-3.png\" alt=\"\" /></p>\n\n<p>当然作为备选方案，可以使用使用上面提到的add menuButton的方式。不过这样的缺点是，我们如果需要5个下拉功能菜单，就不得不写五个插件，而都是重复的工作。</p>\n\n<p>当一件事开始重复的时候，就一定有方法可以让其变的简单。</p>\n\n<p>我们的解决办法是，通过一个插件，来配置多个下拉功能菜单。</p>\n\n<p>talk is chip, show you the code:</p>\n\n<h4 id=\"\">使用配置：</h4>\n\n<pre><code>toolbar1: 'undo redo | group group group group group | fullscreen',\ngroup_set: [{\n    icon: 'alignleft',\n    buttons: 'alignleft,aligncenter,alignright',\n    title: 'Align center'\n}, {\n    icon: 'bullist',\n    buttons: 'bullist,numlist',\n    title: 'advanced.bullist_desc'\n}, {\n    icon: 'indent',\n    buttons: 'indent,outdent',\n    title: 'advanced.indent_desc'\n}, {\n    icon: 'subscript',\n    buttons: 'superscript,subscript',\n    title: 'advanced.sup_desc'\n},{\n    icon: 'image',\n    buttons: 'alitophotobank,image, aliphotobank',\n    title: 'advanced.sup_desc'\n}]\n</code></pre>\n\n<p>效果:</p>\n\n<p><img src=\"/content/images/2016/07/c-4.png\" alt=\"\" /></p>\n\n<h3 id=\"plugingroup\">plugin group实现</h3>\n\n<h4 id=\"toolbar\">修改 toolbar 配置</h4>\n\n<p>toolbar1配置了5个group占位符，但是addButton的第一个参数name一定要和toolbar上的占位配置一致，所以第一步是修改  settings.toolbar上的group占位符。</p>\n\n<pre><code>// 修改 setting中toolbar上的group，group为group1，group2\nmodifySettingToolbar: function(ed) {\n    var index = 1;\n    var settings = ed.settings;\n    if(!settings.toolbar1 &amp;&amp; !settings.toolbar2 &amp;&amp; !settings.toolbar3) return false;\n\n    var toolbar1 = settings.toolbar1.split(' '),\n        toolbar2 = settings.toolbar2.split(' '),\n        toolbar3 = settings.toolbar3.split(' ');\n\n    [toolbar1, toolbar2, toolbar3].forEach(function(item) {\n        for (var i = 0; i &lt; item.length; i++) {\n            if(item[i] == 'group') {\n                item[i] = 'group' + index;\n                index ++;\n            }\n        };\n    });\n    this.toolbarNum = index;\n    settings.toolbar1 = toolbar1.join(' ');\n    settings.toolbar2 = toolbar2.join(' ');\n    settings.toolbar3 = toolbar3.join(' ');\n},\n</code></pre>\n\n<h4 id=\"\">插件核心代码</h4>\n\n<pre><code>//编辑器初始化后将初始化一个插件实例\ninit: function(ed, url) {\n    //在这个实例中我们保存一些编辑器的公用信息\n    this.ed = ed;\n    //保留配置信息\n    this.settings = ed.settings;\n    // 注意 4.x 没有3.x的 ed.onInit 方法\n    ed.on('init', function() {\n        this.createControl(ed);\n    }.bind(this));\n},\n// 创建 group button\ncreateControl: function(ed) {\n    var _set = this.settings;\n\n    this.modifySettingToolbar(ed);\n    for (var i = 1; i &lt; this.toolbarNum; i++) {\n\n        var _item = _set.group_set[i-1]; //获取多组信息\n        if(!_item) return false;\n        var _buttons = _item ? _item.buttons.split(',') : [],\n            subItem = [];\n\n        for (var j = 0, l = _buttons.length; j &lt; l; j++) {\n\n            btn  = _buttons[j] &amp;&amp; _buttons[j].trim();\n\n            subItem.push({\n                //配置标题信息则需要考虑到语言和主题\n                text: ed.getLang(BUTTONS_MAP[btn] &amp;&amp; BUTTONS_MAP[btn][0]),\n                //图标类自己创建的话则需要注意格式\n                icon: 'mceIcon mce-i-' + btn,\n                //执行的命令 闭包传入当前btn\n                onclick: (function(btn) {\n                   var cmd = BUTTONS_MAP[btn] &amp;&amp; BUTTONS_MAP[btn][1];\n                   return function(e) {\n                      ed.execCommand(cmd);\n                   }\n               })(btn)\n            });\n        }\n        ed.addButton('group' + i, {\n            type: 'menubutton',\n            icon: _item.icon || '',\n            menu: subItem\n        });\n    }\n    return false;\n},\n</code></pre>\n\n<p>注释已经很详细了，就不讲解代码了。</p>\n\n<p>其中的BUTTONS_MAP是我配置的一个title&amp;cmd的map：</p>\n\n<pre><code>// 目前 plugin group支持的一些功能map\nvar BUTTONS_MAP = {\n  bold : ['Bold', 'Bold'],\n  italic : ['Italic', 'Italic'],\n  underline : ['Underline', 'Underline'],\n  strikethrough : ['Strikethrough', 'Strikethrough'],\n  alignleft : ['Align left', 'JustifyLeft'],\n  aligncenter : ['Align center', 'JustifyCenter'],\n  alignright : ['Align right', 'JustifyRight'],\n  alignjustify : ['Alignment', 'JustifyFull'],\n  bullist : ['Bullet list', 'InsertUnorderedList'],\n  numlist : ['Numbered list', 'InsertOrderedList'],\n  outdent : ['Decrease indent', 'Outdent'],\n  indent : ['Increase indent', 'Indent'],\n  cut : ['Cut', 'Cut'],\n  copy : ['Copy', 'Copy'],\n  paste : ['Paste', 'Paste'],\n  undo : ['Undo', 'Undo'],\n  redo : ['Redo', 'Redo'],\n  link : ['Insert link', 'mceLink'],\n  unlink : ['Remove link', 'unlink'],\n  image : ['Insert image', 'mceImage'],\n  removeformat : ['Clear formatting', 'mceCleanup'],\n  help : ['help', 'mceHelp'],\n  code : ['Source code', 'mceCodeEditor'],\n  hr : ['Horizontal line', 'InsertHorizontalRule'],\n  superscript : ['Subscript', 'subscript'],\n  subscript : ['Superscript', 'superscript'],\n  newdocument : ['New document', 'mceNewDocument'],\n  blockquote : ['Blockquote', 'mceBlockQuote']\n };\n</code></pre>\n\n<p>以上就是group的使用方式和源码解释，希望能帮到你。</p>\n\n<p>源码托管在github:  <a href=\"https://github.com/freestyle21/tinymce_plugin_group\" target=\"_blank\"><code>点我下载</code></a></p>","image":"/content/images/2016/07/c-5.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:47:58","created_by":1,"updated_at":"2016-07-19 13:57:13","updated_by":1,"published_at":"2015-04-18 13:47:00","published_by":1},{"id":92,"uuid":"d57c8753-4baa-4f3e-8509-738ed8cc93bd","title":"自适应process组件","slug":"process-component-2","markdown":"很久没有写博客了，自从工作忙了就忘了学习新东西，真是越大越懒。\n\n做项目中，需要一个process流程的UI组件，翻遍公司组件和业界框架，都没有满足自适应要求的现成的process组件，只能自己实现。实现的过程中，发现有两个有意思的地方，特此分享出来。\n\n首先看看最后需要的效果：<a href=\"http://qubaoming.me/demo/process/process.html\">点我查看demo</a>。\n\n## 实现\n\n流程组件中，两个hr构成圆点之间的连接线。\n\n圆点用span 通过 border-raduis: 50%实现。\n\n接下来，第一个难点来了，如何实现 居中 并且 自适应。\n\n自适应的意思是，拉伸浏览器的时候，流程组件也跟着变化长度，并且不变型。那么，我们自然的想到了用百分数设置宽度。\n\n第一张方案：\n\n![](/content/images/2016/07/aaa.png)\n\n用 outer 居中， inner平分内部，即每个inner占用 1/7 = 14.2%。内部原点span和文字通过每个inner的text-align:center;居中。\n\n接下来就连接线hr的宽度的计算就成了问题。比如连接线hr的起始位置怎么计算？inner的1/2，也就是1/14=0.071？\n\n第一次inner的1/7就有省略小数点的误差，再一半肯定更有误差，hr的宽度会再乘以2，乘以3，误差会更大，很有可能出现下面的情况:\n\n![](/content/images/2016/07/bbb.png)\n\n第二种方案：\n\n要解决节点span长度计算的问题，就必须让其乘以的倍数是精确可计算的。于是：\n\n![](/content/images/2016/07/tttt.png)\n\n通过外层outer实现居中，inner＋左侧等宽的空白 平分内部宽度，即 1/8=12.5%。\n\n这里又来了另一个问题：如何使下方文字左移自身宽度一半？\n\n父元素设置 text-align: center; ？？ 不行，我们的圆点span只能从最左边开始。\n\n自身position: absolute; left: 50%; margin-left: -宽度？不行，自身宽度不知道，变化的。\n\nposition: relative; left: -50%？不行，left 百分比是以最近已定位父元素的宽度为参照。\n\n\n最后解决办法是，增加一层父元素，使父元素宽度为自身宽度。这样left百分比就可以相当于以自身宽度。\n\n\n最后的效果：\n\n![](/content/images/2016/07/ccc.png)\n\n\n02.06更新\n-----\n\n由于是跨部门合作，对方返回的流程状态总是在变，从7个变到5个，从5个变到6个。\n\n\n7个状态有8个span，这样 1/8 = 12.5\n\n5个是加3个变8，也是12.5。通过margin-left微调。\n\n6个同理，加2变8，通过margin-left微调。\n\n07.24 更新\n----\n\n升级组件，可以适应后端的数据5-7个。\n\ngithub地址: https://github.com/freestyle21/step","mobiledoc":null,"html":"<p>很久没有写博客了，自从工作忙了就忘了学习新东西，真是越大越懒。</p>\n\n<p>做项目中，需要一个process流程的UI组件，翻遍公司组件和业界框架，都没有满足自适应要求的现成的process组件，只能自己实现。实现的过程中，发现有两个有意思的地方，特此分享出来。</p>\n\n<p>首先看看最后需要的效果：<a href=\"http://qubaoming.me/demo/process/process.html\">点我查看demo</a>。</p>\n\n<h2 id=\"\">实现</h2>\n\n<p>流程组件中，两个hr构成圆点之间的连接线。</p>\n\n<p>圆点用span 通过 border-raduis: 50%实现。</p>\n\n<p>接下来，第一个难点来了，如何实现 居中 并且 自适应。</p>\n\n<p>自适应的意思是，拉伸浏览器的时候，流程组件也跟着变化长度，并且不变型。那么，我们自然的想到了用百分数设置宽度。</p>\n\n<p>第一张方案：</p>\n\n<p><img src=\"/content/images/2016/07/aaa.png\" alt=\"\" /></p>\n\n<p>用 outer 居中， inner平分内部，即每个inner占用 1/7 = 14.2%。内部原点span和文字通过每个inner的text-align:center;居中。</p>\n\n<p>接下来就连接线hr的宽度的计算就成了问题。比如连接线hr的起始位置怎么计算？inner的1/2，也就是1/14=0.071？</p>\n\n<p>第一次inner的1/7就有省略小数点的误差，再一半肯定更有误差，hr的宽度会再乘以2，乘以3，误差会更大，很有可能出现下面的情况:</p>\n\n<p><img src=\"/content/images/2016/07/bbb.png\" alt=\"\" /></p>\n\n<p>第二种方案：</p>\n\n<p>要解决节点span长度计算的问题，就必须让其乘以的倍数是精确可计算的。于是：</p>\n\n<p><img src=\"/content/images/2016/07/tttt.png\" alt=\"\" /></p>\n\n<p>通过外层outer实现居中，inner＋左侧等宽的空白 平分内部宽度，即 1/8=12.5%。</p>\n\n<p>这里又来了另一个问题：如何使下方文字左移自身宽度一半？</p>\n\n<p>父元素设置 text-align: center; ？？ 不行，我们的圆点span只能从最左边开始。</p>\n\n<p>自身position: absolute; left: 50%; margin-left: -宽度？不行，自身宽度不知道，变化的。</p>\n\n<p>position: relative; left: -50%？不行，left 百分比是以最近已定位父元素的宽度为参照。</p>\n\n<p>最后解决办法是，增加一层父元素，使父元素宽度为自身宽度。这样left百分比就可以相当于以自身宽度。</p>\n\n<p>最后的效果：</p>\n\n<p><img src=\"/content/images/2016/07/ccc.png\" alt=\"\" /></p>\n\n<h2 id=\"0206\">02.06更新  </h2>\n\n<p>由于是跨部门合作，对方返回的流程状态总是在变，从7个变到5个，从5个变到6个。</p>\n\n<p>7个状态有8个span，这样 1/8 = 12.5</p>\n\n<p>5个是加3个变8，也是12.5。通过margin-left微调。</p>\n\n<p>6个同理，加2变8，通过margin-left微调。</p>\n\n<h2 id=\"0724\">07.24 更新  </h2>\n\n<p>升级组件，可以适应后端的数据5-7个。</p>\n\n<p>github地址: <a href=\"https://github.com/freestyle21/step\">https://github.com/freestyle21/step</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-07 13:51:08","created_by":1,"updated_at":"2016-07-19 14:05:25","updated_by":1,"published_at":"2015-01-15 13:51:00","published_by":1},{"id":93,"uuid":"83cb1eac-adf0-4604-b2d7-6141a66cc88d","title":"寻找节点d＝n的节点算法","slug":"path-shortest-algorithm-2","markdown":">这里的算法是毕设过程中，自己想到的，也不知道有不有人提出过。这里就记录下发现的过程的具体的算法，以后会用到。\n\n## 背景描述\n毕设做的是「社交网络中病毒传播的预测」，前期过程主要是模拟几个网络的数据，然后从一个节点开始传播，研究传播过程的预测性。\n\n其中一步，需要研究距离桥节点（两个网络的俩连接点）距离为n的节点为病毒源的传播过程。这里产生一个需求：**寻找与节点A距离为n的节点们。**\n\n毕设过程基本是重复博士生姐姐已发表的论文，不过由于年轻气盛给导师说要自己做，只是博士生姐姐提供主线思路。每次都是自己做出来后，给博士生姐姐讲，然后给我讲他的。发现，寻找离节点A距离n的节点们，博士生姐姐都是用`Dijkstra`算法先把整个网络的节点距离算出来，再找需要的节点。\n\n但是，这样做的缺点是浪费不必要的时间和空间，因为我们的需求中只需要计算距离特定点A长度d＝n的节点们，而不需要计算所有节点的所有距离长度节点。\n\n## 算法内容\n算法思路是根据最直接的想法进行的，即\n寻找与节点A距离d＝n的节点算法：\n\n1.   寻找与节点A距离d＝n－1的的邻居节点\n2.   第一步的节点中减去d＝n－2，n－3，。。。，1，0的邻居节点\n\njs写的伪代码(直接用的毕设时的数据结构)\n\n\n       /*\n            寻找网络Net中距离节点node距离distance的节点们\n            Net = {\n                '1': {\n                    'status': 1, // 节点编号1的节点状态是已感染。\n                    'connect': [2,3,4,5] // 节点编号1的节点的邻居节点。\n                },\n                ...\n            }\n        */\n        function findDistanceNodes(Net, node, distance) {\n            var findNodes = [];\n            if(distance == 0) {\n                findNodes.push(node);\n            } else {\n                // 寻找距离  distance - 1 的节点们的邻居们\n                var lastDistanceNodes = findDistanceNodes(Net, node, distance - 1);\n                for(var i =0; i < lastDistanceNodes.length; i++) {\n                    findNodes = array_merge(Net[lastDistanceNodes[i]].connect, findNodes);\n                }\n                // 去重\n                findNodes = rmSameArr(findNodes);\n\n                // 从刚才的邻居们中排除 距离node d＝0,1,2,3,4,...distance-1的节点\n                for(var i = 0; i < distance; i++) {\n                    findNodes = minArrFromArr(findNodes, findDistanceNodes(Net, node, i));\n                }\n            }\n            return findNodes;\n        }\n\n\n## 结尾\n以上算法经过毕设结果验证，和博士生姐姐的结果一致，整体运行速度也比其快。\n这里粗略记录下研究过程，希望也能感受到毕设中的苦与甜。","mobiledoc":null,"html":"<blockquote>\n  <p>这里的算法是毕设过程中，自己想到的，也不知道有不有人提出过。这里就记录下发现的过程的具体的算法，以后会用到。</p>\n</blockquote>\n\n<h2 id=\"\">背景描述</h2>\n\n<p>毕设做的是「社交网络中病毒传播的预测」，前期过程主要是模拟几个网络的数据，然后从一个节点开始传播，研究传播过程的预测性。</p>\n\n<p>其中一步，需要研究距离桥节点（两个网络的俩连接点）距离为n的节点为病毒源的传播过程。这里产生一个需求：<strong>寻找与节点A距离为n的节点们。</strong></p>\n\n<p>毕设过程基本是重复博士生姐姐已发表的论文，不过由于年轻气盛给导师说要自己做，只是博士生姐姐提供主线思路。每次都是自己做出来后，给博士生姐姐讲，然后给我讲他的。发现，寻找离节点A距离n的节点们，博士生姐姐都是用<code>Dijkstra</code>算法先把整个网络的节点距离算出来，再找需要的节点。</p>\n\n<p>但是，这样做的缺点是浪费不必要的时间和空间，因为我们的需求中只需要计算距离特定点A长度d＝n的节点们，而不需要计算所有节点的所有距离长度节点。</p>\n\n<h2 id=\"\">算法内容</h2>\n\n<p>算法思路是根据最直接的想法进行的，即\n寻找与节点A距离d＝n的节点算法：</p>\n\n<ol>\n<li>寻找与节点A距离d＝n－1的的邻居节点  </li>\n<li>第一步的节点中减去d＝n－2，n－3，。。。，1，0的邻居节点</li>\n</ol>\n\n<p>js写的伪代码(直接用的毕设时的数据结构)</p>\n\n<pre><code>   /*\n        寻找网络Net中距离节点node距离distance的节点们\n        Net = {\n            '1': {\n                'status': 1, // 节点编号1的节点状态是已感染。\n                'connect': [2,3,4,5] // 节点编号1的节点的邻居节点。\n            },\n            ...\n        }\n    */\n    function findDistanceNodes(Net, node, distance) {\n        var findNodes = [];\n        if(distance == 0) {\n            findNodes.push(node);\n        } else {\n            // 寻找距离  distance - 1 的节点们的邻居们\n            var lastDistanceNodes = findDistanceNodes(Net, node, distance - 1);\n            for(var i =0; i &lt; lastDistanceNodes.length; i++) {\n                findNodes = array_merge(Net[lastDistanceNodes[i]].connect, findNodes);\n            }\n            // 去重\n            findNodes = rmSameArr(findNodes);\n\n            // 从刚才的邻居们中排除 距离node d＝0,1,2,3,4,...distance-1的节点\n            for(var i = 0; i &lt; distance; i++) {\n                findNodes = minArrFromArr(findNodes, findDistanceNodes(Net, node, i));\n            }\n        }\n        return findNodes;\n    }\n</code></pre>\n\n<h2 id=\"\">结尾</h2>\n\n<p>以上算法经过毕设结果验证，和博士生姐姐的结果一致，整体运行速度也比其快。\n这里粗略记录下研究过程，希望也能感受到毕设中的苦与甜。</p>","image":"/content/images/2016/07/c9e42240.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:09:05","created_by":1,"updated_at":"2016-07-19 14:05:41","updated_by":1,"published_at":"2014-06-15 00:09:00","published_by":1},{"id":94,"uuid":"6c289b1d-ab76-4383-81bd-ebec3b5203d7","title":"mac os x 从入门到顺手","slug":"mac-os-learn-2","markdown":"## 惯例\n文章开头，惯例前戏。\nmac入手一周，越用越顺手，记录下使用习惯。\n\n文章会持续更新，朋友如果有更舒服得方式可以留言交流。\n\n## 常用基本手势\n\n左右切换屏幕： 四指左右滑动（习惯除去大拇指）\n\n上下滚动浏览： 两手指上下\n\n鼠标左键和右键： 一个手指单击和两个手指单击（默认是按下，修改了）\n\n查看当前打开程序： 四指向上或向下（查看当当前焦点程序得其他窗口）\n\n移动当前焦点窗口： 三指在title部分。\n\n## iTerm\n默认终端还不错，不过用过iTerm才知道什么叫好。\niTerm界面：\n\n![](/content/images/2016/07/QQ20140418-1-2x.png)\n\n下载：[http://iterm.sourceforge.net/downloads.shtml](http://iterm.sourceforge.net/downloads.shtml)\n\n快捷键：\n\ncommand+d：垂直分割；\n\ncommand+shift+d：水平分割\n\ncommand+f 查找。之后按tab会继续选中并复制右边一个单词，shift+tab继续选中并复制左边一个单词。\n\ncommand+shift+h 自动列出剪切板的历史记录\n\ncommand+enter进入与返回全屏模式\n\n## VIM \n一直见身边得人用这个神器，定位太叼了，可惜每次决心要用的时候，发现很痛苦后又换回sublime了。\n这次重新学习。\n\n#### 常用配置\n创建一个文件 \n\n      sudo touch ~/.vimrc\n\n这是一个配置文件，内容在：[这里](https://github.com/freestyle21/tools/blob/master/.vimrc)\n\n创建文件夹 \n\n      sudo mkdir ~/vim/plugin\n      sudo mkdir ~/vim/colors\n\n下载得插件都放在plugin，主题放colors，在.vimrc里面配置主题即可。\n\n#### 常用命令：\ngt     切换到下一个标签页  \n\ngT     切换到上一个标签页\n\nctrl+w s     水平分割窗口\n\nctrl+w v     垂直分割窗口\n\nctrl+w w     切换窗口\n\nctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)\n\n/pattern     向后搜索字符串pattern\n\n?pattern     向前搜索字符串pattern\n\nn     下一个匹配(如果是/搜\n\ndd     删除光标所在行\n\ndw     删除一个字(word)\n\nx     删除当前字符\n\nX     删除前一个字符\n\nD     删除到行末\n\nyy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行\n\nyw     复制一个字\n\ny$     复制到行末\n\np     粘贴粘贴板的内容到当前行的下面\n\nP     粘贴粘贴板的内容到当前行的上面\n\nh,j,k,l     上，下，左，右\n\nctrl-f     上翻一页\n\nctrl-b     下翻一页\n\n\n%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处\n\nw     跳到下一个字首，按标点或单词分割\n\nW     跳到下一个字首，长跳，如end-of-line被认为是一个字\n\ne     跳到下一个字尾\n\nE     跳到下一个字尾，长跳\n\nb     跳到上一个字\n\nB     跳到上一个字，长跳\n\n0     跳至行首，不管有无缩进，就是跳到第0个字符\n\n^     跳至行首的第一个字符\n\n$     跳至行尾\n\ngg     跳至文件的第一行\n\ngd     跳至当前光标所在的变量的声明处\n\n[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行\n\nfx     在当前行中找x字符，找到了就跳转至\n\ntx     与fx类似，但是只是跳转到x的前一个字符处\n\nFx     跟fx的方向相反\n\n),(     跳转到上/下一个语句\n\nH     移动光标到当前屏幕上最上边的一行\n\nM     移动光标到当前屏幕上中间的一行\n\nL     移动光标到当前屏幕上最下边的一行\n\ncc     删除当前行并进入编辑模式\n\ncw     删除当前字，并进入编辑模式\n\nc$     擦除从当前位置至行末的内容，并进入编辑模式\n\ns     删除当前字符并进入编辑模式\n\nS     删除光标所在行并进入编辑模式\n\nu     撤销\n\nctrl+r     重做\n\ni     从当前光标处进入插入模式\n\nI     进入插入模式，并置光标于行首\n\na     追加模式，置光标于当前光标之后\n\nA     追加模式，置光标于行末\n\no     在当前行之下新加一行，并进入插入模式\n\nO     在当前行之上新加一行，并进入插入模式\n\n\n#### 常用插件\n\ncsExplorer.vim  normal模式输入ColorSchemeExplorer： 可以列出所有的配色文件，然后一个个选择就行啦~\n\nNERD_tree.vim 输入NERD_tree 就能看到目录结构\no  打开关闭文件或者目录\n\np  到上层目录\n\nP  到根目录\n\nr  刷新选中目录 \n\nK  到第一个节点\n\nJ  到最后一个节点 \n\n## Alfred\n全局呼出任何程序，必备。自带得spotlight不好用\n\n安装后option＋space，可以加载任何想要的程序。\n\n## 配置命令行别名\nmac 中命令行打开chrome：\n\n      open -a Google\\ Chrome\n\n在iterm中：\n\n      vi /etc/profile\n      alias chrome=\"open -a Google\\ Chrome\"\n\n然后使之生效：\n\n      source /etc/profile \n\n这样得好处是，在命令行导航到某个文件夹得时候，可以直接使用chrome或者sublime打开这个文件。\n\n## brew\nbrew相当于ubuntu里面得apt-get.方便在mac中安装或者卸载软件。\n\n不过遇到得问题是，按照官方得安装方式：\n\n        ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n\n在iterm中不能使用brew。也是想着吧brew得安装目录仍系统路径中。 但是，总是找不到安装没有。\n\nfind全局发现在 .npm 里面。\n\n删除了原来的，重新安装就好了。\n\n        rm -rf /usr/local/Cellar /usr/local/.git && brew cleanup\n\n\n\n\n","mobiledoc":null,"html":"<h2 id=\"\">惯例</h2>\n\n<p>文章开头，惯例前戏。\nmac入手一周，越用越顺手，记录下使用习惯。</p>\n\n<p>文章会持续更新，朋友如果有更舒服得方式可以留言交流。</p>\n\n<h2 id=\"\">常用基本手势</h2>\n\n<p>左右切换屏幕： 四指左右滑动（习惯除去大拇指）</p>\n\n<p>上下滚动浏览： 两手指上下</p>\n\n<p>鼠标左键和右键： 一个手指单击和两个手指单击（默认是按下，修改了）</p>\n\n<p>查看当前打开程序： 四指向上或向下（查看当当前焦点程序得其他窗口）</p>\n\n<p>移动当前焦点窗口： 三指在title部分。</p>\n\n<h2 id=\"iterm\">iTerm</h2>\n\n<p>默认终端还不错，不过用过iTerm才知道什么叫好。\niTerm界面：</p>\n\n<p><img src=\"/content/images/2016/07/QQ20140418-1-2x.png\" alt=\"\" /></p>\n\n<p>下载：<a href=\"http://iterm.sourceforge.net/downloads.shtml\">http://iterm.sourceforge.net/downloads.shtml</a></p>\n\n<p>快捷键：</p>\n\n<p>command+d：垂直分割；</p>\n\n<p>command+shift+d：水平分割</p>\n\n<p>command+f 查找。之后按tab会继续选中并复制右边一个单词，shift+tab继续选中并复制左边一个单词。</p>\n\n<p>command+shift+h 自动列出剪切板的历史记录</p>\n\n<p>command+enter进入与返回全屏模式</p>\n\n<h2 id=\"vim\">VIM</h2>\n\n<p>一直见身边得人用这个神器，定位太叼了，可惜每次决心要用的时候，发现很痛苦后又换回sublime了。\n这次重新学习。</p>\n\n<h4 id=\"\">常用配置</h4>\n\n<p>创建一个文件 </p>\n\n<pre><code>  sudo touch ~/.vimrc\n</code></pre>\n\n<p>这是一个配置文件，内容在：<a href=\"https://github.com/freestyle21/tools/blob/master/.vimrc\">这里</a></p>\n\n<p>创建文件夹 </p>\n\n<pre><code>  sudo mkdir ~/vim/plugin\n  sudo mkdir ~/vim/colors\n</code></pre>\n\n<p>下载得插件都放在plugin，主题放colors，在.vimrc里面配置主题即可。</p>\n\n<h4 id=\"\">常用命令：</h4>\n\n<p>gt     切换到下一个标签页  </p>\n\n<p>gT     切换到上一个标签页</p>\n\n<p>ctrl+w s     水平分割窗口</p>\n\n<p>ctrl+w v     垂直分割窗口</p>\n\n<p>ctrl+w w     切换窗口</p>\n\n<p>ctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)</p>\n\n<p>/pattern     向后搜索字符串pattern</p>\n\n<p>?pattern     向前搜索字符串pattern</p>\n\n<p>n     下一个匹配(如果是/搜</p>\n\n<p>dd     删除光标所在行</p>\n\n<p>dw     删除一个字(word)</p>\n\n<p>x     删除当前字符</p>\n\n<p>X     删除前一个字符</p>\n\n<p>D     删除到行末</p>\n\n<p>yy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行</p>\n\n<p>yw     复制一个字</p>\n\n<p>y$     复制到行末</p>\n\n<p>p     粘贴粘贴板的内容到当前行的下面</p>\n\n<p>P     粘贴粘贴板的内容到当前行的上面</p>\n\n<p>h,j,k,l     上，下，左，右</p>\n\n<p>ctrl-f     上翻一页</p>\n\n<p>ctrl-b     下翻一页</p>\n\n<p>%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处</p>\n\n<p>w     跳到下一个字首，按标点或单词分割</p>\n\n<p>W     跳到下一个字首，长跳，如end-of-line被认为是一个字</p>\n\n<p>e     跳到下一个字尾</p>\n\n<p>E     跳到下一个字尾，长跳</p>\n\n<p>b     跳到上一个字</p>\n\n<p>B     跳到上一个字，长跳</p>\n\n<p>0     跳至行首，不管有无缩进，就是跳到第0个字符</p>\n\n<p>^     跳至行首的第一个字符</p>\n\n<p>$     跳至行尾</p>\n\n<p>gg     跳至文件的第一行</p>\n\n<p>gd     跳至当前光标所在的变量的声明处</p>\n\n<p>[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行</p>\n\n<p>fx     在当前行中找x字符，找到了就跳转至</p>\n\n<p>tx     与fx类似，但是只是跳转到x的前一个字符处</p>\n\n<p>Fx     跟fx的方向相反</p>\n\n<p>),(     跳转到上/下一个语句</p>\n\n<p>H     移动光标到当前屏幕上最上边的一行</p>\n\n<p>M     移动光标到当前屏幕上中间的一行</p>\n\n<p>L     移动光标到当前屏幕上最下边的一行</p>\n\n<p>cc     删除当前行并进入编辑模式</p>\n\n<p>cw     删除当前字，并进入编辑模式</p>\n\n<p>c$     擦除从当前位置至行末的内容，并进入编辑模式</p>\n\n<p>s     删除当前字符并进入编辑模式</p>\n\n<p>S     删除光标所在行并进入编辑模式</p>\n\n<p>u     撤销</p>\n\n<p>ctrl+r     重做</p>\n\n<p>i     从当前光标处进入插入模式</p>\n\n<p>I     进入插入模式，并置光标于行首</p>\n\n<p>a     追加模式，置光标于当前光标之后</p>\n\n<p>A     追加模式，置光标于行末</p>\n\n<p>o     在当前行之下新加一行，并进入插入模式</p>\n\n<p>O     在当前行之上新加一行，并进入插入模式</p>\n\n<h4 id=\"\">常用插件</h4>\n\n<p>csExplorer.vim  normal模式输入ColorSchemeExplorer： 可以列出所有的配色文件，然后一个个选择就行啦~</p>\n\n<p>NERD<em>tree.vim 输入NERD</em>tree 就能看到目录结构 <br />\no  打开关闭文件或者目录</p>\n\n<p>p  到上层目录</p>\n\n<p>P  到根目录</p>\n\n<p>r  刷新选中目录 </p>\n\n<p>K  到第一个节点</p>\n\n<p>J  到最后一个节点 </p>\n\n<h2 id=\"alfred\">Alfred</h2>\n\n<p>全局呼出任何程序，必备。自带得spotlight不好用</p>\n\n<p>安装后option＋space，可以加载任何想要的程序。</p>\n\n<h2 id=\"\">配置命令行别名</h2>\n\n<p>mac 中命令行打开chrome：</p>\n\n<pre><code>  open -a Google\\ Chrome\n</code></pre>\n\n<p>在iterm中：</p>\n\n<pre><code>  vi /etc/profile\n  alias chrome=\"open -a Google\\ Chrome\"\n</code></pre>\n\n<p>然后使之生效：</p>\n\n<pre><code>  source /etc/profile \n</code></pre>\n\n<p>这样得好处是，在命令行导航到某个文件夹得时候，可以直接使用chrome或者sublime打开这个文件。</p>\n\n<h2 id=\"brew\">brew</h2>\n\n<p>brew相当于ubuntu里面得apt-get.方便在mac中安装或者卸载软件。</p>\n\n<p>不过遇到得问题是，按照官方得安装方式：</p>\n\n<pre><code>    ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n</code></pre>\n\n<p>在iterm中不能使用brew。也是想着吧brew得安装目录仍系统路径中。 但是，总是找不到安装没有。</p>\n\n<p>find全局发现在 .npm 里面。</p>\n\n<p>删除了原来的，重新安装就好了。</p>\n\n<pre><code>    rm -rf /usr/local/Cellar /usr/local/.git &amp;&amp; brew cleanup\n</code></pre>","image":"/content/images/2016/07/20140601_110348_142.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:12:01","created_by":1,"updated_at":"2016-07-19 14:25:16","updated_by":1,"published_at":"2014-04-18 00:12:00","published_by":1},{"id":95,"uuid":"bc8aecb3-07d4-4c52-9c09-68fb5e1e1cf8","title":"关于长大","slug":"about-grown-2","markdown":"记得13年总结的时候，写过要多联系朋友。当时发出那样的感叹是因为过去忙于自己的事，从来不主动联系，每次想起时总有或多或少的内疚。\n\n久了，耐心没了，联系更少了。\n\n但总有那么几个朋友，无论多久不联系，无论相隔多远，一见面总会是那么的熟悉。无论我们在外面有多么装逼，凑在一起就会变成一群傻逼。最喜欢知乎的一个回答，什么样的朋友才是最好的朋友：“三秋不见如隔一日，既能亲密无间，也可相忘于江湖。”\n\n越长大越孤单，越孤单越安静。孤单还有另一个好处，就是一个人忙碌一天后，回寝室的路上，能够找个没人的地儿，看看天空，想想莫名其妙的。\n\n所谓成熟，就是经历的多了，遇到再大的事，都能够潇洒的点支烟，想一想，再来面对。\n\n\n \n\n","mobiledoc":null,"html":"<p>记得13年总结的时候，写过要多联系朋友。当时发出那样的感叹是因为过去忙于自己的事，从来不主动联系，每次想起时总有或多或少的内疚。</p>\n\n<p>久了，耐心没了，联系更少了。</p>\n\n<p>但总有那么几个朋友，无论多久不联系，无论相隔多远，一见面总会是那么的熟悉。无论我们在外面有多么装逼，凑在一起就会变成一群傻逼。最喜欢知乎的一个回答，什么样的朋友才是最好的朋友：“三秋不见如隔一日，既能亲密无间，也可相忘于江湖。”</p>\n\n<p>越长大越孤单，越孤单越安静。孤单还有另一个好处，就是一个人忙碌一天后，回寝室的路上，能够找个没人的地儿，看看天空，想想莫名其妙的。</p>\n\n<p>所谓成熟，就是经历的多了，遇到再大的事，都能够潇洒的点支烟，想一想，再来面对。</p>","image":"/content/images/2016/07/aa-1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:17:16","created_by":1,"updated_at":"2016-07-19 14:25:29","updated_by":1,"published_at":"2014-03-01 00:17:00","published_by":1},{"id":96,"uuid":"a710df39-0f84-44f6-b2f8-5697dda69d4c","title":"关于「远程兼职」","slug":"about-parttime-job-2","markdown":">这篇文章创建在14.02.28，但是06.15才开始写。忙完整个毕业季，终于给大学划上一个句号。接下来整理好心情，享受工作和学习。\n最初接远程兼职得原因是大四上不想去帝都实习，又不想用家里钱，于是便想着在寝室干活挣钱。\n\n顺利毕业了，工作找到满意的，兼职也告一段落，大四算是结局圆满了。这里稍作整理，纪念做过得那些兼职，方便有同样意向得朋友。\n\n## 远程兼职是什么\n远程兼职，就是异地网上合作共同完成一个项目。我遇到得团队中，初创团队更倾向远程兼职，他们希望在实体办公前尽可能得压缩成本。\n\n## 远程兼职怎么找\n先不说怎么找远程兼职，换个角度想想如果我们是老板，我们会通过哪些渠道找人？\n\n最靠谱得应该算熟人推荐。老板会先在自己人脉库中搜寻，勾兑。\n\n如果没找到，就会通过认识得人，让他们推荐，叫做隐型人脉库。\n\n如果没找到，会在网上找。常见得是v2ex，上面自荐推荐得都很多，上v2ex得人大部分还是靠谱得。其次就是豆瓣了，在你能搜到得那几个组里面，经常会出现招兼职。\n\n所以，找活干主要就是通过熟人介绍，还有特定网站去搜寻。我的第一份远程兼职是在v2ex上找得，当时年轻气盛，发了一个自荐得贴，过了两个月第一个老板才联系过来。之后都是朋友介绍。\n\n## 远程兼职要求\n对于有远程兼职想法得web前端，我总结几个愉快完成兼职需要注意得地方。\n\n首先，时间。时间不够讲得再好都是扯淡，保证自己和别人约定得时间一致，同时自己也有缓冲得时间。\n\n其次，能力。接项目得时候可以指明前端或者后台，不过一般都会让前后都做，所以对前后端最好都有所了解。如果有独立完成项目得能力，那里远程会做的相对愉快些。\n\n另外，合作细节。合作之前最好有文档协议，双方确定好合作时间，阶段完成时间，阶段完成期望，阶段支付酬劳。\n\n## 远程兼职报酬\n这是一个敏感话题，多少也看自己谈多少。每次报酬根据项目工作量和难度而定，所以自己得对于项目估价有个市场了解。一般情况下，估价比标准价格多30%左右合适，时间比预期完成时间多一半合适，才不至于亏自己。\n\n## 远程兼职合作方式\n主要说说自己合作得方式。\n\n代码托管在`bitbucket`上，因为`github`主要是公有仓库，私有需要交费。而`bitbucket`主要是私有得。\n\n交流通过qq和邮件。\n\nbug管理，计划列表通过`trello`，每人一个bug list。\n\n测试服务器为ubuntu12.04，需要涉及到管理服务器，所以对于`linux`，`ngnix`等都要学一些。\n\n以上都是自己经历几段兼职后，总结得血于泪。不过，对于web前端更使用一些。\n","mobiledoc":null,"html":"<blockquote>\n  <p>这篇文章创建在14.02.28，但是06.15才开始写。忙完整个毕业季，终于给大学划上一个句号。接下来整理好心情，享受工作和学习。\n  最初接远程兼职得原因是大四上不想去帝都实习，又不想用家里钱，于是便想着在寝室干活挣钱。</p>\n</blockquote>\n\n<p>顺利毕业了，工作找到满意的，兼职也告一段落，大四算是结局圆满了。这里稍作整理，纪念做过得那些兼职，方便有同样意向得朋友。</p>\n\n<h2 id=\"\">远程兼职是什么</h2>\n\n<p>远程兼职，就是异地网上合作共同完成一个项目。我遇到得团队中，初创团队更倾向远程兼职，他们希望在实体办公前尽可能得压缩成本。</p>\n\n<h2 id=\"\">远程兼职怎么找</h2>\n\n<p>先不说怎么找远程兼职，换个角度想想如果我们是老板，我们会通过哪些渠道找人？</p>\n\n<p>最靠谱得应该算熟人推荐。老板会先在自己人脉库中搜寻，勾兑。</p>\n\n<p>如果没找到，就会通过认识得人，让他们推荐，叫做隐型人脉库。</p>\n\n<p>如果没找到，会在网上找。常见得是v2ex，上面自荐推荐得都很多，上v2ex得人大部分还是靠谱得。其次就是豆瓣了，在你能搜到得那几个组里面，经常会出现招兼职。</p>\n\n<p>所以，找活干主要就是通过熟人介绍，还有特定网站去搜寻。我的第一份远程兼职是在v2ex上找得，当时年轻气盛，发了一个自荐得贴，过了两个月第一个老板才联系过来。之后都是朋友介绍。</p>\n\n<h2 id=\"\">远程兼职要求</h2>\n\n<p>对于有远程兼职想法得web前端，我总结几个愉快完成兼职需要注意得地方。</p>\n\n<p>首先，时间。时间不够讲得再好都是扯淡，保证自己和别人约定得时间一致，同时自己也有缓冲得时间。</p>\n\n<p>其次，能力。接项目得时候可以指明前端或者后台，不过一般都会让前后都做，所以对前后端最好都有所了解。如果有独立完成项目得能力，那里远程会做的相对愉快些。</p>\n\n<p>另外，合作细节。合作之前最好有文档协议，双方确定好合作时间，阶段完成时间，阶段完成期望，阶段支付酬劳。</p>\n\n<h2 id=\"\">远程兼职报酬</h2>\n\n<p>这是一个敏感话题，多少也看自己谈多少。每次报酬根据项目工作量和难度而定，所以自己得对于项目估价有个市场了解。一般情况下，估价比标准价格多30%左右合适，时间比预期完成时间多一半合适，才不至于亏自己。</p>\n\n<h2 id=\"\">远程兼职合作方式</h2>\n\n<p>主要说说自己合作得方式。</p>\n\n<p>代码托管在<code>bitbucket</code>上，因为<code>github</code>主要是公有仓库，私有需要交费。而<code>bitbucket</code>主要是私有得。</p>\n\n<p>交流通过qq和邮件。</p>\n\n<p>bug管理，计划列表通过<code>trello</code>，每人一个bug list。</p>\n\n<p>测试服务器为ubuntu12.04，需要涉及到管理服务器，所以对于<code>linux</code>，<code>ngnix</code>等都要学一些。</p>\n\n<p>以上都是自己经历几段兼职后，总结得血于泪。不过，对于web前端更使用一些。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:20:09","created_by":1,"updated_at":"2016-07-19 14:06:46","updated_by":1,"published_at":"2014-01-18 00:20:00","published_by":1},{"id":97,"uuid":"6d402e86-e81e-4203-b332-7074dde9a86e","title":"BackBone 源码解读及思考","slug":"backbone-code-learn-2","markdown":"## 说明\n前段时间略忙，终于找到时间看看backbone代码。\n\n正如知友们说的那样，backbone简单、随性。 代码简单的看一眼，就能知道作者的思路。因为简单，所以随性，可以很自由的和其他类库大搭配使用，不太要求特别的格式。\n\n本文会关注backbone实现的细节，整体框架在博客园的一位朋友已经总结的很好了。链接：[点击这里](http://www.cnblogs.com/nuysoft/archive/2012/03/19/2404274.html)\n\n本文Bakcbone版本： \n\n            // 定义Backbone版本\n            Backbone.VERSION = '0.9.2';\n\n#### 照例提点问题，有目的的读源码。\n\n1. 怎么和模板引擎配合使用的。\n2.  RESTful JSON 接口从服务器检索到的数据\n3. 通过源码，了解到平时使用时的哪些需要注意的细节。\n4. 当models中值被改变时自动触发一个\"change\"事件、所有用于展示models数据的views都会侦听到这个事件，然后进行重新渲染。如何实现？\n5. 如何兼容IE6+\n6. view model collection怎么关联的。\n\n## 整体框架\n\n        (function() {\n            Backbone.Events        // 自定义事件\n            Backbone.Model        // 模型构造函数和原型扩展\n            Backbone.Collection    // 集合构造函数和原型扩展\n            Backbone.Router        // 路由配置器构造函数和原型扩展\n            Backbone.History        // 路由器构造函数和原型扩展\n            Backbone.View            // 视图构造函数和原型扩展\n            Backbone.sync            // 异步请求工具方法\n            var extend = function (protoProps, classProps) { ... } // 自扩展函数\n            Backbone.Model.extend = Backbone.Collection.extend =          Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法\n        }).call(this);\n\n本文的思路是按照这个框架，提炼每个部分的重要部分，解决上面提出的问题，并注释平时使用时需要注意的细节。\n\n## Events\n\n            var Events = Backbone.Events = {\n            // 该方法类似与DOM Level2中的addEventListener方法\n            // events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等)\n            // 当事件名称为\"all\"时, 在调用trigger方法触发任何事件时, 均会调用\"all\"事件中绑定的所有回调函数\n            on : function(events, callback, context) {\n                var calls, event, node, tail, list;\n                if(!callback)\n                    return this;\n                // eventSplitter = /\\s+/; 把多个事件名组成的字符串分开。\n                events = events.split(eventSplitter);\n\n                // 所有事件都存在this._callbacks这个数组里面\n                calls = this._callbacks || (this._callbacks = {});\n\n                while( event = events.shift()) {\n                    list = calls[event];\n                    node = list ? list.tail : {};\n                    node.next = tail = {};\n                    node.context = context;\n                    node.callback = callback;\n                    // 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件\n                    calls[event] = {\n                        tail : tail,\n                        next : list ? list.next : node\n                    };\n                }\n                // 返回当前对象, 方便进行方法链调用\n                return this;\n            },\n            // - 如果context为空, 则移除所有的callback指定的函数\n            // - 如果callback为空, 则移除事件中所有的回调函数\n            // - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称)\n            // - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数\n            off : function(events, callback, context) {\n                // code...\n                return this;\n            },\n            // 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表\n            trigger : function(events) {\n                var event, node, calls, tail, args, all, rest;\n                // 当前对象没有绑定任何事件\n                if(!( calls = this._callbacks))\n                    return this;\n                // 获取回调函数列表中绑定的\"all\"事件列表\n                all = calls.all;\n                // 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组\n                events = events.split(eventSplitter);\n                // 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数\n                rest = slice.call(arguments, 1);\n\n                // 循环需要触发的事件列表\n                while( event = events.shift()) {\n                    // 此处的node变量记录了当前事件的所有回调函数列表\n                    if( node = calls[event]) {\n                        tail = node.tail;\n                        // node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象\n                        // 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据\n                        while(( node = node.next) !== tail) {\n                            // 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数\n                            node.callback.apply(node.context || this, rest);\n                        }\n                    }\n                    if( node = all) {\n                        tail = node.tail;\n                        // 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数\n                        args = [event].concat(rest);\n                        // 遍历并执行\"all\"事件中的回调函数列表\n                        while(( node = node.next) !== tail) {\n                            node.callback.apply(node.context || this, args);\n                        }\n                    }\n                }\n\n                return this;\n            }\n        };\n        // 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本\n        Events.bind = Events.on;\n        Events.unbind = Events.off;\n\n\n## Model\nModel 比较常用，很多细节，所以列出了几个重要的函数，注释了一些重要细节。\n\n        _.extend(Model.prototype, Events, {\n             // code..\n            // 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值\n            set : function(key, value, options) {\n                var attrs, attr, val;\n\n                // 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置\n                // 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数\n                if(_.isObject(key) || key == null) {\n                    attrs = key;\n                    options = value;\n                } else {\n                    attrs = {};\n                    attrs[key] = value;\n                }\n\n                // options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象\n                options || ( options = {});\n                if(!attrs)\n                    return this;\n                // 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs\n                // 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作\n                if( attrs instanceof Model)\n                    attrs = attrs.attributes;\n                \n                // 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作\n                if(options.unset)\n                    for(attr in attrs)\n                    attrs[attr] =\n                    void 0;\n\n                // 如果设置了validate() 函数，则需要验证\n                if(!this._validate(attrs, options))\n                    return false;\n\n                // 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性\n                // 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id\n                if(this.idAttribute in attrs)\n                    this.id = attrs[this.idAttribute];\n\n                var changes = options.changes = {};\n                // now记录当前模型中的数据对象\n                var now = this.attributes;\n                // escaped记录当前模型中通过escape缓存过的数据\n                var escaped = this._escapedAttributes;\n                // prev记录模型中数据被改变之前的值\n                var prev = this._previousAttributes || {};\n\n                // code..\n\n                // 如果没有配置silent参数，则需要触发change函数。\n                if(!options.silent)\n                    this.change(options);\n                return this;\n            },\n            // 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件\n            fetch : function(options) {\n                options = options ? _.clone(options) : {};\n                var model = this;\n                var success = options.success;\n                // 当获取数据成功后填充数据并调用自定义成功回调函数\n                options.success = function(resp, status, xhr) {\n                    // 如果填充数据时验证失败, 则不会调用自定义success回调函数\n                    if(!model.set(model.parse(resp, xhr), options))\n                        return false;\n                    // 调用自定义的success回调函数\n                    if(success)\n                        success(model, resp);\n                };\n                // 请求发生错误时通过wrapError处理error事件\n                options.error = Backbone.wrapError(options.error, model, options);\n                // 所有的读取数据(Model, Collection)都是通过sync提供的HTTP方法操作\n                return (this.sync || Backbone.sync).call(this, 'read', this, options);\n            },\n            // 保存模型中的数据到服务器\n            save : function(key, value, options) {\n                // attrs存储需要保存到服务器的数据对象\n                var attrs, current;\n\n                // 支持设置单个属性的方式 key: value\n                // 支持对象形式的批量设置方式 {key: value}\n                if(_.isObject(key) || key == null) {\n                    // 如果key是一个对象, 则认为是通过对象方式设置\n                    // 此时第二个参数被认为是options\n                    attrs = key;\n                    options = value;\n                } else {\n                    // 如果是通过key: value形式设置单个属性, 则直接设置attrs\n                    attrs = {};\n                    attrs[key] = value;\n                }\n                // 配置对象必须是一个新的对象\n                options = options ? _.clone(options) : {};\n\n                // 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态\n                // 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态\n                if(options.wait) {\n                    // 对需要保存的数据提前进行验证\n                    if(!this._validate(attrs, options))\n                        return false;\n                    current = _.clone(this.attributes);\n                }\n\n                var model = this;\n                // 在options中可以指定保存数据成功后的自定义回调函数\n                var success = options.success;\n                options.success = function(resp, status, xhr) {\n                    var serverAttrs = model.parse(resp, xhr);\n                    if(options.wait) {\n                        delete options.wait;\n                        serverAttrs = _.extend(attrs || {}, serverAttrs);\n                    }\n                    // 如果调用set方法时验证失败, 则不会调用自定义的success回调函数\n                    if(!model.set(serverAttrs, options))\n                        return false;\n                    if(success) {\n                        // 调用响应成功后自定义的success回调函数\n                        success(model, resp);\n                    } else {\n                        // 如果没有指定自定义回调, 则默认触发sync事件\n                        model.trigger('sync', model, resp, options);\n                    }\n                };\n                // 请求发生错误时通过wrapError处理error事件\n                options.error = Backbone.wrapError(options.error, model, options);\n                \n                var method = this.isNew() ? 'create' : 'update';\n                var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n                // 如果设置了options.wait, 则将数据还原为修改前的状态\n                // 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态\n                if(options.wait)\n                    this.set(current, silentOptions);\n                return xhr;\n            },\n            // code..\n        });\n\n\n## Collection \n\n          var Collection = Backbone.Collection = function(models, options) {\n            options || ( options = {});\n            if(options.model)\n                this.model = options.model;\n            // 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用) \n            // 当然也可以服务器做好了传回来，但是如果前后属于不同团队就不好做了。\n            if(options.comparator)\n                this.comparator = options.comparator;\n\n            // 实例化时重置集合的内部状态(第一次调用时可理解为定义状态)\n            this._reset();\n            this.initialize.apply(this, arguments);\n            \n            // 首次调用时设置了silent参数, 因此不会触发\"reset\"事件\n            if(models)\n                this.reset(models, {\n                    silent : true,\n                    parse : options.parse\n                });\n        };\n        _.extend(Collection.prototype, Events, {\n            // 定义集合的模型类, 模型类必须是一个Backbone.Model的子类\n            model : Model,\n            initialize : function() {\n            },\n            // 返回一个数组, 包含了集合中每个模型的数据对象\n            toJSON : function(options) {\n                return this.map(function(model) {\n                    return model.toJSON(options);\n                });\n            },\n            // 默认会触发\"add\"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发\n            // 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 {name: 'test'}), 将自动将数据对象实例化为model指向的模型对象\n            add : function(models, options) {\n                var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];\n                options || ( options = {});\n                // models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组\n                models = _.isArray(models) ? models.slice() : [models];\n\n                // 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作:\n                // - 将数据对象转化模型对象\n                // - 建立模型与集合之间的引用\n                // - 记录无效和重复的模型, 并在后面进行过滤\n                for( i = 0, length = models.length; i < length; i++) {\n                   \n                    // 当前模型的cid和id\n                    cid = model.cid;\n                    id = model.id;\n                    // dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除\n                    if(cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {\n                        dups.push(i);\n                        continue;\n                    }\n                    cids[cid] = ids[id] = model;\n                }\n                // 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表\n                i = dups.length;\n                while(i--) {\n                    models.splice(dups[i], 1);\n                }\n\n                // code ...\n\n                // 遍历新增加的模型列表\n                for( i = 0, length = this.models.length; i < length; i++) {\n                    if(!cids[( model = this.models[i]).cid])\n                        continue;\n                    options.index = i;\n                    // 触发模型的\"add\"事件, 因为集合监听了模型的\"all\"事件, 因此在_onModelEvent方法中, 集合也将触发\"add\"事件\n                    // 详细信息可参考Collection.prototype._onModelEvent方法\n                    model.trigger('add', model, this, options);\n                }\n                return this;\n            },\n            // 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件)\n            remove : function(models, options) {\n                var i, l, index, model;\n                options || ( options = {});\n                models = _.isArray(models) ? models.slice() : [models];\n                // 遍历需要移除的模型列表\n                for( i = 0, l = models.length; i < l; i++) {\n                    model = this.getByCid(models[i]) || this.get(models[i]);\n                    if(!model)\n                        continue;\n                    delete this._byId[model.id];\n                    delete this._byCid[model.cid];\n                    index = this.indexOf(model);\n                    this.models.splice(index, 1);\n                    this.length--;\n                    // 如果没有设置silent属性, 则触发模型的remove事件\n                    if(!options.silent) {\n                        options.index = index;\n                        model.trigger('remove', model, this, options);\n                    }\n                    this._removeReference(model);\n                }\n                return this;\n            },\n            push : function(model, options) {\n                model = this._prepareModel(model, options);\n                this.add(model, options);\n                return model;\n            },\n            // code ..\n        });\n\n\n## Router & History\n   \n        var Router = Backbone.Router = function(options) {\n            options || ( options = {});\n            if(options.routes)\n                this.routes = options.routes;\n            this._bindRoutes();\n            this.initialize.apply(this, arguments);\n        };\n        _.extend(Router.prototype, Events, {\n            // 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件\n            route : function(route, name, callback) {\n                // 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化\n                Backbone.history || (Backbone.history = new History);\n                // code ...\n                Backbone.history.route(route, _.bind(function(fragment) {\n                    var args = this._extractParameters(route, fragment);\n                    // 调用callback路由监听事件, 并将参数传递给监听事件\n                    callback && callback.apply(this, args);\n                    \n                    this.trigger.apply(this, ['route:' + name].concat(args));\n                    // 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件\n                    Backbone.history.trigger('route', this, name, args);\n                    \n                }, this));\n                return this;\n            },\n           // code ..\n        });\n\n        // History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问)\n        var History = Backbone.History = function() {\n            this.handlers = [];\n            // checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法\n            _.bindAll(this, 'checkUrl');\n        };\n\n        _.extend(History.prototype, Events, {\n            // 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化\n            // interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置)\n            interval : 50,\n            // 获取location中Hash字符串(锚点#后的片段)\n            getHash : function(windowOverride) {\n                // 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取\n                var loc = windowOverride ? windowOverride.location : window.location;\n                // 将锚点(#)后的字符串提取出来并返回\n                var match = loc.href.match(/#(.*)$/);\n                return match ? match[1] : '';\n            },\n            // 根据当前设置的路由方式, 处理并返回当前URL中的路由片段\n            getFragment : function(fragment, forcePushState) {\n                // fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288)\n                if(fragment == null) {\n                    if(this._hasPushState || forcePushState) {\n                        // 使用了pushState方式进行路由\n                        fragment = window.location.pathname;\n                        // search记录当前页面后的参数内容\n                        var search = window.location.search;\n                        // 将路径和参数合并在一起, 作为待处理的路由片段\n                        if(search)\n                            fragment += search; \n                    } else {\n                        // 使用了hash方式进行路由\n                        // 通过getHash方法获取当前锚点(#)后的字符串作为路由片段\n                        fragment = this.getHash();\n                    }\n                }\n                if(!fragment.indexOf(this.options.root))\n                    fragment = fragment.substr(this.options.root.length);\n                // 如果URL片段首字母为\"#\"或\"/\", 则去除该字符\n                return fragment.replace(routeStripper, '');\n            },\n            // 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数\n            start : function(options) {\n\n                // (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式)\n                this._wantsHashChange = this.options.hashChange !== false;\n                // _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器\n                // pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式\n                this._wantsPushState = !!this.options.pushState;\n\n                // _hasPushState属性记录浏览器是否支持pushState特性\n                this._hasPushState = !!(this.options.pushState && window.history && window.history.pushState);\n\n                var fragment = this.getFragment();\n                // documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式\n                var docMode = document.documentMode;\n                var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n                if(oldIE) {\n                    // 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件\n                    // 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由\n                    this.iframe = $('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\n                    this.navigate(fragment);\n                }\n\n                // 开始监听路由状态变化\n                if(this._hasPushState) {\n                    // 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法\n                    $(window).bind('popstate', this.checkUrl);\n                } else if(this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n                    // 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法\n                    $(window).bind('hashchange', this.checkUrl);\n                } else if(this._wantsHashChange) {\n                    // 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率\n                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n                }\n                // code ..\n            },\n            // 停止history对路由的监控, 并将状态恢复为未监听状态\n            stop : function() {\n                // 解除对浏览器路由的onpopstate和onhashchange事件的监听\n                $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n                // 停止对于低版本的IE浏览器的心跳监控\n                clearInterval(this._checkUrlInterval);\n                // 恢复started状态, 便于下次重新调用start方法\n                History.started = false;\n            },\n            // 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用\n            checkUrl : function(e) {\n                // 获取当前的URL片段\n                var current = this.getFragment();\n                // 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量\n                if(current == this.fragment && this.iframe)\n                    current = this.getFragment(this.getHash(this.iframe));\n                // 如果当前URL与上一次的状态没有发生任何变化, 则停止执行\n                if(current == this.fragment)\n                    return false;\n\n                // 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL\n                if(this.iframe)\n                    this.navigate(current);\n                // 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法\n                this.loadUrl() || this.loadUrl(this.getHash());\n            },\n            // code ..\n        });\n\n## View\n\n     \n        // Backbone.View 视图相关\n        var View = Backbone.View = function(options) {\n            // 为每一个视图对象创建一个唯一标识, 前缀为\"view\"\n            this.cid = _.uniqueId('view');\n            this._configure(options || {});\n            this._ensureElement();\n            this.initialize.apply(this, arguments);\n            this.delegateEvents();\n        };\n\n        // viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身\n        var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];\n        _.extend(View.prototype, Events, {\n            // 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签\n            tagName : 'div',\n            // code ..\n            // 移除当前视图的$el元素\n            remove : function() {\n                // 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据\n                this.$el.remove();\n                return this;\n            },\n            // 该方法用于在内部创建this.el时自动调用\n            make : function(tagName, attributes, content) {\n                var el = document.createElement(tagName);\n                if(attributes)\n                    $(el).attr(attributes);\n                if(content)\n                    $(el).html(content);\n                return el;\n            },\n            // 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用\n            setElement : function(element, delegate) {\n                // this.$el 存放Jquery或其他库的示例对象\n                this.$el = ( element instanceof $) ? element : $(element);\n                // this.el存放标准的DOM对象\n                this.el = this.$el[0];\n                // code ...\n                return this;\n            },\n            // 为视图元素绑定事件\n            // events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'):\n            // {\n            //     'click #title': 'edit',\n            //     'click .save': 'save'\n            //     'click span': function() {}\n            // }\n            // 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合)\n            delegateEvents : function(events) {\n                if(!(events || ( events = getValue(this, 'events'))))\n                    return;\n                // 取消当前已经绑定过的events事件\n                this.undelegateEvents();\n                for(var key in events) {\n                    // code ...                \n                    // 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素\n                    // 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中\n                    var match = key.match(delegateEventSplitter);\n                    // eventName为解析后的事件名称\n                    // selector为解析后的事件元素选择器表达式\n                    var eventName = match[1], selector = match[2];\n                    \n                    method = _.bind(method, this);\n                    // 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法\n                    eventName += '.delegateEvents' + this.cid;\n                    if(selector === '') {\n                        this.$el.bind(eventName, method);\n                    } else {\n                        this.$el.delegate(selector, eventName, method);\n                    }\n                }\n            },\n            \n            // 在实例化视图对象时设置初始配置\n            // 将传递的配置覆盖到对象的options中\n            // 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性\n            _configure : function(options) {\n                // 如果对象本身设置了默认配置, 则使用传递的配置进行合并\n                if(this.options)\n                    options = _.extend({}, this.options, options);\n                // 遍历viewOptions列表\n                for(var i = 0, l = viewOptions.length; i < l; i++) {\n                    // attr依次为viewOptions中的属性名\n                    var attr = viewOptions[i];\n                    // 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性\n                    if(options[attr])\n                        this[attr] = options[attr];\n                }\n                this.options = options;\n            },\n            _ensureElement : function() {\n                \n                if(!this.el) {\n                    // 如果没有设置el属性, 则创建默认元素\n                    var attrs = getValue(this, 'attributes') || {};\n                    if(this.id)\n                        attrs.id = this.id;\n                    if(this.className)\n                        attrs['class'] = this.className;\n                    // 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素\n                    this.setElement(this.make(this.tagName, attrs), false);\n                } else {\n                    // 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素\n                    this.setElement(this.el, false);\n                }\n            }\n        });\n\n\n## Backbone.sync\n\n    var methodMap = {\n            'create' : 'POST',\n            'update' : 'PUT',\n            'delete' : 'DELETE',\n            'read' : 'GET'\n        };\n        // Async用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的连接\n        // sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持\n        // Model Collection save 或者fetch都用这个这个类。\n        Backbone.sync = function(method, model, options) {\n            // 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE)\n            var type = methodMap[method];\n\n            // params将作为请求参数对象传递给第三方库的$.ajax方法\n            var params = {\n                // 请求类型\n                type : type,\n                // 数据格式默认为json\n                dataType : 'json'\n            };\n\n            // 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url\n            if(!options.url) {\n                params.url = getValue(model, 'url') || urlError();\n            }\n\n            if(!options.data && model && (method == 'create' || method == 'update')) {\n                params.contentType = 'application/json';\n                params.data = JSON.stringify(model.toJSON());\n            }\n            if(Backbone.emulateHTTP) {\n                // 如果操作类型为PUT或DELETE\n                if(type === 'PUT' || type === 'DELETE') {\n                    // 将操作名称存放到_method参数发送到服务器\n                    if(Backbone.emulateJSON)\n                        params.data._method = type;\n                    // 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息\n                    params.type = 'POST';\n                    params.beforeSend = function(xhr) {\n                        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                    };\n                }\n            }\n            // 通过第三方库的$.ajax方法向服务器发送请求同步数据状态\n            return $.ajax(_.extend(params, options));\n        };\n\n\n## 使用\n\n            \n        var extend = function(protoProps, classProps) {\n            // child存储已经实现继承自当前类的子类(Function)\n            // protoProps设置子类原型链中的属性\n            // classProps设置子类的静态属性\n            var child = inherits(this, protoProps, classProps);\n            // 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承\n            child.extend = this.extend;\n            // 返回实现继承的子类\n            return child;\n        };\n        // 为Model, Collection, Router和View类实现继承机制 每次使用只需要 Backbone.View.extend({...});\n        Model.extend = Collection.extend = Router.extend = View.extend = extend;\n\n\n## 说明\n\n本次分析基本上对翻译源码注释，中间省略了一些个人认为对理解代码实现和平时应用关系不大的代码。","mobiledoc":null,"html":"<h2 id=\"\">说明</h2>\n\n<p>前段时间略忙，终于找到时间看看backbone代码。</p>\n\n<p>正如知友们说的那样，backbone简单、随性。 代码简单的看一眼，就能知道作者的思路。因为简单，所以随性，可以很自由的和其他类库大搭配使用，不太要求特别的格式。</p>\n\n<p>本文会关注backbone实现的细节，整体框架在博客园的一位朋友已经总结的很好了。链接：<a href=\"http://www.cnblogs.com/nuysoft/archive/2012/03/19/2404274.html\">点击这里</a></p>\n\n<p>本文Bakcbone版本： </p>\n\n<pre><code>        // 定义Backbone版本\n        Backbone.VERSION = '0.9.2';\n</code></pre>\n\n<h4 id=\"\">照例提点问题，有目的的读源码。</h4>\n\n<ol>\n<li>怎么和模板引擎配合使用的。  </li>\n<li>RESTful JSON 接口从服务器检索到的数据  </li>\n<li>通过源码，了解到平时使用时的哪些需要注意的细节。  </li>\n<li>当models中值被改变时自动触发一个\"change\"事件、所有用于展示models数据的views都会侦听到这个事件，然后进行重新渲染。如何实现？  </li>\n<li>如何兼容IE6+  </li>\n<li>view model collection怎么关联的。</li>\n</ol>\n\n<h2 id=\"\">整体框架</h2>\n\n<pre><code>    (function() {\n        Backbone.Events        // 自定义事件\n        Backbone.Model        // 模型构造函数和原型扩展\n        Backbone.Collection    // 集合构造函数和原型扩展\n        Backbone.Router        // 路由配置器构造函数和原型扩展\n        Backbone.History        // 路由器构造函数和原型扩展\n        Backbone.View            // 视图构造函数和原型扩展\n        Backbone.sync            // 异步请求工具方法\n        var extend = function (protoProps, classProps) { ... } // 自扩展函数\n        Backbone.Model.extend = Backbone.Collection.extend =          Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法\n    }).call(this);\n</code></pre>\n\n<p>本文的思路是按照这个框架，提炼每个部分的重要部分，解决上面提出的问题，并注释平时使用时需要注意的细节。</p>\n\n<h2 id=\"events\">Events</h2>\n\n<pre><code>        var Events = Backbone.Events = {\n        // 该方法类似与DOM Level2中的addEventListener方法\n        // events允许指定多个事件名称, 通过空白字符进行分隔(如空格, 制表符等)\n        // 当事件名称为\"all\"时, 在调用trigger方法触发任何事件时, 均会调用\"all\"事件中绑定的所有回调函数\n        on : function(events, callback, context) {\n            var calls, event, node, tail, list;\n            if(!callback)\n                return this;\n            // eventSplitter = /\\s+/; 把多个事件名组成的字符串分开。\n            events = events.split(eventSplitter);\n\n            // 所有事件都存在this._callbacks这个数组里面\n            calls = this._callbacks || (this._callbacks = {});\n\n            while( event = events.shift()) {\n                list = calls[event];\n                node = list ? list.tail : {};\n                node.next = tail = {};\n                node.context = context;\n                node.callback = callback;\n                // 重新组装当前事件的回调列表, 列表中已经加入了本次回调事件\n                calls[event] = {\n                    tail : tail,\n                    next : list ? list.next : node\n                };\n            }\n            // 返回当前对象, 方便进行方法链调用\n            return this;\n        },\n        // - 如果context为空, 则移除所有的callback指定的函数\n        // - 如果callback为空, 则移除事件中所有的回调函数\n        // - 如果events为空, 但指定了callback或context, 则移除callback或context指定的回调函数(不区分事件名称)\n        // - 如果没有传递任何参数, 则移除对象中绑定的所有事件和回调函数\n        off : function(events, callback, context) {\n            // code...\n            return this;\n        },\n        // 触发已经定义的一个或多个事件, 依次执行绑定的回调函数列表\n        trigger : function(events) {\n            var event, node, calls, tail, args, all, rest;\n            // 当前对象没有绑定任何事件\n            if(!( calls = this._callbacks))\n                return this;\n            // 获取回调函数列表中绑定的\"all\"事件列表\n            all = calls.all;\n            // 将需要触发的事件名称, 按照eventSplitter规则解析为一个数组\n            events = events.split(eventSplitter);\n            // 将trigger从第2个之后的参数, 记录到rest变量, 将依次传递给回调函数\n            rest = slice.call(arguments, 1);\n\n            // 循环需要触发的事件列表\n            while( event = events.shift()) {\n                // 此处的node变量记录了当前事件的所有回调函数列表\n                if( node = calls[event]) {\n                    tail = node.tail;\n                    // node变量的值, 按照事件的绑定顺序, 被依次赋值为绑定的单个回调事件对象\n                    // 最后一次绑定的事件next属性, 与tail引用同一个对象, 以此作为是否到达列表末尾的判断依据\n                    while(( node = node.next) !== tail) {\n                        // 执行所有绑定的事件, 并将调用trigger时的参数传递给回调函数\n                        node.callback.apply(node.context || this, rest);\n                    }\n                }\n                if( node = all) {\n                    tail = node.tail;\n                    // 与调用普通事件的回调函数不同之处在于, all事件会将当前调用的事件名作为第一个参数传递给回调函数\n                    args = [event].concat(rest);\n                    // 遍历并执行\"all\"事件中的回调函数列表\n                    while(( node = node.next) !== tail) {\n                        node.callback.apply(node.context || this, args);\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n    // 绑定事件与释放事件的别名, 也为了同时兼容Backbone以前的版本\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n</code></pre>\n\n<h2 id=\"model\">Model</h2>\n\n<p>Model 比较常用，很多细节，所以列出了几个重要的函数，注释了一些重要细节。</p>\n\n<pre><code>    _.extend(Model.prototype, Events, {\n         // code..\n        // 设置模型中的数据, 如果key值不存在, 则作为新的属性添加到模型, 如果key值已经存在, 则修改为新的值\n        set : function(key, value, options) {\n            var attrs, attr, val;\n\n            // 参数形式允许key-value对象形式, 或通过key, value两个参数进行单独设置\n            // 如果key是一个对象, 则认定为使用对象形式设置, 第二个参数将被视为options参数\n            if(_.isObject(key) || key == null) {\n                attrs = key;\n                options = value;\n            } else {\n                attrs = {};\n                attrs[key] = value;\n            }\n\n            // options配置项必须是一个对象, 如果没有设置options则默认值为一个空对象\n            options || ( options = {});\n            if(!attrs)\n                return this;\n            // 如果被设置的数据对象属于Model类的一个实例, 则将Model对象的attributes数据对象赋给attrs\n            // 一般在复制一个Model对象的数据到另一个Model对象时, 会执行该动作\n            if( attrs instanceof Model)\n                attrs = attrs.attributes;\n\n            // 一般在复制一个Model对象的数据到另一个Model对象时, 但仅仅需要复制Model中的数据而不需要复制值时执行该操作\n            if(options.unset)\n                for(attr in attrs)\n                attrs[attr] =\n                void 0;\n\n            // 如果设置了validate() 函数，则需要验证\n            if(!this._validate(attrs, options))\n                return false;\n\n            // 如果设置的id属性名被包含在数据集合中, 则将id覆盖到模型的id属性\n            // 这是为了确保在自定义id属性名后, 访问模型的id属性时, 也能正确访问到id\n            if(this.idAttribute in attrs)\n                this.id = attrs[this.idAttribute];\n\n            var changes = options.changes = {};\n            // now记录当前模型中的数据对象\n            var now = this.attributes;\n            // escaped记录当前模型中通过escape缓存过的数据\n            var escaped = this._escapedAttributes;\n            // prev记录模型中数据被改变之前的值\n            var prev = this._previousAttributes || {};\n\n            // code..\n\n            // 如果没有配置silent参数，则需要触发change函数。\n            if(!options.silent)\n                this.change(options);\n            return this;\n        },\n        // 从服务器获取默认的模型数据, 获取数据后使用set方法将数据填充到模型, 因此如果获取到的数据与当前模型中的数据不一致, 将会触发change事件\n        fetch : function(options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n            // 当获取数据成功后填充数据并调用自定义成功回调函数\n            options.success = function(resp, status, xhr) {\n                // 如果填充数据时验证失败, 则不会调用自定义success回调函数\n                if(!model.set(model.parse(resp, xhr), options))\n                    return false;\n                // 调用自定义的success回调函数\n                if(success)\n                    success(model, resp);\n            };\n            // 请求发生错误时通过wrapError处理error事件\n            options.error = Backbone.wrapError(options.error, model, options);\n            // 所有的读取数据(Model, Collection)都是通过sync提供的HTTP方法操作\n            return (this.sync || Backbone.sync).call(this, 'read', this, options);\n        },\n        // 保存模型中的数据到服务器\n        save : function(key, value, options) {\n            // attrs存储需要保存到服务器的数据对象\n            var attrs, current;\n\n            // 支持设置单个属性的方式 key: value\n            // 支持对象形式的批量设置方式 {key: value}\n            if(_.isObject(key) || key == null) {\n                // 如果key是一个对象, 则认为是通过对象方式设置\n                // 此时第二个参数被认为是options\n                attrs = key;\n                options = value;\n            } else {\n                // 如果是通过key: value形式设置单个属性, 则直接设置attrs\n                attrs = {};\n                attrs[key] = value;\n            }\n            // 配置对象必须是一个新的对象\n            options = options ? _.clone(options) : {};\n\n            // 如果在options中设置了wait选项, 则被改变的数据将会被提前验证, 且服务器没有响应新数据(或响应失败)时, 本地数据会被还原为修改前的状态\n            // 如果没有设置wait选项, 则无论服务器是否设置成功, 本地数据均会被修改为最新状态\n            if(options.wait) {\n                // 对需要保存的数据提前进行验证\n                if(!this._validate(attrs, options))\n                    return false;\n                current = _.clone(this.attributes);\n            }\n\n            var model = this;\n            // 在options中可以指定保存数据成功后的自定义回调函数\n            var success = options.success;\n            options.success = function(resp, status, xhr) {\n                var serverAttrs = model.parse(resp, xhr);\n                if(options.wait) {\n                    delete options.wait;\n                    serverAttrs = _.extend(attrs || {}, serverAttrs);\n                }\n                // 如果调用set方法时验证失败, 则不会调用自定义的success回调函数\n                if(!model.set(serverAttrs, options))\n                    return false;\n                if(success) {\n                    // 调用响应成功后自定义的success回调函数\n                    success(model, resp);\n                } else {\n                    // 如果没有指定自定义回调, 则默认触发sync事件\n                    model.trigger('sync', model, resp, options);\n                }\n            };\n            // 请求发生错误时通过wrapError处理error事件\n            options.error = Backbone.wrapError(options.error, model, options);\n\n            var method = this.isNew() ? 'create' : 'update';\n            var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n            // 如果设置了options.wait, 则将数据还原为修改前的状态\n            // 此时保存的请求还没有得到响应, 因此如果响应失败, 模型中将保持修改前的状态, 如果服务器响应成功, 则会在success中设置模型中的数据为最新状态\n            if(options.wait)\n                this.set(current, silentOptions);\n            return xhr;\n        },\n        // code..\n    });\n</code></pre>\n\n<h2 id=\"collection\">Collection</h2>\n\n<pre><code>      var Collection = Backbone.Collection = function(models, options) {\n        options || ( options = {});\n        if(options.model)\n            this.model = options.model;\n        // 如果设置了comparator属性, 则集合中的数据将按照comparator方法中的排序算法进行排序(在add方法中会自动调用) \n        // 当然也可以服务器做好了传回来，但是如果前后属于不同团队就不好做了。\n        if(options.comparator)\n            this.comparator = options.comparator;\n\n        // 实例化时重置集合的内部状态(第一次调用时可理解为定义状态)\n        this._reset();\n        this.initialize.apply(this, arguments);\n\n        // 首次调用时设置了silent参数, 因此不会触发\"reset\"事件\n        if(models)\n            this.reset(models, {\n                silent : true,\n                parse : options.parse\n            });\n    };\n    _.extend(Collection.prototype, Events, {\n        // 定义集合的模型类, 模型类必须是一个Backbone.Model的子类\n        model : Model,\n        initialize : function() {\n        },\n        // 返回一个数组, 包含了集合中每个模型的数据对象\n        toJSON : function(options) {\n            return this.map(function(model) {\n                return model.toJSON(options);\n            });\n        },\n        // 默认会触发\"add\"事件, 如果在options中设置了silent属性, 可以关闭此次事件触发\n        // 传入的models可以是一个或一系列的模型对象(Model类的实例), 如果在集合中设置了model属性, 则允许直接传入数据对象(如 {name: 'test'}), 将自动将数据对象实例化为model指向的模型对象\n        add : function(models, options) {\n            var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];\n            options || ( options = {});\n            // models必须是一个数组, 如果只传入了一个模型, 则将其转换为数组\n            models = _.isArray(models) ? models.slice() : [models];\n\n            // 遍历需要添加的模型列表, 遍历过程中, 将执行以下操作:\n            // - 将数据对象转化模型对象\n            // - 建立模型与集合之间的引用\n            // - 记录无效和重复的模型, 并在后面进行过滤\n            for( i = 0, length = models.length; i &lt; length; i++) {\n\n                // 当前模型的cid和id\n                cid = model.cid;\n                id = model.id;\n                // dups数组中记录了无效或重复的模型索引(models数组中的索引), 并在下一步进行过滤删除\n                if(cids[cid] || this._byCid[cid] || ((id != null) &amp;&amp; (ids[id] || this._byId[id]))) {\n                    dups.push(i);\n                    continue;\n                }\n                cids[cid] = ids[id] = model;\n            }\n            // 从models中删除无效或重复的模型, 保留目前集合中真正需要添加的模型列表\n            i = dups.length;\n            while(i--) {\n                models.splice(dups[i], 1);\n            }\n\n            // code ...\n\n            // 遍历新增加的模型列表\n            for( i = 0, length = this.models.length; i &lt; length; i++) {\n                if(!cids[( model = this.models[i]).cid])\n                    continue;\n                options.index = i;\n                // 触发模型的\"add\"事件, 因为集合监听了模型的\"all\"事件, 因此在_onModelEvent方法中, 集合也将触发\"add\"事件\n                // 详细信息可参考Collection.prototype._onModelEvent方法\n                model.trigger('add', model, this, options);\n            }\n            return this;\n        },\n        // 如果没有设置options.silent参数, 将触发模型的remove事件, 同时将触发集合的remove事件(集合通过_onModelEvent方法监听了模型的所有事件)\n        remove : function(models, options) {\n            var i, l, index, model;\n            options || ( options = {});\n            models = _.isArray(models) ? models.slice() : [models];\n            // 遍历需要移除的模型列表\n            for( i = 0, l = models.length; i &lt; l; i++) {\n                model = this.getByCid(models[i]) || this.get(models[i]);\n                if(!model)\n                    continue;\n                delete this._byId[model.id];\n                delete this._byCid[model.cid];\n                index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                // 如果没有设置silent属性, 则触发模型的remove事件\n                if(!options.silent) {\n                    options.index = index;\n                    model.trigger('remove', model, this, options);\n                }\n                this._removeReference(model);\n            }\n            return this;\n        },\n        push : function(model, options) {\n            model = this._prepareModel(model, options);\n            this.add(model, options);\n            return model;\n        },\n        // code ..\n    });\n</code></pre>\n\n<h2 id=\"routerhistory\">Router &amp; History</h2>\n\n<pre><code>    var Router = Backbone.Router = function(options) {\n        options || ( options = {});\n        if(options.routes)\n            this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n    _.extend(Router.prototype, Events, {\n        // 将一个路由规则绑定给一个监听事件, 当URL片段匹配该规则时, 会自动调用触发该事件\n        route : function(route, name, callback) {\n            // 创建history实例, Backbone.history是一个单例对象, 只在第一次创建路由器对象时被实例化\n            Backbone.history || (Backbone.history = new History);\n            // code ...\n            Backbone.history.route(route, _.bind(function(fragment) {\n                var args = this._extractParameters(route, fragment);\n                // 调用callback路由监听事件, 并将参数传递给监听事件\n                callback &amp;&amp; callback.apply(this, args);\n\n                this.trigger.apply(this, ['route:' + name].concat(args));\n                // 触发history实例中绑定的route事件, 当路由器匹配到任何规则时, 均会触发该事件\n                Backbone.history.trigger('route', this, name, args);\n\n            }, this));\n            return this;\n        },\n       // code ..\n    });\n\n    // History一般不会被直接调用, 在第一次实例化Router对象时, 将自动创建一个History的单例(通过Backbone.history访问)\n    var History = Backbone.History = function() {\n        this.handlers = [];\n        // checkUrl方法用于在监听到URL发生变化时检查并调用loadUrl方法\n        _.bindAll(this, 'checkUrl');\n    };\n\n    _.extend(History.prototype, Events, {\n        // 当用户使用低版本的IE浏览器(不支持onhashchange事件)时, 通过心跳监听路由状态的变化\n        // interval属性设置心跳频率(毫秒), 该频率如果太低可能会导致延迟, 如果太高可能会消耗CPU资源(需要考虑用户使用低端浏览器时的设备配置)\n        interval : 50,\n        // 获取location中Hash字符串(锚点#后的片段)\n        getHash : function(windowOverride) {\n            // 如果传入了一个window对象, 则从该对象中获取, 否则默认从当前window对象中获取\n            var loc = windowOverride ? windowOverride.location : window.location;\n            // 将锚点(#)后的字符串提取出来并返回\n            var match = loc.href.match(/#(.*)$/);\n            return match ? match[1] : '';\n        },\n        // 根据当前设置的路由方式, 处理并返回当前URL中的路由片段\n        getFragment : function(fragment, forcePushState) {\n            // fragment是通过getHash或从URL中已经提取的待处理路由片段(如 #/id/1288)\n            if(fragment == null) {\n                if(this._hasPushState || forcePushState) {\n                    // 使用了pushState方式进行路由\n                    fragment = window.location.pathname;\n                    // search记录当前页面后的参数内容\n                    var search = window.location.search;\n                    // 将路径和参数合并在一起, 作为待处理的路由片段\n                    if(search)\n                        fragment += search; \n                } else {\n                    // 使用了hash方式进行路由\n                    // 通过getHash方法获取当前锚点(#)后的字符串作为路由片段\n                    fragment = this.getHash();\n                }\n            }\n            if(!fragment.indexOf(this.options.root))\n                fragment = fragment.substr(this.options.root.length);\n            // 如果URL片段首字母为\"#\"或\"/\", 则去除该字符\n            return fragment.replace(routeStripper, '');\n        },\n        // 该方法作为整个路由的调度器, 它将针对不同浏览器监听URL片段的变化, 负责验证并通知到监听函数\n        start : function(options) {\n\n            // (如果手动设置了options.pushState为true, 且浏览器支持pushState特性, 则会使用pushState方式)\n            this._wantsHashChange = this.options.hashChange !== false;\n            // _wantsPushState属性记录是否希望使用pushState方式来记录和导航路由器\n            // pushState是HTML5中为window.history添加的新特性, 如果没有手动声明options.pushState为true, 则默认将使用hash方式\n            this._wantsPushState = !!this.options.pushState;\n\n            // _hasPushState属性记录浏览器是否支持pushState特性\n            this._hasPushState = !!(this.options.pushState &amp;&amp; window.history &amp;&amp; window.history.pushState);\n\n            var fragment = this.getFragment();\n            // documentMode是IE浏览器的独有属性, 用于标识当前浏览器使用的渲染模式\n            var docMode = document.documentMode;\n            var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &amp;&amp; (!docMode || docMode &lt;= 7));\n\n            if(oldIE) {\n                // 如果用户使用低版本的IE浏览器, 不支持popstate和onhashchange事件\n                // 向DOM中插入一个隐藏的iframe, 并通过改变和心跳监听该iframe的URL实现路由\n                this.iframe = $('&lt;iframe src=\"javascript:0\" tabindex=\"-1\" /&gt;').hide().appendTo('body')[0].contentWindow;\n                this.navigate(fragment);\n            }\n\n            // 开始监听路由状态变化\n            if(this._hasPushState) {\n                // 如果使用了pushState方式路由, 且浏览器支持该特性, 则将popstate事件监听到checkUrl方法\n                $(window).bind('popstate', this.checkUrl);\n            } else if(this._wantsHashChange &amp;&amp; ('onhashchange' in window) &amp;&amp; !oldIE) {\n                // 如果使用Hash方式进行路由, 且浏览器支持onhashchange事件, 则将hashchange事件监听到checkUrl方法\n                $(window).bind('hashchange', this.checkUrl);\n            } else if(this._wantsHashChange) {\n                // 对于低版本的浏览器, 通过setInterval方法心跳监听checkUrl方法, interval属性标识心跳频率\n                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            }\n            // code ..\n        },\n        // 停止history对路由的监控, 并将状态恢复为未监听状态\n        stop : function() {\n            // 解除对浏览器路由的onpopstate和onhashchange事件的监听\n            $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n            // 停止对于低版本的IE浏览器的心跳监控\n            clearInterval(this._checkUrlInterval);\n            // 恢复started状态, 便于下次重新调用start方法\n            History.started = false;\n        },\n        // 该方法在onpopstate和onhashchange事件被触发后自动调用, 或者在低版本的IE浏览器中由setInterval心跳定时调用\n        checkUrl : function(e) {\n            // 获取当前的URL片段\n            var current = this.getFragment();\n            // 对低版本的IE浏览器, 将从iframe中获取最新的URL片段并赋给current变量\n            if(current == this.fragment &amp;&amp; this.iframe)\n                current = this.getFragment(this.getHash(this.iframe));\n            // 如果当前URL与上一次的状态没有发生任何变化, 则停止执行\n            if(current == this.fragment)\n                return false;\n\n            // 执行到这里, URL已经发生改变, 调用navigate方法将URL设置为当前URL\n            if(this.iframe)\n                this.navigate(current);\n            // 调用loadUrl方法, 检查匹配的规则, 并执行规则绑定的方法\n            this.loadUrl() || this.loadUrl(this.getHash());\n        },\n        // code ..\n    });\n</code></pre>\n\n<h2 id=\"view\">View</h2>\n\n<pre><code>    // Backbone.View 视图相关\n    var View = Backbone.View = function(options) {\n        // 为每一个视图对象创建一个唯一标识, 前缀为\"view\"\n        this.cid = _.uniqueId('view');\n        this._configure(options || {});\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents();\n    };\n\n    // viewOptions列表记录一些列属性名, 在构造视图对象时, 如果传递的配置项中包含这些名称, 则将属性复制到对象本身\n    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];\n    _.extend(View.prototype, Events, {\n        // 如果在创建视图对象时, 没有设置指定的el元素, 则会通过make方法创建一个元素, tagName为创建元素的默认标签\n        tagName : 'div',\n        // code ..\n        // 移除当前视图的$el元素\n        remove : function() {\n            // 通过调用jQuery或Zepto的remove方法, 因此在第三方库中会同时移除该元素绑定的所有事件和数据\n            this.$el.remove();\n            return this;\n        },\n        // 该方法用于在内部创建this.el时自动调用\n        make : function(tagName, attributes, content) {\n            var el = document.createElement(tagName);\n            if(attributes)\n                $(el).attr(attributes);\n            if(content)\n                $(el).html(content);\n            return el;\n        },\n        // 为视图对象设置标准的$el及el属性, 该方法在对象创建时被自动调用\n        setElement : function(element, delegate) {\n            // this.$el 存放Jquery或其他库的示例对象\n            this.$el = ( element instanceof $) ? element : $(element);\n            // this.el存放标准的DOM对象\n            this.el = this.$el[0];\n            // code ...\n            return this;\n        },\n        // 为视图元素绑定事件\n        // events参数配置了需要绑定事件的集合, 格式如('事件名称 元素选择表达式' : '事件方法名称/或事件函数'):\n        // {\n        //     'click #title': 'edit',\n        //     'click .save': 'save'\n        //     'click span': function() {}\n        // }\n        // 该方法在视图对象初始化时会被自动调用, 并将对象中的events属性作为events参数(事件集合)\n        delegateEvents : function(events) {\n            if(!(events || ( events = getValue(this, 'events'))))\n                return;\n            // 取消当前已经绑定过的events事件\n            this.undelegateEvents();\n            for(var key in events) {\n                // code ...                \n                // 解析事件表达式(key), 从表达式中解析出事件的名字和需要操作的元素\n                // 例如 'click #title'将被解析为 'click' 和 '#title' 两部分, 均存放在match数组中\n                var match = key.match(delegateEventSplitter);\n                // eventName为解析后的事件名称\n                // selector为解析后的事件元素选择器表达式\n                var eventName = match[1], selector = match[2];\n\n                method = _.bind(method, this);\n                // 设置事件名称, 在事件名称后追加标识, 用于传递给jQuery或Zepto的事件绑定方法\n                eventName += '.delegateEvents' + this.cid;\n                if(selector === '') {\n                    this.$el.bind(eventName, method);\n                } else {\n                    this.$el.delegate(selector, eventName, method);\n                }\n            }\n        },\n\n        // 在实例化视图对象时设置初始配置\n        // 将传递的配置覆盖到对象的options中\n        // 将配置中与viewOptions列表相同的配置复制到对象本身, 作为对象的属性\n        _configure : function(options) {\n            // 如果对象本身设置了默认配置, 则使用传递的配置进行合并\n            if(this.options)\n                options = _.extend({}, this.options, options);\n            // 遍历viewOptions列表\n            for(var i = 0, l = viewOptions.length; i &lt; l; i++) {\n                // attr依次为viewOptions中的属性名\n                var attr = viewOptions[i];\n                // 将options配置中与viewOptions相同的配置复制到对象本身, 作为对象的属性\n                if(options[attr])\n                    this[attr] = options[attr];\n            }\n            this.options = options;\n        },\n        _ensureElement : function() {\n\n            if(!this.el) {\n                // 如果没有设置el属性, 则创建默认元素\n                var attrs = getValue(this, 'attributes') || {};\n                if(this.id)\n                    attrs.id = this.id;\n                if(this.className)\n                    attrs['class'] = this.className;\n                // 通过make方法创建元素, 并调用setElement方法将元素设置为视图所使用的标准元素\n                this.setElement(this.make(this.tagName, attrs), false);\n            } else {\n                // 如果设置了el属性, 则直接调用setElement方法将el元素设置为视图的标准元素\n                this.setElement(this.el, false);\n            }\n        }\n    });\n</code></pre>\n\n<h2 id=\"backbonesync\">Backbone.sync</h2>\n\n<pre><code>var methodMap = {\n        'create' : 'POST',\n        'update' : 'PUT',\n        'delete' : 'DELETE',\n        'read' : 'GET'\n    };\n    // Async用于在Backbone中操作数据时, 向服务器发送请求同步数据状态, 以建立与服务器之间的连接\n    // sync发送默认通过第三方库(jQuery, Zepto等) $.ajax方法发送请求, 因此如果要调用状态同步相关的方法, 需要第三方库支持\n    // Model Collection save 或者fetch都用这个这个类。\n    Backbone.sync = function(method, model, options) {\n        // 根据CRUD方法名定义与服务器交互的方法(POST, GET, PUT, DELETE)\n        var type = methodMap[method];\n\n        // params将作为请求参数对象传递给第三方库的$.ajax方法\n        var params = {\n            // 请求类型\n            type : type,\n            // 数据格式默认为json\n            dataType : 'json'\n        };\n\n        // 如果在发送请求时没有在options中设置url地址, 将会通过模型对象的url属性或方法来获取url\n        if(!options.url) {\n            params.url = getValue(model, 'url') || urlError();\n        }\n\n        if(!options.data &amp;&amp; model &amp;&amp; (method == 'create' || method == 'update')) {\n            params.contentType = 'application/json';\n            params.data = JSON.stringify(model.toJSON());\n        }\n        if(Backbone.emulateHTTP) {\n            // 如果操作类型为PUT或DELETE\n            if(type === 'PUT' || type === 'DELETE') {\n                // 将操作名称存放到_method参数发送到服务器\n                if(Backbone.emulateJSON)\n                    params.data._method = type;\n                // 实际以POST方式进行提交, 并发送X-HTTP-Method-Override头信息\n                params.type = 'POST';\n                params.beforeSend = function(xhr) {\n                    xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                };\n            }\n        }\n        // 通过第三方库的$.ajax方法向服务器发送请求同步数据状态\n        return $.ajax(_.extend(params, options));\n    };\n</code></pre>\n\n<h2 id=\"\">使用</h2>\n\n<pre><code>    var extend = function(protoProps, classProps) {\n        // child存储已经实现继承自当前类的子类(Function)\n        // protoProps设置子类原型链中的属性\n        // classProps设置子类的静态属性\n        var child = inherits(this, protoProps, classProps);\n        // 将extend函数添加到子类, 因此调用子类的extend方法便可实现对子类的继承\n        child.extend = this.extend;\n        // 返回实现继承的子类\n        return child;\n    };\n    // 为Model, Collection, Router和View类实现继承机制 每次使用只需要 Backbone.View.extend({...});\n    Model.extend = Collection.extend = Router.extend = View.extend = extend;\n</code></pre>\n\n<h2 id=\"\">说明</h2>\n\n<p>本次分析基本上对翻译源码注释，中间省略了一些个人认为对理解代码实现和平时应用关系不大的代码。</p>","image":"/content/images/2016/07/backbone.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:26:34","created_by":1,"updated_at":"2016-07-19 14:06:26","updated_by":1,"published_at":"2014-01-28 00:26:00","published_by":1},{"id":98,"uuid":"d2ae0380-e750-4d4c-9c32-9fbce39e62e7","title":"基于Seajs的可控台球碰撞游戏","slug":"ji-yu-seajsde-ke-kong-tai-qiu-peng-zhuang-you-xi-2","markdown":"# 前言\n\n不记得哪个黑色星期五，贪吃鱼基本完工的时候，产品突然增加需求，要求金币扔出去后不消失，互相可碰撞，其最终结果还要由服务器控制(没错，至今做的所有游戏都有幕后黑手，=W=).\n\n对于碰撞以前只写过一个球到处碰墙壁的，小球之间的碰撞倒是没有接触，想到他们碰撞过程中的角度变化、速度分配，就不敢往下想了，于是马上想到box2d这个牛逼哄哄的引擎.\n\n但是，使用物理引擎虽然高效、逼真，但所有碰撞都是不可控，包括最终的落点。所以引擎不能解决这次遇到的需求。\n\n不能用引擎，咱自己写也不怕，反正当年物理和高数都学得还不错，嘻嘻、\n\n最后，趁游戏上线后的空闲时间，整理下碰撞的思路，记录成本文。\n\n如果你喜欢先睹为快，可以先去玩玩这个游戏:\n\n<a href=\"http://qubaoming.me/demo/CrashBall/index.html\" target=\"_blank\"> view demo >></a>\n\n\n\n# 游戏实现\n\n本文的核心代码是通过游戏中的逻辑移动过来，为了方便，所以代码组织也和cocos2d的思想类似。\n\ncocos2d中有Scene、director、layer层级之分，在demo中也有对应的init、game、ball，既然用到模块层级，当然首选seajs。\n\n#### 游戏架构\n        ├ css \n            ├ main.css\n        ├ js\n            ├ jquery   \n            ├ jquery.js\n            ├ seajs\n            ├ seajs.js\n            ├ ball\n            ├ game\n            ├ util\n            └ init\n        └ CrashBall.html\n\n`util`模块封装的是一些必要的工具函数\n\n`ball`模块封装小球move和drawPredict的类\n\n`game`模块控制游戏进度，管理小球的运动\n\n`init`模块是游戏入口，调用`game.js`的初始化和开始接口\n\n游戏难度集中在`ball`和`game`模块，所以只分析碰撞过程得碰撞检测和处理。\n\n\n\n####  复杂的碰撞\n\n&nbsp;&nbsp;&nbsp;&nbsp;首先建系很重要。由于我们模拟使用`left`和`top`来改变坐标，所以我们以`table`左上角为坐标原点，垂直向下为x轴正方向，水平向左为y轴正方向。\n\n__边缘碰撞处理__\n\n边缘碰撞处理较为常规，只需要检测小球坐标和边缘的相对关系即可：\n\n           // 左右墙壁\n           if (ball.x < util.R || ball.x > util.W - util.R) { \n                ball.angle *= -1; \n                ball.angle %= Math.PI; \n                ....\n                if (ball.x < util.R) {\n                   ball.x = util.R; \n                }\n                if (ball.x > util.W - util.R) {\n                   ball.x = util.W - util.R; \n                }\n            }\n\n            // 上下墙壁\n            if (ball.y < util.R || ball.y > util.H - util.R) { \n                ball.angle = ball.angle > 0 ? Math.PI - ball.angle: -Math.PI - ball.angle;                \n                ball.angle %= Math.PI;\n                ....\n            }  \n\n上述代码作用是，检测小球坐标和墙壁大小关系，修改小球运动的角度。\n\n计算角度的源码：\n    \n         angle = Math.atan2(toPos[0] - fromPos[0], toPos[1] - fromPos[1]);\n\n计算的是点(left, top)和x正方向的角度，即下图的∠DAC.\n\n\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\" alt=\"left\" width=\"264\" height=\"217\" class=\"alignnone size-full wp-image-282\" /></a>\n\n左右碰撞处理方案是乘以`-1`，∠DAC是入角，∠DAB和∠DAC正好差个`-1`.\n\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\" alt=\"top\" width=\"278\" height=\"240\" class=\"alignnone size-medium wp-image-283\" /></a>\n\n上下碰撞是分正负处理。如上图中∠EAC和∠EAB互补，如果反向运动，∠EAB和∠CAB的变化应该是反向再选择180°。\n\n最后注意的是，如果小球坐标超过边界坐标，则要它坐标设为边界坐标，不然就会出现靠着边界来回撞的bug，前人留下来的bug找了好久，= = .\n\n\n__小球碰撞处理__\n\na. 碰撞检测是判断他们的距离和2倍半径的关系：\n\n        var dis = Math.sqrt(Math.pow(disX, 2) + Math.pow(disY, 2)); \n        if (dis <= gap) {...}\n\n\n\nb. 如果速度太大或者重绘频率太小，怎会看到两个小球互相融入的效果，所以处理第一步是还原碰撞初始状态。\n\n        ball.x -= (gap - dis) * sin;\n        ball.y -= (gap - dis) * cos;\n\n上面代码是修正主动碰的小球的位置，让他退回刚好碰撞的位置，其实就是下图的AB之间的距离，相当于球o1从A退到B.\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\" alt=\"roll\" width=\"270\" height=\"233\" class=\"alignnone size-full wp-image-288\" /></a>\n\n\n\n\nc.  小球斜碰很难分析，我们把他们的速度旋转到x轴方向。\n\n        vx1 = vx * hitcos + vy * hitsin,\n        vy1 = vy * hitcos - vx * hitsin,\n\n上面的vx是原来速度v在x方向的速度，vy是v在y方向的速度。把原来的速度顺时针旋转两球圆心弦的角度，以后则不考虑y方向的运动。x方向上动量守恒和能量守恒，即\n\n        m * vx10 + m * vx20 = m * vx11 + m * vx21;\n        1/2 * m * vx10² + 1/2 * m * vx20² = 1/2 * m * vx11² + 1/2 * m * v21²\n\n联立求解可得碰撞后的速度大小。\n\n然后将速度旋转回去：\n    \n        vx = vx1 * hitcos - vy1 * hitsin;\n        vy = vy1 * hitcos + vx1 * hitsin;\n \n则碰撞后的速度和角度都可以得出：\n\n        ball.v = Math.sqrt(vx * vx + vy * vy) * (1 - 0); // (1-0) 变为大小，标量\n        obj.v = Math.sqrt(objVx * objVx + objVy * objVy) * (1 - 0);\n        ball.angle = Math.atan2(vx, vy);\n        obj.angle = Math.atan2(objVx, objVy);\n\n注意atan2(y, x)计算的是(x,y)到(0,0)的角度，我们这里使用(vx, vy),计算的是(vx, vy)到(0,0)角的余角。\n\n\n\n__考虑外力__\n\n        ball.v = ball.v * (1 - util.LOSS); // 碰撞边缘后减速\n\n故循环跳出条件是 `Math.round(v) <= 0`\n\n        if( Math.round(ball.v <= 0) {\n            ball.v = 0;\n            for(var i = 0; i < movingballs.length; i++) {\n                if(movingballs[i] == ball) {\n                    movingballs.remove(i);\n                }\n            }\n            window.clearInterval(_this.emmiter);\n        }\n         \n\n上式moveingballs.remove(i)移除数组指定位置的元素，是手动添加的：\n\n        Array.prototype.remove = function() { \n            ...\n        }\n\n\n\n\n__预测线__\n\n\n预测线的运动逻辑和小球一样，唯一不同的是，使用while而不是setInterval, 这样预测路线就会比我们的小球提前运动到指定位置。\n\n由于预测路线和小球运动路径相同，且比小球提前到达，那么就能提前知道小球的停止位置，如果判断到小球到达了不能到达的位置，则可以减小他的速度即可。\n\n\n预测路线的小黄点，是通过\n    \n        var elem = document.createElement(\"div\");\n        ....\n        wrap.append(elem);\n\n追加到DOM父节点上的，所以如果一次碰撞小球太多，则会卡死的现象。\n\n<br>\n在cocos2d中是使用在Layer上drawDot()，几乎没有内存消耗，所以不存在卡的现象。\n\n如果要应用到是项目中，建议使用canvas 或者 documentFragment处理。\n\n另外在贪吃鱼游戏中，运动的过程是通过加速度和路程来计算每次增加的位置的，运动效果比刚才的每次增加相同dx,dy的方案要好，如果对运动效果要求较高，可以考虑这种方式。\n\n\n\n## 结语\n\n实际需求中，很多情况下我们不能使用现成的引擎或者框架，必须要去自己造轮子。\n\n像刚才的碰撞处理中完全靠数学和物理知识，可见学好基本理论知识的重要性，就像作为程序员必需的数据结构和算法一样，总有你不知道的哪天就会用上，所以不断学习这些基础的东西，才能在用的时候随机应变。\n\n最后，源码放在github上： <a href=\"https://github.com/freestyle21/CrashBall\" target=\"_blank\">https://github.com/freestyle21/CrashBall</a>\n","mobiledoc":null,"html":"<h1 id=\"\">前言</h1>\n\n<p>不记得哪个黑色星期五，贪吃鱼基本完工的时候，产品突然增加需求，要求金币扔出去后不消失，互相可碰撞，其最终结果还要由服务器控制(没错，至今做的所有游戏都有幕后黑手，=W=).</p>\n\n<p>对于碰撞以前只写过一个球到处碰墙壁的，小球之间的碰撞倒是没有接触，想到他们碰撞过程中的角度变化、速度分配，就不敢往下想了，于是马上想到box2d这个牛逼哄哄的引擎.</p>\n\n<p>但是，使用物理引擎虽然高效、逼真，但所有碰撞都是不可控，包括最终的落点。所以引擎不能解决这次遇到的需求。</p>\n\n<p>不能用引擎，咱自己写也不怕，反正当年物理和高数都学得还不错，嘻嘻、</p>\n\n<p>最后，趁游戏上线后的空闲时间，整理下碰撞的思路，记录成本文。</p>\n\n<p>如果你喜欢先睹为快，可以先去玩玩这个游戏:</p>\n\n<p><a href=\"http://qubaoming.me/demo/CrashBall/index.html\" target=\"_blank\"> view demo >></a></p>\n\n<h1 id=\"\">游戏实现</h1>\n\n<p>本文的核心代码是通过游戏中的逻辑移动过来，为了方便，所以代码组织也和cocos2d的思想类似。</p>\n\n<p>cocos2d中有Scene、director、layer层级之分，在demo中也有对应的init、game、ball，既然用到模块层级，当然首选seajs。</p>\n\n<h4 id=\"\">游戏架构</h4>\n\n<pre><code>    ├ css \n        ├ main.css\n    ├ js\n        ├ jquery   \n        ├ jquery.js\n        ├ seajs\n        ├ seajs.js\n        ├ ball\n        ├ game\n        ├ util\n        └ init\n    └ CrashBall.html\n</code></pre>\n\n<p><code>util</code>模块封装的是一些必要的工具函数</p>\n\n<p><code>ball</code>模块封装小球move和drawPredict的类</p>\n\n<p><code>game</code>模块控制游戏进度，管理小球的运动</p>\n\n<p><code>init</code>模块是游戏入口，调用<code>game.js</code>的初始化和开始接口</p>\n\n<p>游戏难度集中在<code>ball</code>和<code>game</code>模块，所以只分析碰撞过程得碰撞检测和处理。</p>\n\n<h4 id=\"\">复杂的碰撞</h4>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;首先建系很重要。由于我们模拟使用<code>left</code>和<code>top</code>来改变坐标，所以我们以<code>table</code>左上角为坐标原点，垂直向下为x轴正方向，水平向左为y轴正方向。</p>\n\n<p><strong>边缘碰撞处理</strong></p>\n\n<p>边缘碰撞处理较为常规，只需要检测小球坐标和边缘的相对关系即可：</p>\n\n<pre><code>       // 左右墙壁\n       if (ball.x &lt; util.R || ball.x &gt; util.W - util.R) { \n            ball.angle *= -1; \n            ball.angle %= Math.PI; \n            ....\n            if (ball.x &lt; util.R) {\n               ball.x = util.R; \n            }\n            if (ball.x &gt; util.W - util.R) {\n               ball.x = util.W - util.R; \n            }\n        }\n\n        // 上下墙壁\n        if (ball.y &lt; util.R || ball.y &gt; util.H - util.R) { \n            ball.angle = ball.angle &gt; 0 ? Math.PI - ball.angle: -Math.PI - ball.angle;                \n            ball.angle %= Math.PI;\n            ....\n        }  \n</code></pre>\n\n<p>上述代码作用是，检测小球坐标和墙壁大小关系，修改小球运动的角度。</p>\n\n<p>计算角度的源码：</p>\n\n<pre><code>     angle = Math.atan2(toPos[0] - fromPos[0], toPos[1] - fromPos[1]);\n</code></pre>\n\n<p>计算的是点(left, top)和x正方向的角度，即下图的∠DAC.</p>\n\n<p><a href=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/left.png\" alt=\"left\" width=\"264\" height=\"217\" class=\"alignnone size-full wp-image-282\" /></a></p>\n\n<p>左右碰撞处理方案是乘以<code>-1</code>，∠DAC是入角，∠DAB和∠DAC正好差个<code>-1</code>.</p>\n\n<p><a href=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/top.png\" alt=\"top\" width=\"278\" height=\"240\" class=\"alignnone size-medium wp-image-283\" /></a></p>\n\n<p>上下碰撞是分正负处理。如上图中∠EAC和∠EAB互补，如果反向运动，∠EAB和∠CAB的变化应该是反向再选择180°。</p>\n\n<p>最后注意的是，如果小球坐标超过边界坐标，则要它坐标设为边界坐标，不然就会出现靠着边界来回撞的bug，前人留下来的bug找了好久，= = .</p>\n\n<p><strong>小球碰撞处理</strong></p>\n\n<p>a. 碰撞检测是判断他们的距离和2倍半径的关系：</p>\n\n<pre><code>    var dis = Math.sqrt(Math.pow(disX, 2) + Math.pow(disY, 2)); \n    if (dis &lt;= gap) {...}\n</code></pre>\n\n<p>b. 如果速度太大或者重绘频率太小，怎会看到两个小球互相融入的效果，所以处理第一步是还原碰撞初始状态。</p>\n\n<pre><code>    ball.x -= (gap - dis) * sin;\n    ball.y -= (gap - dis) * cos;\n</code></pre>\n\n<p>上面代码是修正主动碰的小球的位置，让他退回刚好碰撞的位置，其实就是下图的AB之间的距离，相当于球o1从A退到B.\n<a href=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\"><img src=\"http://qubaoming.me/wp-content/uploads/2013/11/roll.png\" alt=\"roll\" width=\"270\" height=\"233\" class=\"alignnone size-full wp-image-288\" /></a></p>\n\n<p>c.  小球斜碰很难分析，我们把他们的速度旋转到x轴方向。</p>\n\n<pre><code>    vx1 = vx * hitcos + vy * hitsin,\n    vy1 = vy * hitcos - vx * hitsin,\n</code></pre>\n\n<p>上面的vx是原来速度v在x方向的速度，vy是v在y方向的速度。把原来的速度顺时针旋转两球圆心弦的角度，以后则不考虑y方向的运动。x方向上动量守恒和能量守恒，即</p>\n\n<pre><code>    m * vx10 + m * vx20 = m * vx11 + m * vx21;\n    1/2 * m * vx10² + 1/2 * m * vx20² = 1/2 * m * vx11² + 1/2 * m * v21²\n</code></pre>\n\n<p>联立求解可得碰撞后的速度大小。</p>\n\n<p>然后将速度旋转回去：</p>\n\n<pre><code>    vx = vx1 * hitcos - vy1 * hitsin;\n    vy = vy1 * hitcos + vx1 * hitsin;\n</code></pre>\n\n<p>则碰撞后的速度和角度都可以得出：</p>\n\n<pre><code>    ball.v = Math.sqrt(vx * vx + vy * vy) * (1 - 0); // (1-0) 变为大小，标量\n    obj.v = Math.sqrt(objVx * objVx + objVy * objVy) * (1 - 0);\n    ball.angle = Math.atan2(vx, vy);\n    obj.angle = Math.atan2(objVx, objVy);\n</code></pre>\n\n<p>注意atan2(y, x)计算的是(x,y)到(0,0)的角度，我们这里使用(vx, vy),计算的是(vx, vy)到(0,0)角的余角。</p>\n\n<p><strong>考虑外力</strong></p>\n\n<pre><code>    ball.v = ball.v * (1 - util.LOSS); // 碰撞边缘后减速\n</code></pre>\n\n<p>故循环跳出条件是 <code>Math.round(v) &lt;= 0</code></p>\n\n<pre><code>    if( Math.round(ball.v &lt;= 0) {\n        ball.v = 0;\n        for(var i = 0; i &lt; movingballs.length; i++) {\n            if(movingballs[i] == ball) {\n                movingballs.remove(i);\n            }\n        }\n        window.clearInterval(_this.emmiter);\n    }\n</code></pre>\n\n<p>上式moveingballs.remove(i)移除数组指定位置的元素，是手动添加的：</p>\n\n<pre><code>    Array.prototype.remove = function() { \n        ...\n    }\n</code></pre>\n\n<p><strong>预测线</strong></p>\n\n<p>预测线的运动逻辑和小球一样，唯一不同的是，使用while而不是setInterval, 这样预测路线就会比我们的小球提前运动到指定位置。</p>\n\n<p>由于预测路线和小球运动路径相同，且比小球提前到达，那么就能提前知道小球的停止位置，如果判断到小球到达了不能到达的位置，则可以减小他的速度即可。</p>\n\n<p>预测路线的小黄点，是通过</p>\n\n<pre><code>    var elem = document.createElement(\"div\");\n    ....\n    wrap.append(elem);\n</code></pre>\n\n<p>追加到DOM父节点上的，所以如果一次碰撞小球太多，则会卡死的现象。</p>\n\n<p><br> <br />\n在cocos2d中是使用在Layer上drawDot()，几乎没有内存消耗，所以不存在卡的现象。</p>\n\n<p>如果要应用到是项目中，建议使用canvas 或者 documentFragment处理。</p>\n\n<p>另外在贪吃鱼游戏中，运动的过程是通过加速度和路程来计算每次增加的位置的，运动效果比刚才的每次增加相同dx,dy的方案要好，如果对运动效果要求较高，可以考虑这种方式。</p>\n\n<h2 id=\"\">结语</h2>\n\n<p>实际需求中，很多情况下我们不能使用现成的引擎或者框架，必须要去自己造轮子。</p>\n\n<p>像刚才的碰撞处理中完全靠数学和物理知识，可见学好基本理论知识的重要性，就像作为程序员必需的数据结构和算法一样，总有你不知道的哪天就会用上，所以不断学习这些基础的东西，才能在用的时候随机应变。</p>\n\n<p>最后，源码放在github上： <a href=\"https://github.com/freestyle21/CrashBall\" target=\"_blank\">https://github.com/freestyle21/CrashBall</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-08 00:47:41","created_by":1,"updated_at":"2016-07-19 14:08:00","updated_by":1,"published_at":"2013-07-10 03:44:00","published_by":1},{"id":99,"uuid":"66d36866-439d-43f1-9f38-f3fe3895fe4d","title":"蜕变·WebRebuild 2013 前端年度交流会成都站邀请","slug":"webrebuild-2013-2","markdown":"![](/content/images/2016/07/aaa--1-.jpg)\n\n互联网web前端设计行业通过一段时期的茧封或焰炼，web技术使行业、企业及自身发生质的改变。痛苦的蜕变是成长的契机，在彼此互相冲击、交流、融合的对话下，将以尊重包容互助合作同步发展的心态，对行业蜕变、自我提升的过程分享自己的观点进行探讨。\n\n2013，本届主题为“蜕变”的前端技术年度交流会已是第七届，依然如往年在深圳、广州、上海、北京、成都五地举行，腾讯ecd联合 WebRebuild.ORG、深圳大学文化产业研究院、迅雷CUED主办了第七届前端年度交流会. “蜕变” 成都站，将于11月17日下午一点半在翼起来咖啡馆举行。\n\n### 交流会形式\n\nweb前端设计主题分享、现场来宾主题交流对话探讨。\n\n### 会议进行时间\n\n2013-11-17 (星期日) 13:30-18:00\n\n### 会议地点\n\n武侯区高新区天府大道765号天府软件园A11楼（翼起来创业咖啡馆）\n\n### 邀请参会对象\n\n互联网web前端/设计从业者及相关专业、兴趣的学生。\n\n### 报名渠道\n\nWebRebuild.ORG官方网站，或添加微信公众帐号(webrebuildorg)进行相关操作。\n\n### 交流会背景\n\nWebRebuild.ORG 成立于2007年，由互联网前端业界人员自发起的一个交流会组织，从深圳扩散至全国，旨在推动互联网前端web标准技术在中国的发展，致力于为同行从业者 提供一个分享交流的平台，提升从业者的影响力及技术能力储备，并向发展成为推动中国互联网前端web标准技术的非盈利性组织的目标而努力。\n\n从2007年至今，WebRebuild.ORG得到了W3C中国、Google中国、腾讯、迅雷、网易、欢聚时代、百家筝鸣古筝教育集团等企业组织、同行及会议组委志愿者的大力支持与帮助，已成为中国前端盛大的行业盛会之一。\n\n广州、上海、北京、成都地区更多详细信息及参会报名请访问WebRebuild官方网站查阅：[http://www.webrebuild.org](http://www.webrebuild.org) 或收听WebRebuild微信公众帐号（webrebuildorg）获取最新信息。\n\n\nPS：此次 [WebRebuild 成都站](http://www.webrebuild.org/2013/cd/agenda.html)，[@fs21](http://qubaoming.me) 会做一个分享，欢迎成都的前端朋友~\n\n分享ppt [下载](http://vdisk.weibo.com/s/BJjK1OuvdXeqA)","mobiledoc":null,"html":"<p><img src=\"/content/images/2016/07/aaa--1-.jpg\" alt=\"\" /></p>\n\n<p>互联网web前端设计行业通过一段时期的茧封或焰炼，web技术使行业、企业及自身发生质的改变。痛苦的蜕变是成长的契机，在彼此互相冲击、交流、融合的对话下，将以尊重包容互助合作同步发展的心态，对行业蜕变、自我提升的过程分享自己的观点进行探讨。</p>\n\n<p>2013，本届主题为“蜕变”的前端技术年度交流会已是第七届，依然如往年在深圳、广州、上海、北京、成都五地举行，腾讯ecd联合 WebRebuild.ORG、深圳大学文化产业研究院、迅雷CUED主办了第七届前端年度交流会. “蜕变” 成都站，将于11月17日下午一点半在翼起来咖啡馆举行。</p>\n\n<h3 id=\"\">交流会形式</h3>\n\n<p>web前端设计主题分享、现场来宾主题交流对话探讨。</p>\n\n<h3 id=\"\">会议进行时间</h3>\n\n<p>2013-11-17 (星期日) 13:30-18:00</p>\n\n<h3 id=\"\">会议地点</h3>\n\n<p>武侯区高新区天府大道765号天府软件园A11楼（翼起来创业咖啡馆）</p>\n\n<h3 id=\"\">邀请参会对象</h3>\n\n<p>互联网web前端/设计从业者及相关专业、兴趣的学生。</p>\n\n<h3 id=\"\">报名渠道</h3>\n\n<p>WebRebuild.ORG官方网站，或添加微信公众帐号(webrebuildorg)进行相关操作。</p>\n\n<h3 id=\"\">交流会背景</h3>\n\n<p>WebRebuild.ORG 成立于2007年，由互联网前端业界人员自发起的一个交流会组织，从深圳扩散至全国，旨在推动互联网前端web标准技术在中国的发展，致力于为同行从业者 提供一个分享交流的平台，提升从业者的影响力及技术能力储备，并向发展成为推动中国互联网前端web标准技术的非盈利性组织的目标而努力。</p>\n\n<p>从2007年至今，WebRebuild.ORG得到了W3C中国、Google中国、腾讯、迅雷、网易、欢聚时代、百家筝鸣古筝教育集团等企业组织、同行及会议组委志愿者的大力支持与帮助，已成为中国前端盛大的行业盛会之一。</p>\n\n<p>广州、上海、北京、成都地区更多详细信息及参会报名请访问WebRebuild官方网站查阅：<a href=\"http://www.webrebuild.org\">http://www.webrebuild.org</a> 或收听WebRebuild微信公众帐号（webrebuildorg）获取最新信息。</p>\n\n<p>PS：此次 <a href=\"http://www.webrebuild.org/2013/cd/agenda.html\">WebRebuild 成都站</a>，<a href=\"http://qubaoming.me\">@fs21</a> 会做一个分享，欢迎成都的前端朋友~</p>\n\n<p>分享ppt <a href=\"http://vdisk.weibo.com/s/BJjK1OuvdXeqA\">下载</a></p>","image":"/content/images/2016/07/aaa--1--1.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 06:59:47","created_by":1,"updated_at":"2016-07-19 14:26:14","updated_by":1,"published_at":"2013-11-01 06:59:00","published_by":1},{"id":100,"uuid":"a425623a-d8e4-4502-8056-b7ed5de080df","title":"cocos2d-html5 中的性能优化","slug":"cocos2d-html5-performance-optimization-2","markdown":"游戏开发中，难免会遇到性能瓶颈。图片一多，渲染批次就会直线上升，任何动画都会变得闪动。\n\nOpenGL ES优化的问题，主要考虑两个方面：**内存存储**和**运行速度**。\n\n2D游戏中的最占内存的就是图片资源，一张图片使用的纹理格式不同，就可能带来极大的性能差异。图片数量的控制好坏，对一个游戏的流程与否有最直接的关系。在前端开发中，常见的减少HTTP请求的方式有css Sprite 来处理图片数量的问题，在cocos2d中也有类似的处理方式。（这里打个广告，操哥的[grunt-sprite](https://npmjs.org/package/grunt-sprite)）.\n\n关于内存，cocos2d中采用预加载的方式来处理。把所有同类图片打包成plist文件，然后通过帧缓存的方式读取。打包软件推荐 [TexturePacker](http://www.codeandweb.com/texturepacker).这里注意打包后的的图片空隙不要太多，Size constraints设置为Any size，改变layout Algorithm找到最合适图片。如下图：\n\n![](/content/images/2016/07/QQ---a---20131024093817-300x229.png)\n\n\npublish后会得到plist文件和png文件。其中plist文件记录了打包前的图片的名字和在生成png文件中的位置。在项目的入口文件中引入刚才的plist文件，就可以在任何Layer和Sprite里面提取这些预加载过的图片了。举个栗子：\n    \n\n    cc.MenuItemImage.createWithFrames(\"setA.png\", \"setB.png\",null,this.click_set, this);\n\n    cc.Sprite.createWithSpriteFrameName('deskBg.png');\n\n关于运行速度，纹理渲染每一次都会调用GLDrawArray，要是上千图片，结果不难想象。要降低渲染批次，我们使用SpriteBatchNode的方式。\n   \n\nSpriteBatchNode的作用管理Sprite。我们知道，每当屏幕渲染一个纹理的时候，需要三个过程：准备渲染、渲染图形、清除渲染。如果每一次都重复这三个过程，这些固定开销就会降低我们的渲染效率。SpriteBatchNode的作用就是把很多次这样的过程变成一次。\n\n\n例如最近的一次项目。需要把旋转指针、旋转云图、内环背景等添加到一个Layer中。这是可以考虑先给Layer创建SpriteBatchNode，然后把上面的物体放到刚创建的SpriteBatchNode中。\n\n\n\n    this.spriteBatch = cc.SpriteBatchNode.create(\"res/pan.png\");\n    this.pan.addChild(this.spriteBatch ,200);\n\n    // 转盘 内环\n    var ring = cc.Sprite.createWithSpriteFrameName(Pan_Arr.l1.ring);\n    this.spriteBatch.addChild(ring);\n\n\n\n使用了后，对应的渲染批次就会降低N-1次。N是SpriteBatchNode管理的Sprite的数量。\n\n\n\n关于SpriteBatchNode有两点注意：\n\n*   使用贴图必须是同一张图片，例如可以使用TexturePacker打包publish出来的图片。\n*   所有被管理的Sprite必须在同一渲染层。也就是说呗AddChild的时候的zOrder必须是一样的。\n\n\n\n以上就是最近研究的cocos2d-html5性能优化实践，主要就是FrameCache和SpriteBatchNode两种预加载。\n\n\n\n  \n   ","mobiledoc":null,"html":"<p>游戏开发中，难免会遇到性能瓶颈。图片一多，渲染批次就会直线上升，任何动画都会变得闪动。</p>\n\n<p>OpenGL ES优化的问题，主要考虑两个方面：<strong>内存存储</strong>和<strong>运行速度</strong>。</p>\n\n<p>2D游戏中的最占内存的就是图片资源，一张图片使用的纹理格式不同，就可能带来极大的性能差异。图片数量的控制好坏，对一个游戏的流程与否有最直接的关系。在前端开发中，常见的减少HTTP请求的方式有css Sprite 来处理图片数量的问题，在cocos2d中也有类似的处理方式。（这里打个广告，操哥的<a href=\"https://npmjs.org/package/grunt-sprite\">grunt-sprite</a>）.</p>\n\n<p>关于内存，cocos2d中采用预加载的方式来处理。把所有同类图片打包成plist文件，然后通过帧缓存的方式读取。打包软件推荐 <a href=\"http://www.codeandweb.com/texturepacker\">TexturePacker</a>.这里注意打包后的的图片空隙不要太多，Size constraints设置为Any size，改变layout Algorithm找到最合适图片。如下图：</p>\n\n<p><img src=\"/content/images/2016/07/QQ---a---20131024093817-300x229.png\" alt=\"\" /></p>\n\n<p>publish后会得到plist文件和png文件。其中plist文件记录了打包前的图片的名字和在生成png文件中的位置。在项目的入口文件中引入刚才的plist文件，就可以在任何Layer和Sprite里面提取这些预加载过的图片了。举个栗子：</p>\n\n<pre><code>cc.MenuItemImage.createWithFrames(\"setA.png\", \"setB.png\",null,this.click_set, this);\n\ncc.Sprite.createWithSpriteFrameName('deskBg.png');\n</code></pre>\n\n<p>关于运行速度，纹理渲染每一次都会调用GLDrawArray，要是上千图片，结果不难想象。要降低渲染批次，我们使用SpriteBatchNode的方式。</p>\n\n<p>SpriteBatchNode的作用管理Sprite。我们知道，每当屏幕渲染一个纹理的时候，需要三个过程：准备渲染、渲染图形、清除渲染。如果每一次都重复这三个过程，这些固定开销就会降低我们的渲染效率。SpriteBatchNode的作用就是把很多次这样的过程变成一次。</p>\n\n<p>例如最近的一次项目。需要把旋转指针、旋转云图、内环背景等添加到一个Layer中。这是可以考虑先给Layer创建SpriteBatchNode，然后把上面的物体放到刚创建的SpriteBatchNode中。</p>\n\n<pre><code>this.spriteBatch = cc.SpriteBatchNode.create(\"res/pan.png\");\nthis.pan.addChild(this.spriteBatch ,200);\n\n// 转盘 内环\nvar ring = cc.Sprite.createWithSpriteFrameName(Pan_Arr.l1.ring);\nthis.spriteBatch.addChild(ring);\n</code></pre>\n\n<p>使用了后，对应的渲染批次就会降低N-1次。N是SpriteBatchNode管理的Sprite的数量。</p>\n\n<p>关于SpriteBatchNode有两点注意：</p>\n\n<ul>\n<li>使用贴图必须是同一张图片，例如可以使用TexturePacker打包publish出来的图片。</li>\n<li>所有被管理的Sprite必须在同一渲染层。也就是说呗AddChild的时候的zOrder必须是一样的。</li>\n</ul>\n\n<p>以上就是最近研究的cocos2d-html5性能优化实践，主要就是FrameCache和SpriteBatchNode两种预加载。</p>","image":"/content/images/2016/07/2051584439.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:05:59","created_by":1,"updated_at":"2016-07-19 14:07:18","updated_by":1,"published_at":"2013-10-24 07:05:00","published_by":1},{"id":101,"uuid":"f9e178b0-3b96-4261-bf98-f92f1b1a9f28","title":"细说移动前端Android联调","slug":"mobile-debug-2","markdown":"#### 为什么要联调\nA：正在疯狂coding的时候，产品MM过来，焦急的说两周前的一个页面在手机上显示略微错位，但小本上显示正常！\n\nB：本着爱折腾的原则，作为大前端，在移动互联网时代的基本技能。\n#### 联调的方式：\n1：ADB Chrome extension\n\n2：Opera Mobile\n\n3：weinre\n\n4: [Adobe Egde Inspect CC](http://html.adobe.com/edge/inspect/)\n\n\n#### 方式一：ADB Chrome extension：具体参考：[这里](https://developers.google.com/chrome-developer-tools/docs/remote-debugging?hl=zh-CN&csw=1)\n\n步骤一：[ADB extension](https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage)\n\n步骤二：安装手机驱动\n\n步骤三：手机chrome 开发者工具->启动USB网页调试\n\n步骤四：ADB->View Inspection Targets\n\n细节：手机驱动如果不好找就装个91或者豌豆荚吧\n\n优缺点：配置简单，可快速开始。但ADB会闹脾气，时快时慢\t\n\n优化：解决慢可以尝试用android的sdk本地搞个服务器。\n\n基本配置->下载[ADT](http://developer.android.com/sdk/index.html)->CMD(adb forward tcp:8888 localadstract:chrome_devtools_remote)->localhost:8888\n\n#### 方式二：Opera Mobile\n\n步骤一：下载Opera桌面版(低版本)\n       下载Opera 模拟器\n\n步骤二：打开桌面版的Dragonfly 点击右上角的远程调试设置端口\n\n步骤三：在模拟器中输入 opera:debug 设置端口连接。\n\n细节：Opera桌面版高版本的调试器居然不是dragongly，下低版本(10.52)。\n\n优缺点：简单方便，支持模拟各种机型的显示效果。但是不能选择元素方式不友好。\n\n#### 方式三：weinre(web in remote)\n步骤一：安装Node.js. => 安装weinre(npm install -g weinre)\n\n步骤二：启动服务器 weinre --httpPort 8080 --boundHost -all-\n\n步骤三：在目标调试文件中加入： \n\n     <script src=\"http://本机ip:8080/target/target-script-min.js#anonymous\"></script>\n\n步骤四：[localhost:8080/client](localhost:8080/client) 即可调试\n\n细节：引入的script标签中必须有#anonymous,否则看不到可调试文件。\n\n优缺点：高端上流，操作简单，可用浏览器自带的调试器调试，适合爱好不同开发者。\n\n缺点是，方便前端开发。\n\n优化：每次都手动引入js很不爽，效率极低。做成书签形式，每次在当前页面引入js。\n\n    javascript:(function(e){\n        e.setAttribute(\"src\",\"http://192.168.1.5:8080/target/target-script-min.js#anonymous\");\n        document.getElementsByTagName(\"body\")[0].appendChild(e);\n        alert('has executed!');\n    })(document.createElement(\"script\"));\n    void(0);\n\n#### 结语：\n移动端调试虽好玩，但是太折腾，保证效率，只能作为最后法宝\n\n遇到问题：Bug现象->本地调试->定位bug->确定是否联调\n\n\t\n","mobiledoc":null,"html":"<h4 id=\"\">为什么要联调</h4>\n\n<p>A：正在疯狂coding的时候，产品MM过来，焦急的说两周前的一个页面在手机上显示略微错位，但小本上显示正常！</p>\n\n<p>B：本着爱折腾的原则，作为大前端，在移动互联网时代的基本技能。  </p>\n\n<h4 id=\"\">联调的方式：</h4>\n\n<p>1：ADB Chrome extension</p>\n\n<p>2：Opera Mobile</p>\n\n<p>3：weinre</p>\n\n<p>4: <a href=\"http://html.adobe.com/edge/inspect/\">Adobe Egde Inspect CC</a></p>\n\n<h4 id=\"adbchromeextensionhttpsdevelopersgooglecomchromedevelopertoolsdocsremotedebugginghlzhcncsw1\">方式一：ADB Chrome extension：具体参考：<a href=\"https://developers.google.com/chrome-developer-tools/docs/remote-debugging?hl=zh-CN&amp;csw=1\">这里</a></h4>\n\n<p>步骤一：<a href=\"https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage\">ADB extension</a></p>\n\n<p>步骤二：安装手机驱动</p>\n\n<p>步骤三：手机chrome 开发者工具->启动USB网页调试</p>\n\n<p>步骤四：ADB->View Inspection Targets</p>\n\n<p>细节：手机驱动如果不好找就装个91或者豌豆荚吧</p>\n\n<p>优缺点：配置简单，可快速开始。但ADB会闹脾气，时快时慢    </p>\n\n<p>优化：解决慢可以尝试用android的sdk本地搞个服务器。</p>\n\n<p>基本配置->下载<a href=\"http://developer.android.com/sdk/index.html\">ADT</a>->CMD(adb forward tcp:8888 localadstract:chrome<em>devtools</em>remote)->localhost:8888</p>\n\n<h4 id=\"operamobile\">方式二：Opera Mobile</h4>\n\n<p>步骤一：下载Opera桌面版(低版本)\n       下载Opera 模拟器</p>\n\n<p>步骤二：打开桌面版的Dragonfly 点击右上角的远程调试设置端口</p>\n\n<p>步骤三：在模拟器中输入 opera:debug 设置端口连接。</p>\n\n<p>细节：Opera桌面版高版本的调试器居然不是dragongly，下低版本(10.52)。</p>\n\n<p>优缺点：简单方便，支持模拟各种机型的显示效果。但是不能选择元素方式不友好。</p>\n\n<h4 id=\"weinrewebinremote\">方式三：weinre(web in remote)</h4>\n\n<p>步骤一：安装Node.js. => 安装weinre(npm install -g weinre)</p>\n\n<p>步骤二：启动服务器 weinre --httpPort 8080 --boundHost -all-</p>\n\n<p>步骤三：在目标调试文件中加入： </p>\n\n<pre><code> &lt;script src=\"http://本机ip:8080/target/target-script-min.js#anonymous\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>步骤四：<a href=\"localhost:8080/client\">localhost:8080/client</a> 即可调试</p>\n\n<p>细节：引入的script标签中必须有#anonymous,否则看不到可调试文件。</p>\n\n<p>优缺点：高端上流，操作简单，可用浏览器自带的调试器调试，适合爱好不同开发者。</p>\n\n<p>缺点是，方便前端开发。</p>\n\n<p>优化：每次都手动引入js很不爽，效率极低。做成书签形式，每次在当前页面引入js。</p>\n\n<pre><code>javascript:(function(e){\n    e.setAttribute(\"src\",\"http://192.168.1.5:8080/target/target-script-min.js#anonymous\");\n    document.getElementsByTagName(\"body\")[0].appendChild(e);\n    alert('has executed!');\n})(document.createElement(\"script\"));\nvoid(0);\n</code></pre>\n\n<h4 id=\"\">结语：</h4>\n\n<p>移动端调试虽好玩，但是太折腾，保证效率，只能作为最后法宝</p>\n\n<p>遇到问题：Bug现象->本地调试->定位bug->确定是否联调</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:13:03","created_by":1,"updated_at":"2016-07-19 14:07:44","updated_by":1,"published_at":"2013-09-08 07:13:00","published_by":1},{"id":102,"uuid":"b722e4ac-fa7e-4237-84fe-d1cb9d2f4b48","title":"grunt-2x2x","slug":"grunt-2x2x-2","markdown":"> a grunt plugin to resize and rename @2x.png(jpg,gif,) image to .png(jpg,gif)\n\n场景：移动前端开发中，设计给的psd都是双倍图，适用于高清屏。对于低端手机，需要用@x的图片。平时工作中，用「App设计助理」+「Photoshop切图脚本工具PNG@2x Export」可以秒出@2x图层的@2x图片，之后再用grunt-2x2x便可将@2x转到@x，实现流程自动化。\n\n详见： [https://npmjs.org/package/grunt-2x2x](https://npmjs.org/package/grunt-2x2x)","mobiledoc":null,"html":"<blockquote>\n  <p>a grunt plugin to resize and rename @2x.png(jpg,gif,) image to .png(jpg,gif)</p>\n</blockquote>\n\n<p>场景：移动前端开发中，设计给的psd都是双倍图，适用于高清屏。对于低端手机，需要用@x的图片。平时工作中，用「App设计助理」+「Photoshop切图脚本工具PNG@2x Export」可以秒出@2x图层的@2x图片，之后再用grunt-2x2x便可将@2x转到@x，实现流程自动化。</p>\n\n<p>详见： <a href=\"https://npmjs.org/package/grunt-2x2x\">https://npmjs.org/package/grunt-2x2x</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:23:48","created_by":1,"updated_at":"2016-07-19 14:08:48","updated_by":1,"published_at":"2013-06-17 07:23:00","published_by":1},{"id":103,"uuid":"3602e45e-2a7e-4128-b83a-b26a3dda32a3","title":"居中","slug":"css-align-center-2","markdown":"说到居中，好像每个前端人都能随口说出几个，像耳熟能详的`margin:0 auto`、`line-heght`之类的。但是，当天天面对各式各样的设计稿时，或许你知道的那几个法宝也不能应对了。\n\n本文就日常重构中遇到的一些情景给出对应的解决方案，并对每种解决方案的优缺点进行简要概括。\n\n* * *\n\n## 垂直居中\n\n### -webkit-box- 居中\n\n      <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\theight: 300px;\n\t\t\twidth: 300px;\n\t\t\tdisplay: -webkit-box;\n\t\t\t-webkit-box-align: center; // 水平居中\n\t\t\t-webkit-box-pack: center; // 垂直居中\n\t\t\t-webkit-box-orient: vertical;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t    <span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t</div>\n\n评价：适用于多行文本，缺点是只有-webkit内核浏览器支持，移动端可以多使用。\n\n### height | line-height 等值居中\n\n    <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\theight: 90px;\n\t\t\tline-height: 90px;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t\t<span>我是文本我居中</span>\n\t</div>    \n\n评价：使用于单行文本(图片也可以)，缺点是要求父元素高度已知。\n\n### padding 居中\n\n    <style>\n\t\t.wraper {\n\t\t\tbackground: #DBE6BA;\n\t\t\tpadding: 25px;\n\t\t\twidth: 560px;\n\t\t}\n\t</style>\n\t<div class=\"wraper\">\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t\t我是文本我居中\n\t</div>    \n\n评价：只是看起来居中，其实是用padding撑满父元素而已，=。=。\n\n### table-cell 居中\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tdisplay: table-cell;\n\t\t\tvertical-align: middle;\n\t\t}\n\t\t.wraper {\n\t\t\tdisplay: table;\n\t\t\theight: 80px;\n\t\t\tbackground: #DBE6FD;\n\t\t}\n\t</style> \n\t<div class=\"wraper\">\n\t\t<div class=\"inner\">\n\t\t\t我是文本我居中\n\t\t\t我是文本我居中\n\t\t</div>\n\t</div>    \n\n评价：等于移动端用的较多，很适用。不过要注意的是他可能会破坏布局，要用display破坏原来的block属性。\n\n### absolute 居中\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tposition: absolute;\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tmargin: auto;\n\t\t\twidth: 300px;\n\t\t\theight: 100px;\n\t\t}\n\t\t.wraper {\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t</style> \n\t<div class=\"wraper\">\n\t\t<div class=\"inner\">\n\t\t\t我是文本我居中\n\t\t\t我是文本我居中\n\t\t</div>\n\t</div>    \n\n评价：要求父元素高度宽度都固定。\n\n    <style type=\"text/css\"> \n\t\t.inner {\n\t\t\tposition: absolute;\n\t\t\theight: 100px;\n\t\t\ttop: 50%;\n\t\t\tmargin-top: -50px: \n\t\t}\n\t\t.wraper {\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t</style> \n\n\t<div class=\"wraper\">\n\t    <div class=\"inner\">\n\t        \t我是文本我居中\n\t\t        我是文本我居中\n\t    </div>\n\t</div>    \n\n评价：要求需要居中的元素高度已知。\n\n### 对于span，img等行内元素，使用vertical-align: middle。\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\theight: 100px;\n\t\t}\n\t\timg {\n\t\t\tvertical-align: middle;\n\t\t}\n\t</style>\n\t<p>\n\t\t<img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\">\n\t\t我是图片后的文字，我要居中\n\t</p>\n\n### 图片和文本要图片居中，可以使用`<img src=\"\" align=\"absmiddle\" />`\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n\t<p>\n\t\t<img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\">\n\t\t我是图片后的文字，我要居中\n\t</p> \n\n* * *\n\n## 水平居中\n\n### text-align 居中\n\n    <style>\n\t\tp {\n\t\t\tbackground: #DBE6FD;\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n\t<p>\n\t\t<span>我要水平居中！</span>\n\t</p>    \n\n评价： 限于文本和图片等内联元素。\n\n### `margin: 0 auto;` 居中\n\n    <style>\n\t\t.outer {\n\t\t\tbackground: #DBE6FD;\n\t\t}\n\t\t.inner {\n\t\t\tbackground: #F3F3F3;\n\t\t\twidth: 80%;\n\t\t\tmargin: 0 auto;\n\t\t}\n\t</style>\n\t<div class=\"outer\">\n\t\t<div class=\"inner\">\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t</div>\n\t</div>    \n\n评价：只对于块级元素有效。\n\n### `absolute`\n\n    <style>\n\t\t.outer {\n\t\t\tbackground: #DBE6FD;\n\t\t\tposition: relative;\n\t\t}\n\t\t.inner {\n\t\t\tbackground: #F3F3F3;\n\t\t\tposition: relative;\n\t\t\tleft: 50%;\n\t\t\twidth: 400px;\n\t\t\tmargin-left: -200px;\n\t\t}\n\t</style>\n\t<div class=\"outer\">\n\t\t<div class=\"inner\">\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t\t<p>我是内容我居中</p>\n\t\t</div>\n\t</div>  \n\n评价：只对宽度已知的元素有效。\n### 总结：以上每种方法都有自己的优点和缺点，对于特定场景，选用适合此场景的方法即可。\n## 补充\n\nbox-flex：布局的垂直等高、水平均分、按比例划分。\n\n    <style>\n\t\t.wraper {\n\t\t\tdisplay: box;\n\t\t}\n\t\t.sectionOne {\n\t\t\tbox-flex: 3;\n\t\t}\n\t\t.sectionTwo {\n\t\t\tbox-flex: 2;\n\t\t}\n\t\t.sectionThree {\n\t\t\tbox-flex: 1;\n\t\t}\n\t</style>\n\t<article class=\"wrap\">\n\t\t<section class=\"sectionOne\">01</section>\n\t\t<section class=\"sectionTwo\">02</section>\n\t\t<section class=\"sectionThree\">03</section>\n\t</article>\n\t    \n#### 说明：\n\n1.    父元素必须为display:box（此时容器定义为内联元素，使用margin：0 auto无效，要在父元素上使用text-aglin:center.）\n\n2.    如果其中一个子元素设置了固定宽度，该子元素直接应用设置的宽度，其他的在按比例平分剩下的。\n\n    \n\n#### box属性：\n\nbox-orient box-direction(排列顺序，reverse|normal)\n\nbox-align（父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch）\n\nbox-pack(子容器的水平对齐方式 start | end | center | justify)","mobiledoc":null,"html":"<p>说到居中，好像每个前端人都能随口说出几个，像耳熟能详的<code>margin:0 auto</code>、<code>line-heght</code>之类的。但是，当天天面对各式各样的设计稿时，或许你知道的那几个法宝也不能应对了。</p>\n\n<p>本文就日常重构中遇到的一些情景给出对应的解决方案，并对每种解决方案的优缺点进行简要概括。</p>\n\n<hr />\n\n<h2 id=\"\">垂直居中</h2>\n\n<h3 id=\"webkitbox\">-webkit-box- 居中</h3>\n\n<pre><code>  &lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        height: 300px;\n        width: 300px;\n        display: -webkit-box;\n        -webkit-box-align: center; // 水平居中\n        -webkit-box-pack: center; // 垂直居中\n        -webkit-box-orient: vertical;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>评价：适用于多行文本，缺点是只有-webkit内核浏览器支持，移动端可以多使用。</p>\n\n<h3 id=\"heightlineheight\">height | line-height 等值居中</h3>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        height: 90px;\n        line-height: 90px;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n    &lt;span&gt;我是文本我居中&lt;/span&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：使用于单行文本(图片也可以)，缺点是要求父元素高度已知。</p>\n\n<h3 id=\"padding\">padding 居中</h3>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        background: #DBE6BA;\n        padding: 25px;\n        width: 560px;\n    }\n&lt;/style&gt;\n&lt;div class=\"wraper\"&gt;\n    我是文本我居中\n    我是文本我居中\n    我是文本我居中\n    我是文本我居中\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：只是看起来居中，其实是用padding撑满父元素而已，=。=。</p>\n\n<h3 id=\"tablecell\">table-cell 居中</h3>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .wraper {\n        display: table;\n        height: 80px;\n        background: #DBE6FD;\n    }\n&lt;/style&gt; \n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n        我是文本我居中\n        我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：等于移动端用的较多，很适用。不过要注意的是他可能会破坏布局，要用display破坏原来的block属性。</p>\n\n<h3 id=\"absolute\">absolute 居中</h3>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        position: absolute;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        margin: auto;\n        width: 300px;\n        height: 100px;\n    }\n    .wraper {\n        width: 400px;\n        height: 400px;\n        background: #DBE6FD;\n        position: relative;\n    }\n&lt;/style&gt; \n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n        我是文本我居中\n        我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：要求父元素高度宽度都固定。</p>\n\n<pre><code>&lt;style type=\"text/css\"&gt; \n    .inner {\n        position: absolute;\n        height: 100px;\n        top: 50%;\n        margin-top: -50px: \n    }\n    .wraper {\n        width: 400px;\n        height: 400px;\n        background: #DBE6FD;\n        position: relative;\n    }\n&lt;/style&gt; \n\n&lt;div class=\"wraper\"&gt;\n    &lt;div class=\"inner\"&gt;\n            我是文本我居中\n            我是文本我居中\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：要求需要居中的元素高度已知。</p>\n\n<h3 id=\"spanimgverticalalignmiddle\">对于span，img等行内元素，使用vertical-align: middle。</h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        height: 100px;\n    }\n    img {\n        vertical-align: middle;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\"&gt;\n    我是图片后的文字，我要居中\n&lt;/p&gt;\n</code></pre>\n\n<h3 id=\"imgsrcalignabsmiddle\">图片和文本要图片居中，可以使用<code>&lt;img src=\"\" align=\"absmiddle\" /&gt;</code></h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        text-align: center;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;img align=\"absmiddle\" src=\"qq.png\" alt=\"qq\"&gt;\n    我是图片后的文字，我要居中\n&lt;/p&gt; \n</code></pre>\n\n<hr />\n\n<h2 id=\"\">水平居中</h2>\n\n<h3 id=\"textalign\">text-align 居中</h3>\n\n<pre><code>&lt;style&gt;\n    p {\n        background: #DBE6FD;\n        text-align: center;\n    }\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;span&gt;我要水平居中！&lt;/span&gt;\n&lt;/p&gt;    \n</code></pre>\n\n<p>评价： 限于文本和图片等内联元素。</p>\n\n<h3 id=\"margin0auto\"><code>margin: 0 auto;</code> 居中</h3>\n\n<pre><code>&lt;style&gt;\n    .outer {\n        background: #DBE6FD;\n    }\n    .inner {\n        background: #F3F3F3;\n        width: 80%;\n        margin: 0 auto;\n    }\n&lt;/style&gt;\n&lt;div class=\"outer\"&gt;\n    &lt;div class=\"inner\"&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre>\n\n<p>评价：只对于块级元素有效。</p>\n\n<h3 id=\"absolute\"><code>absolute</code></h3>\n\n<pre><code>&lt;style&gt;\n    .outer {\n        background: #DBE6FD;\n        position: relative;\n    }\n    .inner {\n        background: #F3F3F3;\n        position: relative;\n        left: 50%;\n        width: 400px;\n        margin-left: -200px;\n    }\n&lt;/style&gt;\n&lt;div class=\"outer\"&gt;\n    &lt;div class=\"inner\"&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n        &lt;p&gt;我是内容我居中&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;  \n</code></pre>\n\n<p>评价：只对宽度已知的元素有效。</p>\n\n<h3 id=\"\">总结：以上每种方法都有自己的优点和缺点，对于特定场景，选用适合此场景的方法即可。</h3>\n\n<h2 id=\"\">补充</h2>\n\n<p>box-flex：布局的垂直等高、水平均分、按比例划分。</p>\n\n<pre><code>&lt;style&gt;\n    .wraper {\n        display: box;\n    }\n    .sectionOne {\n        box-flex: 3;\n    }\n    .sectionTwo {\n        box-flex: 2;\n    }\n    .sectionThree {\n        box-flex: 1;\n    }\n&lt;/style&gt;\n&lt;article class=\"wrap\"&gt;\n    &lt;section class=\"sectionOne\"&gt;01&lt;/section&gt;\n    &lt;section class=\"sectionTwo\"&gt;02&lt;/section&gt;\n    &lt;section class=\"sectionThree\"&gt;03&lt;/section&gt;\n&lt;/article&gt;\n</code></pre>\n\n<h4 id=\"\">说明：</h4>\n\n<ol>\n<li><p>   父元素必须为display:box（此时容器定义为内联元素，使用margin：0 auto无效，要在父元素上使用text-aglin:center.）</p></li>\n<li><p>   如果其中一个子元素设置了固定宽度，该子元素直接应用设置的宽度，其他的在按比例平分剩下的。</p></li>\n</ol>\n\n<h4 id=\"box\">box属性：</h4>\n\n<p>box-orient box-direction(排列顺序，reverse|normal)</p>\n\n<p>box-align（父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch）</p>\n\n<p>box-pack(子容器的水平对齐方式 start | end | center | justify)</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 07:38:39","created_by":1,"updated_at":"2016-07-19 14:09:07","updated_by":1,"published_at":"2013-06-08 07:38:00","published_by":1},{"id":104,"uuid":"7ed10fcd-73ce-4086-84b3-828d449118d2","title":"实习之始","slug":"shi-xi-zhi-shi-2","markdown":"今天终于有时间安静下来，看看书，听听音乐，写写文字。\n\n来深圳三天了，还是没有放下对一个陌生城市的防备。曾经想着来这个世界，就是为了改变它，但游离在这座城市的高楼大厦间，突然觉得自己是多么的渺小，无助。入职培训的两天里，都没有很人有较多接触，独来独往。外面看来是高贵冷艳，其实是害怕、没准备。有时候都在思考，自己到底是属于静如处子还是动如狡兔，或者一半一半。\n\n深圳给人的印象太深了。首先是喜怒无常的天气，有时候可以是左边阳光灿烂，右边却乌云密布，有时早上红火太阳，下午就滚滚雷声。另外还有，本地人说话很好听。每次在地铁里都很认真的听广播，无聊的时候还故意找别人说话，其实是为了听听广东话。有时候都在想要好好学两句，回去好骗骗小马和颖姐。其他的还有吃饭贵、交通好，高楼多、腿好看（*@ο@*）……\n\n腾讯确实给力，做什么都有大公司的霸气。实习生直接住三星级酒店，短短15天，但住了真心不想走。工作的环境跟想象中一样，气氛很好，椅子很舒服，两个大屏幕超给力，这里的人初次接触就很nice。入职培训的时候，跳跳虎从最后逆袭到了10颗星，最感动地是鲜姐居然记住了我的生日，专门去买了礼物，当时真的有点受宠若惊。不知道是不是腾讯的传统。\n\n写着写着，又想远了。本来的满肚子的话，不知接下来如何开始。\n\n计划的，每天锻炼呢？来了深圳就没有锻炼过。反思，以后每天至少做点俯卧撑，没事去公司的健身房走走！\n\n最近一直在听周围的人说租房难，所以不敢马虎。早上在豆瓣和58上泡了一上午，下午去看了房，没有什么不满意的，就交了押金。懒得讲价和到处找。后面没有麻烦了，全身心投入工作吧。虽然干的可能是给峰哥猫哥搓背倒水的体力活，但也要以不为自己打工的精神干好，从小事做起。另外保证效率，必须获得认可。明天陪恺睿和高富帅去high一天，后天开始fight吧！","mobiledoc":null,"html":"<p>今天终于有时间安静下来，看看书，听听音乐，写写文字。</p>\n\n<p>来深圳三天了，还是没有放下对一个陌生城市的防备。曾经想着来这个世界，就是为了改变它，但游离在这座城市的高楼大厦间，突然觉得自己是多么的渺小，无助。入职培训的两天里，都没有很人有较多接触，独来独往。外面看来是高贵冷艳，其实是害怕、没准备。有时候都在思考，自己到底是属于静如处子还是动如狡兔，或者一半一半。</p>\n\n<p>深圳给人的印象太深了。首先是喜怒无常的天气，有时候可以是左边阳光灿烂，右边却乌云密布，有时早上红火太阳，下午就滚滚雷声。另外还有，本地人说话很好听。每次在地铁里都很认真的听广播，无聊的时候还故意找别人说话，其实是为了听听广东话。有时候都在想要好好学两句，回去好骗骗小马和颖姐。其他的还有吃饭贵、交通好，高楼多、腿好看（<em>@ο@</em>）……</p>\n\n<p>腾讯确实给力，做什么都有大公司的霸气。实习生直接住三星级酒店，短短15天，但住了真心不想走。工作的环境跟想象中一样，气氛很好，椅子很舒服，两个大屏幕超给力，这里的人初次接触就很nice。入职培训的时候，跳跳虎从最后逆袭到了10颗星，最感动地是鲜姐居然记住了我的生日，专门去买了礼物，当时真的有点受宠若惊。不知道是不是腾讯的传统。</p>\n\n<p>写着写着，又想远了。本来的满肚子的话，不知接下来如何开始。</p>\n\n<p>计划的，每天锻炼呢？来了深圳就没有锻炼过。反思，以后每天至少做点俯卧撑，没事去公司的健身房走走！</p>\n\n<p>最近一直在听周围的人说租房难，所以不敢马虎。早上在豆瓣和58上泡了一上午，下午去看了房，没有什么不满意的，就交了押金。懒得讲价和到处找。后面没有麻烦了，全身心投入工作吧。虽然干的可能是给峰哥猫哥搓背倒水的体力活，但也要以不为自己打工的精神干好，从小事做起。另外保证效率，必须获得认可。明天陪恺睿和高富帅去high一天，后天开始fight吧！</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:02:26","created_by":1,"updated_at":"2016-07-19 14:27:19","updated_by":1,"published_at":"2013-06-20 08:02:00","published_by":1},{"id":105,"uuid":"50fdebd1-8b6c-4cb2-9f9e-a4dfe94f38e3","title":"Canvas动画","slug":"canvas-animation-2","markdown":"## 引题\n\n最近忙完实验，在慢慢开始的学习HTML5 的canvas，很早就听过动态canvas的威名，一直没有机会和时间学习。这次系统学习HTML5和css3，自然不会放过这次机会。\n\n本文主要是总结学习canvas动画的一些基本知识，并不会介绍canvas，关于入门读者朋友可以回去翻翻书本。另外本文还会试着写几个实例，加深理解。\n\n## canvas动画基本思想\n\n### 思想一 刷新重绘\n\n我们平时看到的canvas游戏里，人物运动、物体变化都是基于这个思想。比如绘制动画的圆，我们通过鼠标触动或者重力等外界因素改变圆的圆心坐标。下一步，通过：\n\n    context.clearRect(0, 0, canvas.width, canvas.height)\n\n把当前canvas的画面清空。然后，再通过：\n    \n    context.art(circle.x, circle.y, circle.radius, 0, Math.PI*2) \n\n利用新的圆心坐标绘制新的圆。\n\n刷新重绘的思想是canvas游戏的核心，任何需要移动的物体都是通过这种方式。\n\n不过在即时战略游戏中，很多东西不需要更新，需要的只是人物，这样我们全部清楚再重绘就有点得不偿失。这里就需要用到一种区域适配更新的技术，是John Carmack发明的，叫做ATR技术。有兴趣的朋友可以去google一下。\n\n### 思想二 碰撞检测\n\n碰撞检测用的比较比较频繁。比如和canvas上的圆交互的时候，需要检测点击的是哪个圆，只需循环判断触点坐标到圆心的距离与半径的关系即可。再比如迷宫游戏里面，移动人物的时候需要判断前方是否是墙壁，是墙壁的话就不能移动。这个碰撞检测的方法不太常见，是通过像素检测的方式。如果前方的像素是我们预定的墙壁的颜色，就不能移动了。\n\n### 一些需要知道的东西\n\n动画对于重绘速度有要求，通常每秒30次以上才不会导致出现间断的现象。由于绘制速度很快，可能你会觉得我们的画布会反应迟钝。但是，由于很多现代浏览器都使用了**硬件加速**等性能增强技术，把图像处理工作转移给显卡，从而节省了CPU。由此引申出一个css hack技术。开启硬件加速，css如下：\n\n    transform: translateZ(0);\n    transform: translate3d(0, 0, 0);\n\n圆圈绘图程序每次刷新画布，都会先使用clearRect清除所有，再绘制所有(比上次多). 这样不会出现闪烁，因为Canvas针对这个问题进行了优化，它实际上会在绘图逻辑执行完成后才清除或绘制所有内容。\n\n## canvas动画实例\n\n### 实例一 自由落体交互的小球\n\n要不断的移动小球，正如上面所说，就需要不断重绘canvas\n\n    setTimeOut(\"drawFrame()\", 20)\n\n接下来看看drawFrame函数：\n    \n    function drawFrame() {\n      //清空\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      context.beginPath();\n      //balls是一个存放我们小球的数组。\n      for(var i=0; i&lt;balls.length; i++) {\n        var ball = balls[i];\n        ball.x += ball.dx;\n        ball.y += ball.dy;\n        // 添加重力效果\n        if ((ball.y) &lt; canvas.height) ball.dy += 0.22;\n        // 添加摩擦力效果\n        ball.dx = ball.dx * 0.998;\n        // 碰到墙反弹\n        if ((ball.x + ball.radius &gt; canvas.width) || (ball.x - ball.radius &lt; 0)) {\n          ball.dx = -ball.dx;\n        }\n        // 碰到地反弹注意0.96哦！\n        if ((ball.y + ball.radius &gt; canvas.height) || (ball.y - ball.radius &lt; 0)) { \n          ball.dy = -ball.dy*0.96; \n        }\n        context.fillStyle = \"white\";\n        // Draw 开始绘制球\n        context.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);\n        context.lineWidth = 1;\n        context.fill();\n        context.stroke(); \n      }\n      setTimeout(\"drawFrame()\", 20);\n    }\n\n\n`drawFrame`函数是动画的核心，处理外力对小球的影响。考虑了重力摩擦力等。然后不断调整小球的坐标，刷新重绘。\n\n下面是我们处理鼠标交互的函数：\n\n    function canvasClick(e) {\n      // 触点位置\n      var clickX = e.pageX - canvas.offsetLeft;\n      var clickY = e.pageY - canvas.offsetTop;\n      // 边界检测，看点击哪个球。\n      for(var i in balls)\n      {\n        var ball = balls[i];\n        if ((clickX &gt; (ball.x-ball.radius)) &amp;&amp; (clickX &lt; (ball.x+ball.radius)))\n        {\n          if ((clickY &gt; (ball.y-ball.radius)) &amp;&amp; (clickY &lt; (ball.y+ball.radius)))\n          {\n            // 改变小球的速度。\n            ball.dx -= 2;\n            ball.dy -= 3;\n            return;\n          }\n        }\n      }\n    }\n\n最后是增加小球和清空画布：\n\n\n    function addBall() {\n      var radius = parseFloat(document.getElementById(\"ballSize\").value);\n      var ball = new Ball(50,50,1,1,radius);\n      balls.push(ball);\n    }\n    function clearBalls() {\n      // 清空数组，下次重绘的就是空得了。\n      balls = [];\n    }\n\n最终结果：\n\n![](/content/images/2016/07/eI--A--A--cI--A--A--eI--A--A--aI--A--A--aI--A--A--cI--A--A---958x198.png)\n\n### 实例二 散落的粒子\n\n这次，写一个无数粒子构成的名字，鼠标接触马上散落各处的例子。\n\n无数粒子是用canvas画的圆，不过半径我写成了1px。这里就不展示了。\n\n下面看核心函数，处理小球运动的轨迹：\n\n    function updateBalls(canvas, balls, timeDiff, mousePos) {\n       var context = canvas.getContext('2d');\n      \tvar collisionDamper = 0.3;//碰撞减缓\n      \tvar floorFriction = 0.0005 * timeDiff;//摩擦力\n      \tvar mouseForceMultiplier = 1 * timeDiff;//Multiplier 乘数\n      \tvar restoreForce = 0.002 * timeDiff;\n        //和上个例子一样，循环小球数组，改变每个小球的圆心坐标。\n      \tfor(var n = 0; n &lt; balls.length; n++) {\n            var ball = balls[n];\n            // 改变圆心坐标\n      \t    ball.y += ball.vy;\n            ball.x += ball.vx;\n            // 恢复力，最后要静止。\n      \t    if(ball.x &gt; ball.origX) {\n      \t\t      ball.vx -= restoreForce;\n            } else {\n      \t\t      ball.vx += restoreForce;\n            }\n            if(ball.y &gt; ball.origY) {\n      \t\t      ball.vy -= restoreForce;\n            } else {\n      \t\t      ball.vy += restoreForce;\n            }\n            // 鼠标给的力\n            var mouseX = mousePos.x;\n      \t    var mouseY = mousePos.y;\n      \t    var distX = ball.x - mouseX;//判断左右的。\n      \t    var distY = ball.y - mouseY;\n            var radius = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));\n            var totalDist = Math.abs(distX) + Math.abs(distY);\n            var forceX = (Math.abs(distX) / totalDist) * (1 / radius) *   mouseForceMultiplier;\n      \t    var forceY = (Math.abs(distY) / totalDist) * (1 / radius) * mouseForceMultiplier;\n      \t    if(distX &gt; 0) {\n          \t\t // 如果从左边触动小球\n          \t\t ball.vx += forceX;\n            } else {\n      \t\t     ball.vx -= forceX;\n            }\n            if(distY &gt; 0) {\n          \t\t // 从上方触动小球\n          \t\t ball.vy += forceY;\n            } else {\n      \t\t     ball.vy -= forceY;\n            }\n            // 考虑地板摩擦力\n            if(ball.vx &gt; 0) {\n      \t\t      ball.vx -= floorFriction;\n            } else if(ball.vx &lt; 0) {\n      \t\t      ball.vx += floorFriction; \n            }\n      \t    if(ball.vy &gt; 0) {\n      \t\t      ball.vy -= floorFriction;\n            } else if(ball.vy &lt; 0) {\n      \t\t      ball.vy += floorFriction;\n      \t    }\n      \t    // 碰到地板反弹\n            if(ball.y &gt; (canvas.height - ball.radius)) {\n        \t\t   ball.y = canvas.height - ball.radius - 2;\n        \t\t   ball.vy *= -1;\n        \t\t   ball.vy *= (1 - collisionDamper);\n            }\n            // 碰到上顶反弹\n      \t    if(ball.y &lt; (ball.radius)) {\n        \t\t   ball.y = ball.radius + 2;\n        \t\t   ball.vy *= -1;\n        \t\t   ball.vy *= (1 - collisionDamper);\n            }\n            // 碰到右边反弹\n            if(ball.x &gt; (canvas.width - ball.radius)) {\n        \t\t   ball.x = canvas.width - ball.radius - 2;\n        \t\t   ball.vx *= -1;\n        \t\t   ball.vx *= (1 - collisionDamper);\n           }\n            // 碰到左边反弹\n            if(ball.x &lt; (ball.radius)) {\n        \t\t   ball.x = ball.radius + 2;\n        \t\t   ball.vx *= -1;\n        \t\t   ball.vx *= (1 - collisionDamper);\n            }\n        }\n   }\n   \n\n就像注释的一样，考虑了反弹、地板摩擦力、鼠标力、恢复力等。通过这个函数改变小球的位置。\n\n剩下其他几个不太重要的函数就不写了，主要是循环小球数组重绘，寻找鼠标触点位置等，和第一个差不多。\n\n效果（本来想写freestyle的，太多了，懒得去复制后面的。）：\n\n![](/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198.png)\n","mobiledoc":null,"html":"<h2 id=\"\">引题</h2>\n\n<p>最近忙完实验，在慢慢开始的学习HTML5 的canvas，很早就听过动态canvas的威名，一直没有机会和时间学习。这次系统学习HTML5和css3，自然不会放过这次机会。</p>\n\n<p>本文主要是总结学习canvas动画的一些基本知识，并不会介绍canvas，关于入门读者朋友可以回去翻翻书本。另外本文还会试着写几个实例，加深理解。</p>\n\n<h2 id=\"canvas\">canvas动画基本思想</h2>\n\n<h3 id=\"\">思想一 刷新重绘</h3>\n\n<p>我们平时看到的canvas游戏里，人物运动、物体变化都是基于这个思想。比如绘制动画的圆，我们通过鼠标触动或者重力等外界因素改变圆的圆心坐标。下一步，通过：</p>\n\n<pre><code>context.clearRect(0, 0, canvas.width, canvas.height)\n</code></pre>\n\n<p>把当前canvas的画面清空。然后，再通过：</p>\n\n<pre><code>context.art(circle.x, circle.y, circle.radius, 0, Math.PI*2) \n</code></pre>\n\n<p>利用新的圆心坐标绘制新的圆。</p>\n\n<p>刷新重绘的思想是canvas游戏的核心，任何需要移动的物体都是通过这种方式。</p>\n\n<p>不过在即时战略游戏中，很多东西不需要更新，需要的只是人物，这样我们全部清楚再重绘就有点得不偿失。这里就需要用到一种区域适配更新的技术，是John Carmack发明的，叫做ATR技术。有兴趣的朋友可以去google一下。</p>\n\n<h3 id=\"\">思想二 碰撞检测</h3>\n\n<p>碰撞检测用的比较比较频繁。比如和canvas上的圆交互的时候，需要检测点击的是哪个圆，只需循环判断触点坐标到圆心的距离与半径的关系即可。再比如迷宫游戏里面，移动人物的时候需要判断前方是否是墙壁，是墙壁的话就不能移动。这个碰撞检测的方法不太常见，是通过像素检测的方式。如果前方的像素是我们预定的墙壁的颜色，就不能移动了。</p>\n\n<h3 id=\"\">一些需要知道的东西</h3>\n\n<p>动画对于重绘速度有要求，通常每秒30次以上才不会导致出现间断的现象。由于绘制速度很快，可能你会觉得我们的画布会反应迟钝。但是，由于很多现代浏览器都使用了<strong>硬件加速</strong>等性能增强技术，把图像处理工作转移给显卡，从而节省了CPU。由此引申出一个css hack技术。开启硬件加速，css如下：</p>\n\n<pre><code>transform: translateZ(0);\ntransform: translate3d(0, 0, 0);\n</code></pre>\n\n<p>圆圈绘图程序每次刷新画布，都会先使用clearRect清除所有，再绘制所有(比上次多). 这样不会出现闪烁，因为Canvas针对这个问题进行了优化，它实际上会在绘图逻辑执行完成后才清除或绘制所有内容。</p>\n\n<h2 id=\"canvas\">canvas动画实例</h2>\n\n<h3 id=\"\">实例一 自由落体交互的小球</h3>\n\n<p>要不断的移动小球，正如上面所说，就需要不断重绘canvas</p>\n\n<pre><code>setTimeOut(\"drawFrame()\", 20)\n</code></pre>\n\n<p>接下来看看drawFrame函数：</p>\n\n<pre><code>function drawFrame() {\n  //清空\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.beginPath();\n  //balls是一个存放我们小球的数组。\n  for(var i=0; i&amp;lt;balls.length; i++) {\n    var ball = balls[i];\n    ball.x += ball.dx;\n    ball.y += ball.dy;\n    // 添加重力效果\n    if ((ball.y) &amp;lt; canvas.height) ball.dy += 0.22;\n    // 添加摩擦力效果\n    ball.dx = ball.dx * 0.998;\n    // 碰到墙反弹\n    if ((ball.x + ball.radius &amp;gt; canvas.width) || (ball.x - ball.radius &amp;lt; 0)) {\n      ball.dx = -ball.dx;\n    }\n    // 碰到地反弹注意0.96哦！\n    if ((ball.y + ball.radius &amp;gt; canvas.height) || (ball.y - ball.radius &amp;lt; 0)) { \n      ball.dy = -ball.dy*0.96; \n    }\n    context.fillStyle = \"white\";\n    // Draw 开始绘制球\n    context.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);\n    context.lineWidth = 1;\n    context.fill();\n    context.stroke(); \n  }\n  setTimeout(\"drawFrame()\", 20);\n}\n</code></pre>\n\n<p><code>drawFrame</code>函数是动画的核心，处理外力对小球的影响。考虑了重力摩擦力等。然后不断调整小球的坐标，刷新重绘。</p>\n\n<p>下面是我们处理鼠标交互的函数：</p>\n\n<pre><code>function canvasClick(e) {\n  // 触点位置\n  var clickX = e.pageX - canvas.offsetLeft;\n  var clickY = e.pageY - canvas.offsetTop;\n  // 边界检测，看点击哪个球。\n  for(var i in balls)\n  {\n    var ball = balls[i];\n    if ((clickX &amp;gt; (ball.x-ball.radius)) &amp;amp;&amp;amp; (clickX &amp;lt; (ball.x+ball.radius)))\n    {\n      if ((clickY &amp;gt; (ball.y-ball.radius)) &amp;amp;&amp;amp; (clickY &amp;lt; (ball.y+ball.radius)))\n      {\n        // 改变小球的速度。\n        ball.dx -= 2;\n        ball.dy -= 3;\n        return;\n      }\n    }\n  }\n}\n</code></pre>\n\n<p>最后是增加小球和清空画布：</p>\n\n<pre><code>function addBall() {\n  var radius = parseFloat(document.getElementById(\"ballSize\").value);\n  var ball = new Ball(50,50,1,1,radius);\n  balls.push(ball);\n}\nfunction clearBalls() {\n  // 清空数组，下次重绘的就是空得了。\n  balls = [];\n}\n</code></pre>\n\n<p>最终结果：</p>\n\n<p><img src=\"/content/images/2016/07/eI--A--A--cI--A--A--eI--A--A--aI--A--A--aI--A--A--cI--A--A---958x198.png\" alt=\"\" /></p>\n\n<h3 id=\"\">实例二 散落的粒子</h3>\n\n<p>这次，写一个无数粒子构成的名字，鼠标接触马上散落各处的例子。</p>\n\n<p>无数粒子是用canvas画的圆，不过半径我写成了1px。这里就不展示了。</p>\n\n<p>下面看核心函数，处理小球运动的轨迹：</p>\n\n<pre><code>function updateBalls(canvas, balls, timeDiff, mousePos) {\n   var context = canvas.getContext('2d');\n      var collisionDamper = 0.3;//碰撞减缓\n      var floorFriction = 0.0005 * timeDiff;//摩擦力\n      var mouseForceMultiplier = 1 * timeDiff;//Multiplier 乘数\n      var restoreForce = 0.002 * timeDiff;\n    //和上个例子一样，循环小球数组，改变每个小球的圆心坐标。\n      for(var n = 0; n &amp;lt; balls.length; n++) {\n        var ball = balls[n];\n        // 改变圆心坐标\n          ball.y += ball.vy;\n        ball.x += ball.vx;\n        // 恢复力，最后要静止。\n          if(ball.x &amp;gt; ball.origX) {\n                ball.vx -= restoreForce;\n        } else {\n                ball.vx += restoreForce;\n        }\n        if(ball.y &amp;gt; ball.origY) {\n                ball.vy -= restoreForce;\n        } else {\n                ball.vy += restoreForce;\n        }\n        // 鼠标给的力\n        var mouseX = mousePos.x;\n          var mouseY = mousePos.y;\n          var distX = ball.x - mouseX;//判断左右的。\n          var distY = ball.y - mouseY;\n        var radius = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));\n        var totalDist = Math.abs(distX) + Math.abs(distY);\n        var forceX = (Math.abs(distX) / totalDist) * (1 / radius) *   mouseForceMultiplier;\n          var forceY = (Math.abs(distY) / totalDist) * (1 / radius) * mouseForceMultiplier;\n          if(distX &amp;gt; 0) {\n               // 如果从左边触动小球\n               ball.vx += forceX;\n        } else {\n               ball.vx -= forceX;\n        }\n        if(distY &amp;gt; 0) {\n               // 从上方触动小球\n               ball.vy += forceY;\n        } else {\n               ball.vy -= forceY;\n        }\n        // 考虑地板摩擦力\n        if(ball.vx &amp;gt; 0) {\n                ball.vx -= floorFriction;\n        } else if(ball.vx &amp;lt; 0) {\n                ball.vx += floorFriction; \n        }\n          if(ball.vy &amp;gt; 0) {\n                ball.vy -= floorFriction;\n        } else if(ball.vy &amp;lt; 0) {\n                ball.vy += floorFriction;\n          }\n          // 碰到地板反弹\n        if(ball.y &amp;gt; (canvas.height - ball.radius)) {\n               ball.y = canvas.height - ball.radius - 2;\n               ball.vy *= -1;\n               ball.vy *= (1 - collisionDamper);\n        }\n        // 碰到上顶反弹\n          if(ball.y &amp;lt; (ball.radius)) {\n               ball.y = ball.radius + 2;\n               ball.vy *= -1;\n               ball.vy *= (1 - collisionDamper);\n        }\n        // 碰到右边反弹\n        if(ball.x &amp;gt; (canvas.width - ball.radius)) {\n               ball.x = canvas.width - ball.radius - 2;\n               ball.vx *= -1;\n               ball.vx *= (1 - collisionDamper);\n       }\n        // 碰到左边反弹\n        if(ball.x &amp;lt; (ball.radius)) {\n               ball.x = ball.radius + 2;\n               ball.vx *= -1;\n               ball.vx *= (1 - collisionDamper);\n        }\n    }\n</code></pre>\n\n<p>}</p>\n\n<p>就像注释的一样，考虑了反弹、地板摩擦力、鼠标力、恢复力等。通过这个函数改变小球的位置。</p>\n\n<p>剩下其他几个不太重要的函数就不写了，主要是循环小球数组重绘，寻找鼠标触点位置等，和第一个差不多。</p>\n\n<p>效果（本来想写freestyle的，太多了，懒得去复制后面的。）：</p>\n\n<p><img src=\"/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198.png\" alt=\"\" /></p>","image":"/content/images/2016/07/A--A--A--eI--A--A--cI--A--A--cI--A--A--aI--A--A---958x198-1.png","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:03:40","created_by":1,"updated_at":"2016-07-19 14:08:17","updated_by":1,"published_at":"2013-06-22 08:09:00","published_by":1},{"id":106,"uuid":"50ea9671-d57e-4f59-82e9-3eb8aa982bcc","title":"关于文件上传的几种方式","slug":"file-upload-theme-2","markdown":"##### 上传之前 JavaScript 检测\n1：javascript判断上传文件的大小：\n\n在FireFox、Chrome浏览器中可以根据`document.getElementById(\"id_of_file\").size` 获取上传文件的大小（字节数），而IE浏览器中不支持该属性，只能借助`<img>`标签的`dynsrc`属性，来间接实现获取文件的大小（但需要同意ActiveX控件的运行）。\n\n\tvar ua = window.navigator.userAgent;\n\tif (ua.indexOf(\"MSIE\")>=1){\n\t    browserCfg.ie = true;\n\t}else if(ua.indexOf(\"Firefox\")>=1){\n\t    browserCfg.firefox = true;\n\t}else if(ua.indexOf(\"Chrome\")>=1){\n\t    browserCfg.chrome = true;\n\t}</pre><p>&nbsp;</p>\n\n\tif(browserCfg.firefox || browserCfg.chrome ){\n\t    filesize = obj_file.files[0].size;\n\t}else if(browserCfg.ie){\n\t    var obj_img = document.getElementById(&#39;tempimg&#39;);\n\t    obj_img.dynsrc=obj_file.value;\n\t    filesize = obj_img.fileSize;\n\t}\n\n2：在 HTML 文档中`<input type=\"file\">`标签每出现一次，一个`FileUpload` 对象就会被创建。\n\n该元素的 value 属性保存了用户指定的文件的名称，但是当包含一个 file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容而不仅仅是发送文件名。\n\n为安全起见，file-upload 元素不允许 HTML 作者或 JavaScript 程序员指定一个默认的文件名。HTML value 属性被忽略，并且对于此类元素来说，value 属性是只读的，这意味着只有用户可以输入一个文件名。当用户选择或编辑一个文件名，file-upload 元素触发 onchange 事件句柄。\n\n直接读value属性：\n\n![](/content/images/2016/07/1685753635620199227.png)\n\n3：`<input type='file'>`的files属性，是一个FileList对象（类数组对象），包含了名字和大小 等。如下：\n\n![](/content/images/2016/07/1982709736049941728-300x81.png)\n\n##### HTML5 File API实现上传文件\n\n访问本地文件的一个简单的方法是通过`<input type=\"file\"/>` HTML表单元素。这会给你访问为只读信息提供一个单独的文件如它的名称，大小，MIME类型，文件句柄的引用。\n\nHTML5的File API包括：\n\n1.    FileList序列：代表本地系统中选中的文件组成的数组，通过`<input type='file'>`调用\n2.    Blob接口，原始二进制数据，通过Blob对戏那个你可以访问里面的字节数据。\n3.    File接口，里面存有文件中的只读属性，文件名，类型，访问地址。\n4.    FileReader接口，提供读取文件方法\n5.    FileError接口和FileException对象，定义错误产生条件。\n\n下面实现单文件访问：核心代码就两行，也就是上面提到的FileList和FileReader。\n\n![](/content/images/2016/07/3167719388001804717-300x211.png)\n\n结果：\n\n![](/content/images/2016/07/6597294067029538127-300x235.png)\n\n实现多文件访问：\n\n![](/content/images/2016/07/3334352574214486754-300x255.png)\n\n结果：\n\n![](/content/images/2016/07/3172785937582596517-199x300.png)\n\nps：另外一个种方式File API，它 是 Mozilla 向 W3C 提交的一个草案，可以监听onload，onprogress，onloadstart等事件。详见[这里](http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload)。</a>\n\n##### 使用PHP实现文件上传\n\nHTML:注意设置MIME编码为`multipart/form-data.`\n\n`enctype=\"multipart/form-data\"`是上传二进制数据; form里面的input的值以2进制的方式传过去。\n\n\t<form enctype=\"multipart/form-data\" method=\"post\" action=\"..\">\n\t    <input type=\"file\" id=\"screenshot\" name=\"screenshot\" />\n\t    <hr />\n\t    <input type=\"submit\" value=\"Add\" name=\"submit\" />\n\t</form></pre><p>&nbsp;</p>\n\n\tphp:\n\t$screenshot = $_FILES[&#39;screenshot&#39;][&#39;name&#39;];\n\t$screenshot_type = $_FILES[&#39;screenshot&#39;][&#39;type&#39;];\n\t$screenshot_size = $_FILES[&#39;screenshot&#39;][&#39;size&#39;]; \n\n\n\t$target = $_SERVER[\"DOCUMENT_ROOT\"].GW_UPLOADPATH. $screenshot;\n\tmove_uploaded_file($_FILES[&#39;screenshot&#39;][&#39;tmp_name&#39;], $target)//这里把我们上传的文件放到$target。\n\n需要注意的是，move_uploaded_file函数里面的$target只能为绝对路径，不然就会报错。在这里困了好久。\n\n\n","mobiledoc":null,"html":"<h5 id=\"javascript\">上传之前 JavaScript 检测</h5>\n\n<p>1：javascript判断上传文件的大小：</p>\n\n<p>在FireFox、Chrome浏览器中可以根据<code>document.getElementById(\"id_of_file\").size</code> 获取上传文件的大小（字节数），而IE浏览器中不支持该属性，只能借助<code>&lt;img&gt;</code>标签的<code>dynsrc</code>属性，来间接实现获取文件的大小（但需要同意ActiveX控件的运行）。</p>\n\n<pre><code>var ua = window.navigator.userAgent;\nif (ua.indexOf(\"MSIE\")&gt;=1){\n    browserCfg.ie = true;\n}else if(ua.indexOf(\"Firefox\")&gt;=1){\n    browserCfg.firefox = true;\n}else if(ua.indexOf(\"Chrome\")&gt;=1){\n    browserCfg.chrome = true;\n}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\nif(browserCfg.firefox || browserCfg.chrome ){\n    filesize = obj_file.files[0].size;\n}else if(browserCfg.ie){\n    var obj_img = document.getElementById(&amp;#39;tempimg&amp;#39;);\n    obj_img.dynsrc=obj_file.value;\n    filesize = obj_img.fileSize;\n}\n</code></pre>\n\n<p>2：在 HTML 文档中<code>&lt;input type=\"file\"&gt;</code>标签每出现一次，一个<code>FileUpload</code> 对象就会被创建。</p>\n\n<p>该元素的 value 属性保存了用户指定的文件的名称，但是当包含一个 file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容而不仅仅是发送文件名。</p>\n\n<p>为安全起见，file-upload 元素不允许 HTML 作者或 JavaScript 程序员指定一个默认的文件名。HTML value 属性被忽略，并且对于此类元素来说，value 属性是只读的，这意味着只有用户可以输入一个文件名。当用户选择或编辑一个文件名，file-upload 元素触发 onchange 事件句柄。</p>\n\n<p>直接读value属性：</p>\n\n<p><img src=\"/content/images/2016/07/1685753635620199227.png\" alt=\"\" /></p>\n\n<p>3：<code>&lt;input type='file'&gt;</code>的files属性，是一个FileList对象（类数组对象），包含了名字和大小 等。如下：</p>\n\n<p><img src=\"/content/images/2016/07/1982709736049941728-300x81.png\" alt=\"\" /></p>\n\n<h5 id=\"html5fileapi\">HTML5 File API实现上传文件</h5>\n\n<p>访问本地文件的一个简单的方法是通过<code>&lt;input type=\"file\"/&gt;</code> HTML表单元素。这会给你访问为只读信息提供一个单独的文件如它的名称，大小，MIME类型，文件句柄的引用。</p>\n\n<p>HTML5的File API包括：</p>\n\n<ol>\n<li>FileList序列：代表本地系统中选中的文件组成的数组，通过<code>&lt;input type='file'&gt;</code>调用  </li>\n<li>Blob接口，原始二进制数据，通过Blob对戏那个你可以访问里面的字节数据。  </li>\n<li>File接口，里面存有文件中的只读属性，文件名，类型，访问地址。  </li>\n<li>FileReader接口，提供读取文件方法  </li>\n<li>FileError接口和FileException对象，定义错误产生条件。</li>\n</ol>\n\n<p>下面实现单文件访问：核心代码就两行，也就是上面提到的FileList和FileReader。</p>\n\n<p><img src=\"/content/images/2016/07/3167719388001804717-300x211.png\" alt=\"\" /></p>\n\n<p>结果：</p>\n\n<p><img src=\"/content/images/2016/07/6597294067029538127-300x235.png\" alt=\"\" /></p>\n\n<p>实现多文件访问：</p>\n\n<p><img src=\"/content/images/2016/07/3334352574214486754-300x255.png\" alt=\"\" /></p>\n\n<p>结果：</p>\n\n<p><img src=\"/content/images/2016/07/3172785937582596517-199x300.png\" alt=\"\" /></p>\n\n<p>ps：另外一个种方式File API，它 是 Mozilla 向 W3C 提交的一个草案，可以监听onload，onprogress，onloadstart等事件。详见<a href=\"http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload\">这里</a>。</a></p>\n\n<h5 id=\"php\">使用PHP实现文件上传</h5>\n\n<p>HTML:注意设置MIME编码为<code>multipart/form-data.</code></p>\n\n<p><code>enctype=\"multipart/form-data\"</code>是上传二进制数据; form里面的input的值以2进制的方式传过去。</p>\n\n<pre><code>&lt;form enctype=\"multipart/form-data\" method=\"post\" action=\"..\"&gt;\n    &lt;input type=\"file\" id=\"screenshot\" name=\"screenshot\" /&gt;\n    &lt;hr /&gt;\n    &lt;input type=\"submit\" value=\"Add\" name=\"submit\" /&gt;\n&lt;/form&gt;&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\nphp:\n$screenshot = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;name&amp;#39;];\n$screenshot_type = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;type&amp;#39;];\n$screenshot_size = $_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;size&amp;#39;]; \n\n\n$target = $_SERVER[\"DOCUMENT_ROOT\"].GW_UPLOADPATH. $screenshot;\nmove_uploaded_file($_FILES[&amp;#39;screenshot&amp;#39;][&amp;#39;tmp_name&amp;#39;], $target)//这里把我们上传的文件放到$target。\n</code></pre>\n\n<p>需要注意的是，move<em>uploaded</em>file函数里面的$target只能为绝对路径，不然就会报错。在这里困了好久。</p>","image":"/content/images/2016/07/images.jpeg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:13:46","created_by":1,"updated_at":"2016-07-19 14:09:43","updated_by":1,"published_at":"2013-05-24 08:13:00","published_by":1},{"id":107,"uuid":"22dadcb9-cd81-427a-8779-ec5c8faacc42","title":"前端跨域方式总结和实践","slug":"cross-origin-summary-2","markdown":"面试的时候问了跨域，之前知道几种方式，不过没有深入。既然面试官都问了，那么估计在实践中也会很多吧。总结学习学习！后面和同学讨论后，再问了下google，发现跨域的方式真的好多。\n\n本文意在总结和实践各种跨域方式，然后对比每种的优缺点，希望找到最佳实践方案。\n\n很好的一篇文章，推荐之：\n\n[http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)\n\n通过这篇文章知道了，`域名／协议／端口`只要其中之一不同都不能跨域，另外二级域名之间也不能跨。跨域的解决 ,有句经典的话就是，凡是有src属性的东东，都可以用来跨域。比如img，iframe，script等。\n\n如果练习的话，本机配置虚拟主机的教程在以前的[一篇文章](http://freestyleboy21.blog.163.com/blog/static/20840624120133139420259/?COLLCC=726912607)\n\n## 跨域之动态script\n\n这里，要首先弄清楚，我们跨域的目的是什么？\n\n我理解的是，跨域就是a.com要访问b.com的数据，包括变量，对象等。弄清楚后就可以开始实践这种动态script的方式了。\n\n在127.0.0.2的test.js中，我们要把传递给127.0.0.1/test.php 的数据封装好，我这里简单一个例子:\n\n    // 127.0.0.2/test.js\n\t(function() {\n\t\tvar b_myinfo = {\n\t\t\t'name' : 'fs21',\n\t\t\t'sex'  : 'male',\n\t\t\t'old'  : '21',\n\t\t\t'from' : 'uestc'\n\t\t}\n\t\ta_handler(b_myinfo);\n\t})();\n\n如果在php中，则可以用`echo $_GET('callback').\"($data);\";`来调用回调函数。\n\n另外在`127.0.0.1/test.php`中：\n\n![](/content/images/2016/07/1.png)\n\n请注意上面判断script加载完毕的方式。还有加载完了后的销毁，释放内存。\n这样在我们访问127.0.0.1/test.php时，结果如下：\n\n![](/content/images/2016/07/2.png)\n\n### 传说中的神器，jsonp\n\n上面的方式是两个域我们都可以控制，在一个域中配置好数据接口，另一个域来动态使用。\n\n其实另一个域也第三方的。下面的例子调用百度翻译，写一个简单的单词查询demo。test.html如下：\n\n![](/content/images/2016/07/3.png)\n\n就是获取输入框的内容，动态配置script的src，然后把查询的返回过来。\n\n注意上面src的最后一个回调函数。还有这个回调函数的作用域问题。\n\n结果如下：\n\n![](/content/images/2016/07/4.png)\n\n# 跨域之document.domain + iframe\n\n这种方式主要用在主域相同而子域不同的情况，由于不好模拟，就不折腾了，等以后有需求了，在来弄吧。核心代码如下：\n\n    //a.b.com/c.html\n\tdocument.domain = 'b.com';\n\tvar iframe = document.createElement('iframe');\n\tiframe.src = 'http://e.b.com/f.html';\n\tiframe.style.display = 'none';\n\tiframe.onload = function() {\n\t    var doc = iframe.contentDocument || iframe.contentWindow.document;\n\t    //这里操纵f.html\n\t    var fH1 = doc.getElementsByTagName('h1')[0];\n\t    .....\n\t}\n\t//e.b.com/f.html \n\tdocument.domain = 'b.com\n\n# 跨域之window.name\n\n这个方法早在08年的时候，克军和怿飞就写了博文介绍这这个方法。只怪生的太迟，不能跟上步伐。。站在巨人肩膀上的前提是学习前人的知识经验。\n\n先解释这个方法的原理。这种方法的核心是frame的window.name属性可以存不少数据，**当内部iframe src变化时window.name不变。**\n\n由三个页面组成，`127.0.0.1/test.php｜127.0.0.1/proxy.html｜127.0.0.2/index.php`\n\n我要做的是从第一个访问第三个中的数据。在/test.php中创建一个frame，src指向index.php,如果直接访问frame中的window.name会提示跨域错误，所以第二个proxy.html就上场了，proxy.html内容为空，但是和test.php在同一个域。我们判断如果把index.php加载完成后就把frame的src改成proxy.html，现在访问就不会提示跨域错误了，而且刚才说过，frame的window.name不会变！\n\n代码如下：\n\n//test.php\n\n![](/content/images/2016/07/5.png)\n\n\n    //index.php\n    window.name = 'i am from 127.0.0.2 !';\n\n当访问127.0.0.1/test.php时返回如下：\n\n![](/content/images/2016/07/6.png)\n\n\n这里有点需要注意，即使是IP和域名互相对应，也不能互相通信，他们之间也算跨域。因为这个原因，调了好久。上面的localhost/proxy.html那行最开始写成了`http://127.0.0.1/proxy.html`,这样是不能通信的。\n\n#跨域之HTML5 postMessage\n\n这种跨域方式比较新，而且api简单，容易上手，缺点就是浏览器支持不够，目前就那么几个比较潮的支持。不过相信，不过多久就会成为主流的跨域方式～\n\n下面的目标是两个域互相对话。先给效果图：\n\n![](/content/images/2016/07/7.png)\n\n用iframe的目的是为了方便我们看到，不然还得两个来回转换。其实可以不用iframe的哈！\n\n代码如下:\n\n// 127.0.0.1 test.php\n\n![](/content/images/2016/07/8.png)\n\n//127.0.0.2 index.php\n\n![](/content/images/2016/07/9.png)\n\n如大家所看，HTML5的PostMessage核心代码就postMessage和onmessage。相信不用解释都能懂啦～\n\n# 跨域之flash\n\n现在的flash已经不只是一个动画，更多的有了数据交互，与外界互动，那么跨域也是必须要面对的问题。\n\n由于对flash不太熟悉，只能从网上找点例子，看看原理，这里大致解释一下，如果有熟悉的朋友，欢迎交流指教。\n大致原理就是利用flash API中的LocalConnecttion这个类，在需要通信的两个域中各嵌套一个SWF，然后互相交换数据。\n\n别人说的，数据量限制40kb，数据快。没有实践，先记着吧。\n\n用这种方式跨域通信比较复杂，需要两个SWF，个人感觉实用性不强。\n\n# 跨域之CORS\n\nCORS的全称是`Cross-Origin Resource Sharing`，中文名字叫做“跨域资源共享”。目前在W3C的文档中还是草案，不过浏览器支持情况还是很乐观，IE8(不是XHR而是XDR）以上的IE，chrome 4.0以上，firefox 3.5以上都支持。参见caniuse.com\n\n最开始的时候是在高级程序设计上看到的，不过没有仔细研究。这次弄跨域，果断一起弄了。\n\n其实CORS和XHR差不多，唯一的差别就是CORS需要服务器支持。之前在XHR的写法是：\n\n    xhr.open('GET‘，’test.php',true);\n\n这里的test.php都是在同域名下，一般用相对地址。而我们的CORS写法是：\n\n    xhr.open('GET','freestyle21.cn',true);\n\n差别就是url变成不同域了！但是。。直接这样访问肯定是不行的，要报`Origin is not allowed by Access-Control-Allow-Origin.`的错误。CORS的解决方案是在服务器端该Header头部：\n\n    header(\"Access-Control-Allow-Origin：＊\");\n\n这样再次访问就可以了。对，CORS就这么简单！\n\n下面照例写个demo。http://127.0.0.1/test.php\n\n![](/content/images/2016/07/10.png)\n\n// 127.0.0.2/index.php\n\n    header(\"Access-Control-Allow-Origin:http://localhost\"); \n\n    i am from http://127.0.0.2/index.php\n\n现在访问`127.0.0.1／test.php`结果如下：\n\n![](/content/images/2016/07/10-1.png)\n\n# 总结\n\n通过动态script跨域，就是相当与引入一个外部的js文件而已，只不过这个文件带回来了一些有用的数据。\n\n通过jsonp跨域，实质是HTTP的GET方式请求，把参数或者回调函数传入url，然后在服务端做好相应的接口，返回给回调函数。见过别人做个的另一各种相似的方式是把参数给hash值，另一边通过轮询判断hash的变化，然后利用location.hash使用这个参数。这种方式都感觉略不完美，数据放在url上很不安全，而且会产生历史记录，数量有限\n\n总的来说，目前最简单有效的方式是jsonp，如果在受信任的双方传递数据，它是最佳的选择。\n在上面的例子中同样看到了CORS和postMessage的高效，在可预见的几年内，势必会成为主流。\n\nps：这篇文章边实践边写，写的比较久，断断续续的。因为博客的代码效果(之前在github上)不是很好，所以直接截图了。","mobiledoc":null,"html":"<p>面试的时候问了跨域，之前知道几种方式，不过没有深入。既然面试官都问了，那么估计在实践中也会很多吧。总结学习学习！后面和同学讨论后，再问了下google，发现跨域的方式真的好多。</p>\n\n<p>本文意在总结和实践各种跨域方式，然后对比每种的优缺点，希望找到最佳实践方案。</p>\n\n<p>很好的一篇文章，推荐之：</p>\n\n<p><a href=\"http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html\">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>\n\n<p>通过这篇文章知道了，<code>域名／协议／端口</code>只要其中之一不同都不能跨域，另外二级域名之间也不能跨。跨域的解决 ,有句经典的话就是，凡是有src属性的东东，都可以用来跨域。比如img，iframe，script等。</p>\n\n<p>如果练习的话，本机配置虚拟主机的教程在以前的<a href=\"http://freestyleboy21.blog.163.com/blog/static/20840624120133139420259/?COLLCC=726912607\">一篇文章</a></p>\n\n<h2 id=\"script\">跨域之动态script</h2>\n\n<p>这里，要首先弄清楚，我们跨域的目的是什么？</p>\n\n<p>我理解的是，跨域就是a.com要访问b.com的数据，包括变量，对象等。弄清楚后就可以开始实践这种动态script的方式了。</p>\n\n<p>在127.0.0.2的test.js中，我们要把传递给127.0.0.1/test.php 的数据封装好，我这里简单一个例子:</p>\n\n<pre><code>// 127.0.0.2/test.js\n(function() {\n    var b_myinfo = {\n        'name' : 'fs21',\n        'sex'  : 'male',\n        'old'  : '21',\n        'from' : 'uestc'\n    }\n    a_handler(b_myinfo);\n})();\n</code></pre>\n\n<p>如果在php中，则可以用<code>echo $_GET('callback').\"($data);\";</code>来调用回调函数。</p>\n\n<p>另外在<code>127.0.0.1/test.php</code>中：</p>\n\n<p><img src=\"/content/images/2016/07/1.png\" alt=\"\" /></p>\n\n<p>请注意上面判断script加载完毕的方式。还有加载完了后的销毁，释放内存。\n这样在我们访问127.0.0.1/test.php时，结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/2.png\" alt=\"\" /></p>\n\n<h3 id=\"jsonp\">传说中的神器，jsonp</h3>\n\n<p>上面的方式是两个域我们都可以控制，在一个域中配置好数据接口，另一个域来动态使用。</p>\n\n<p>其实另一个域也第三方的。下面的例子调用百度翻译，写一个简单的单词查询demo。test.html如下：</p>\n\n<p><img src=\"/content/images/2016/07/3.png\" alt=\"\" /></p>\n\n<p>就是获取输入框的内容，动态配置script的src，然后把查询的返回过来。</p>\n\n<p>注意上面src的最后一个回调函数。还有这个回调函数的作用域问题。</p>\n\n<p>结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/4.png\" alt=\"\" /></p>\n\n<h1 id=\"documentdomainiframe\">跨域之document.domain + iframe</h1>\n\n<p>这种方式主要用在主域相同而子域不同的情况，由于不好模拟，就不折腾了，等以后有需求了，在来弄吧。核心代码如下：</p>\n\n<pre><code>//a.b.com/c.html\ndocument.domain = 'b.com';\nvar iframe = document.createElement('iframe');\niframe.src = 'http://e.b.com/f.html';\niframe.style.display = 'none';\niframe.onload = function() {\n    var doc = iframe.contentDocument || iframe.contentWindow.document;\n    //这里操纵f.html\n    var fH1 = doc.getElementsByTagName('h1')[0];\n    .....\n}\n//e.b.com/f.html \ndocument.domain = 'b.com\n</code></pre>\n\n<h1 id=\"windowname\">跨域之window.name</h1>\n\n<p>这个方法早在08年的时候，克军和怿飞就写了博文介绍这这个方法。只怪生的太迟，不能跟上步伐。。站在巨人肩膀上的前提是学习前人的知识经验。</p>\n\n<p>先解释这个方法的原理。这种方法的核心是frame的window.name属性可以存不少数据，<strong>当内部iframe src变化时window.name不变。</strong></p>\n\n<p>由三个页面组成，<code>127.0.0.1/test.php｜127.0.0.1/proxy.html｜127.0.0.2/index.php</code></p>\n\n<p>我要做的是从第一个访问第三个中的数据。在/test.php中创建一个frame，src指向index.php,如果直接访问frame中的window.name会提示跨域错误，所以第二个proxy.html就上场了，proxy.html内容为空，但是和test.php在同一个域。我们判断如果把index.php加载完成后就把frame的src改成proxy.html，现在访问就不会提示跨域错误了，而且刚才说过，frame的window.name不会变！</p>\n\n<p>代码如下：</p>\n\n<p>//test.php</p>\n\n<p><img src=\"/content/images/2016/07/5.png\" alt=\"\" /></p>\n\n<pre><code>//index.php\nwindow.name = 'i am from 127.0.0.2 !';\n</code></pre>\n\n<p>当访问127.0.0.1/test.php时返回如下：</p>\n\n<p><img src=\"/content/images/2016/07/6.png\" alt=\"\" /></p>\n\n<p>这里有点需要注意，即使是IP和域名互相对应，也不能互相通信，他们之间也算跨域。因为这个原因，调了好久。上面的localhost/proxy.html那行最开始写成了<code>http://127.0.0.1/proxy.html</code>,这样是不能通信的。</p>\n\n<h1 id=\"html5postmessage\">跨域之HTML5 postMessage</h1>\n\n<p>这种跨域方式比较新，而且api简单，容易上手，缺点就是浏览器支持不够，目前就那么几个比较潮的支持。不过相信，不过多久就会成为主流的跨域方式～</p>\n\n<p>下面的目标是两个域互相对话。先给效果图：</p>\n\n<p><img src=\"/content/images/2016/07/7.png\" alt=\"\" /></p>\n\n<p>用iframe的目的是为了方便我们看到，不然还得两个来回转换。其实可以不用iframe的哈！</p>\n\n<p>代码如下:</p>\n\n<p>// 127.0.0.1 test.php</p>\n\n<p><img src=\"/content/images/2016/07/8.png\" alt=\"\" /></p>\n\n<p>//127.0.0.2 index.php</p>\n\n<p><img src=\"/content/images/2016/07/9.png\" alt=\"\" /></p>\n\n<p>如大家所看，HTML5的PostMessage核心代码就postMessage和onmessage。相信不用解释都能懂啦～</p>\n\n<h1 id=\"flash\">跨域之flash</h1>\n\n<p>现在的flash已经不只是一个动画，更多的有了数据交互，与外界互动，那么跨域也是必须要面对的问题。</p>\n\n<p>由于对flash不太熟悉，只能从网上找点例子，看看原理，这里大致解释一下，如果有熟悉的朋友，欢迎交流指教。\n大致原理就是利用flash API中的LocalConnecttion这个类，在需要通信的两个域中各嵌套一个SWF，然后互相交换数据。</p>\n\n<p>别人说的，数据量限制40kb，数据快。没有实践，先记着吧。</p>\n\n<p>用这种方式跨域通信比较复杂，需要两个SWF，个人感觉实用性不强。</p>\n\n<h1 id=\"cors\">跨域之CORS</h1>\n\n<p>CORS的全称是<code>Cross-Origin Resource Sharing</code>，中文名字叫做“跨域资源共享”。目前在W3C的文档中还是草案，不过浏览器支持情况还是很乐观，IE8(不是XHR而是XDR）以上的IE，chrome 4.0以上，firefox 3.5以上都支持。参见caniuse.com</p>\n\n<p>最开始的时候是在高级程序设计上看到的，不过没有仔细研究。这次弄跨域，果断一起弄了。</p>\n\n<p>其实CORS和XHR差不多，唯一的差别就是CORS需要服务器支持。之前在XHR的写法是：</p>\n\n<pre><code>xhr.open('GET‘，’test.php',true);\n</code></pre>\n\n<p>这里的test.php都是在同域名下，一般用相对地址。而我们的CORS写法是：</p>\n\n<pre><code>xhr.open('GET','freestyle21.cn',true);\n</code></pre>\n\n<p>差别就是url变成不同域了！但是。。直接这样访问肯定是不行的，要报<code>Origin is not allowed by Access-Control-Allow-Origin.</code>的错误。CORS的解决方案是在服务器端该Header头部：</p>\n\n<pre><code>header(\"Access-Control-Allow-Origin：＊\");\n</code></pre>\n\n<p>这样再次访问就可以了。对，CORS就这么简单！</p>\n\n<p>下面照例写个demo。<a href=\"http://127.0.0.1/test.php\">http://127.0.0.1/test.php</a></p>\n\n<p><img src=\"/content/images/2016/07/10.png\" alt=\"\" /></p>\n\n<p>// 127.0.0.2/index.php</p>\n\n<pre><code>header(\"Access-Control-Allow-Origin:http://localhost\"); \n\ni am from http://127.0.0.2/index.php\n</code></pre>\n\n<p>现在访问<code>127.0.0.1／test.php</code>结果如下：</p>\n\n<p><img src=\"/content/images/2016/07/10-1.png\" alt=\"\" /></p>\n\n<h1 id=\"\">总结</h1>\n\n<p>通过动态script跨域，就是相当与引入一个外部的js文件而已，只不过这个文件带回来了一些有用的数据。</p>\n\n<p>通过jsonp跨域，实质是HTTP的GET方式请求，把参数或者回调函数传入url，然后在服务端做好相应的接口，返回给回调函数。见过别人做个的另一各种相似的方式是把参数给hash值，另一边通过轮询判断hash的变化，然后利用location.hash使用这个参数。这种方式都感觉略不完美，数据放在url上很不安全，而且会产生历史记录，数量有限</p>\n\n<p>总的来说，目前最简单有效的方式是jsonp，如果在受信任的双方传递数据，它是最佳的选择。\n在上面的例子中同样看到了CORS和postMessage的高效，在可预见的几年内，势必会成为主流。</p>\n\n<p>ps：这篇文章边实践边写，写的比较久，断断续续的。因为博客的代码效果(之前在github上)不是很好，所以直接截图了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:44:37","created_by":1,"updated_at":"2016-07-19 14:10:09","updated_by":1,"published_at":"2013-05-09 08:44:00","published_by":1},{"id":108,"uuid":"dbe40561-81ee-4b64-bf19-1ec0b42871a0","title":"Ant的故事","slug":"ant-build-tools-2","markdown":"##   Ant的来历\n\n前段时间在学习淘宝的前端框架Kissy，在项目开发指南中看到了Ant，由于以前听过，所以来了兴趣。正如上篇文章所说，前端实践非常重要，于是就从头到尾研究起Ant来。。\n\n说来，Ant来自Java，是一个基于Java的build工具。和Unix/Linux c中的make工具类似，不过由于Java的原因具有跨平台的优势。那么Ant和前端有半毛线关系么？答案是，哈哈~~\n对前端来说，Ant可以\n\n* 合并js和css文件\n* 压缩js和css文件\n* 生成jsDOC文档\n* 连接FTP，将代码上传到指定服务器\n* 自动上传到SVN，自动打包成zip文件\n* ....\n\n当然这些都是网上抄来的，没有一一实验。喜欢的还是合并、压缩、文档，也都自己从0开始慢慢摸索了下，总结记录一下，方便对她有兴趣的朋友..\n\n# Ant的入门\n\n### 首先我们安装Ant的环境。\n\n安装jdk的步骤就不细说，度娘那里有很多。\n\n下载Ant，传送门: [apache-ant-1.9.0](http://apache.fayea.com/apache-mirror//ant/source/apache-ant-1.9.0-src.zip)\n\n解压到你喜欢的位置，我是F:\\apache-ant-1.9.0.\n\n在path里面添加：`F:\\apache-ant-1.9.0.\\bin`\n\n在DOS里面输入ant，验证安装是否完成。出现下面的结果就算成功了。\n\n\n\tBuildfile：build.xml does not exist! \n\tBuild failed\n\n## 牛刀小试\n\n新建test的java项目，里面建立src目录，在src里面写一个hello.java，内容如下：\n\n\tpublic class HelloWorld {\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n在test目录里面建立build.xml文件。内容如下：\n\n\t<?xml version=\"1.0\" ?>\n\t<project name =\"javacTest\" default=\"run\" basedir=\".\">\n\n\t\t<target name=\"compile\">\n\t\t\t<mkdir dir =\"${basedir}/build/classes\"/>\n\t\t\t<javac srcdir =\"${basedir}/src\" destdir =\"${basedir}/build/classes\"/>\n\t\t</target>\n\t\t<target name=\"run\" depends =\"compile\">\n\t\t\t<java classname =\"HelloWorld\">\n\t\t\t<classpath>\n\t\t\t\t\t<pathelement path=\"${basedir}/build/classes\"/>\n\t\t\t</classpath>\n\t\t\t</java>\n\t\t</target>\n\t</project>\n\n用命令行进入`test`目录里面，执行`ant`。你会发现`build`里面多了`classes`目录，`classes`里面多了`hello.class`。在命令行里面会有`hello world`输出。如下图：\n\n![](/content/images/2016/07/ant.png)\n\n这次不准备讲ant的api，有兴趣的童鞋可以去看[官方文档](http://ant.apache.org/manual/index.html)。这里我把遇到的讲一下，相信这样你也能掌握常见的语法了~\n\n上面的`build.xml`中，就是我们的主角`Ant`了。每个`Ant`都有且只能有一个`project`，多个`target`(可理解为任务块)，`depends=\"compile\"`指必须名字为compile的target先执行，他们存在依赖关系。其他的就不解释了。\n\n## Ant和前端。\n\n### 合并js\n\n在test目录里面建四个js文件内容依次为`console.log(\"hello, i am from 1/2/3/4\");`然后建立build.xml内容为：\n\n\t\n\t<?xml version=\"1.0\"?>\n\t<project name=\"concat\" default=\"build\">\n\t\t<property name=\"concat.note\" value=\"//合并js\" />\n\t\t<target name=\"build\">\n\t\t\t<echo>生成src目录</echo>\n\t\t\t<mkdir dir=\"src\"/>\n\t\t\t<echo>开始合并文件</echo>\n\t\t\t<concat destfile=\"src/fs.js\">\n\t\t\t<header trimleading=\"yes\">${concat.note}\n\t\t\t</header>\n\t\t\t<path path=\"1.js\"/>\n\t\t\t<path path=\"2.js\"/>\n\t\t\t<path path=\"3.js\"/>\n\t\t\t<path path=\"4.js\"/>\n\t\t</concat>\n\t\t</target>\n\t</project>\n\nCMD切换到test目录，执行ant。输出\n\n![](/content/images/2016/07/ant2.png)\n\n在src里面多了fs.js文件，内容为：\n\n![](/content/images/2016/07/concat.png)\n\n现在解释上面的build.xml。property定义一个名为concat.note的变量，内容为`\"//合并js\"`，下面会用${concat.note}引用。header是给fs.js最上面加一行。下面的合并就那样，都看得懂，记住格式就好了。提示一点是header那里有换行，如果不换，自己试试后果，呵呵。\n\n有些童鞋就在想了，要是我有20个js，是不是要写20个path呢？当然不是！为了解决这个问题，我们的dadaType标签就闪亮登场啦~\n\n把path变成\n\n    <pre class=\"brush:xml\">\n        <fileset dir = \"./\" includes = \"**/*.js\">\n    </pre>\n\n\n就可以代替20个path！dataType常用除了我们见过的fileset/path，还有我们在压缩和生成文档要用的argument。fileset还有一个常用的语句，如下：\n\n\t<fileset dir = \"./\">\n\t    <include name = \"**/*.js\" if = \"test\">\n\t    <exclude name = \"my.js\" unless = \"my\">\n\t</fileset>\n\n如果设置了test属性，读取所有js，如果没有设置my属性，则排除my.js\n\n### 压缩js\n\n先下载[YUICompressor](http://vdisk.weibo.com/s/AjhVv)\n\n运行解压过后的install.cmd。(用管理员身份运行，否则会出错哦)\n\n然后随便右键一个文件就就会多一个Process with YUICompressor了。\n\n把刚才解压的YUICompressor放到test目录中，新建一个min文件夹。把build.xml改成如下：\n\n\t\t<?xml version=\"1.0\"?>\n\t\t<project name=\"refund\" default=\"build\">\n\t\t\t<dirname property=\"current.dir\" file=\"${ant.file.uploader}\"/>\n\t\t\t<property name=\"src.dir\" location=\"${current.dir}/src/\"/>\n\t\t\t<property name=\"yuicompressor.path\" location=\"${current.dir}/yuicompressor/yuicompressor.jar\"/>\n\t\t\t<target name=\"build\">\n\t\t\t\t<apply executable=\"java\" dest=\"${current.dir}/min\">\n\t\t\t\t<fileset dir=\"${src.dir}\" includes=\"*.js\"/>\n\t\t\t\t<arg line=\"-jar\"/>\n\t\t\t\t<arg path=\"${yuicompressor.path}\"/>\n\t\t\t\t<arg value=\"-o\"/>\n\t\t\t\t<targetfile/>\n\t\t\t\t<mapper type=\"glob\" from=\"*.js\" to=\"*-min.js\"/>\n\t\t\t\t</apply>\n\t\t\t</target>\n\t\t</project>\n\n然后运行ant命令。在min文件夹里面就会出现：\n\n![](/content/images/2016/07/min.png)\n\n解释上面的build.xml.dirname用来获取文件的目录路径。注意到里面有个变量指向yuicompressor.jar，这样才能用YUICompressor。这里的arg提供给apply一些参数。-jar为YUICompressor中的.jar路径，就是刚才提到的那个变量。mapper定义源文件和目标文件的关联方式，这里是把.js变成-min.js。\n\n生成文档的方式和压缩差不多，用的是jsdoc toolkit。偷下懒，这里就不演示了。\n\n对于我们来说，如果压缩的文件就那么两个，手动就好了。如果多了，就要用Ant了。合并的时候要注意我们的js的顺序，比如jquery一定要在bootstrap.js的前面，注意他们的依赖关系。\n\n本文的参考文章:\n\n* [明河的电子书](http://book.36ria.com/ant/index.html#index)\n* [Apache Ant手册](http://ant.apache.org/manual)\n* [Top 15 Ant Best Practices](http://www.onjava.com/pub/a/onjava/2003/12/17/ant_bestpractices.html)","mobiledoc":null,"html":"<h2 id=\"ant\">  Ant的来历</h2>\n\n<p>前段时间在学习淘宝的前端框架Kissy，在项目开发指南中看到了Ant，由于以前听过，所以来了兴趣。正如上篇文章所说，前端实践非常重要，于是就从头到尾研究起Ant来。。</p>\n\n<p>说来，Ant来自Java，是一个基于Java的build工具。和Unix/Linux c中的make工具类似，不过由于Java的原因具有跨平台的优势。那么Ant和前端有半毛线关系么？答案是，哈哈~~\n对前端来说，Ant可以</p>\n\n<ul>\n<li>合并js和css文件</li>\n<li>压缩js和css文件</li>\n<li>生成jsDOC文档</li>\n<li>连接FTP，将代码上传到指定服务器</li>\n<li>自动上传到SVN，自动打包成zip文件</li>\n<li>....</li>\n</ul>\n\n<p>当然这些都是网上抄来的，没有一一实验。喜欢的还是合并、压缩、文档，也都自己从0开始慢慢摸索了下，总结记录一下，方便对她有兴趣的朋友..</p>\n\n<h1 id=\"ant\">Ant的入门</h1>\n\n<h3 id=\"ant\">首先我们安装Ant的环境。</h3>\n\n<p>安装jdk的步骤就不细说，度娘那里有很多。</p>\n\n<p>下载Ant，传送门: <a href=\"http://apache.fayea.com/apache-mirror//ant/source/apache-ant-1.9.0-src.zip\">apache-ant-1.9.0</a></p>\n\n<p>解压到你喜欢的位置，我是F:\\apache-ant-1.9.0.</p>\n\n<p>在path里面添加：<code>F:\\apache-ant-1.9.0.\\bin</code></p>\n\n<p>在DOS里面输入ant，验证安装是否完成。出现下面的结果就算成功了。</p>\n\n<pre><code>Buildfile：build.xml does not exist! \nBuild failed\n</code></pre>\n\n<h2 id=\"\">牛刀小试</h2>\n\n<p>新建test的java项目，里面建立src目录，在src里面写一个hello.java，内容如下：</p>\n\n<pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"hello world!\");\n    }\n}\n</code></pre>\n\n<p>在test目录里面建立build.xml文件。内容如下：</p>\n\n<pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;project name =\"javacTest\" default=\"run\" basedir=\".\"&gt;\n\n    &lt;target name=\"compile\"&gt;\n        &lt;mkdir dir =\"${basedir}/build/classes\"/&gt;\n        &lt;javac srcdir =\"${basedir}/src\" destdir =\"${basedir}/build/classes\"/&gt;\n    &lt;/target&gt;\n    &lt;target name=\"run\" depends =\"compile\"&gt;\n        &lt;java classname =\"HelloWorld\"&gt;\n        &lt;classpath&gt;\n                &lt;pathelement path=\"${basedir}/build/classes\"/&gt;\n        &lt;/classpath&gt;\n        &lt;/java&gt;\n    &lt;/target&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>用命令行进入<code>test</code>目录里面，执行<code>ant</code>。你会发现<code>build</code>里面多了<code>classes</code>目录，<code>classes</code>里面多了<code>hello.class</code>。在命令行里面会有<code>hello world</code>输出。如下图：</p>\n\n<p><img src=\"/content/images/2016/07/ant.png\" alt=\"\" /></p>\n\n<p>这次不准备讲ant的api，有兴趣的童鞋可以去看<a href=\"http://ant.apache.org/manual/index.html\">官方文档</a>。这里我把遇到的讲一下，相信这样你也能掌握常见的语法了~</p>\n\n<p>上面的<code>build.xml</code>中，就是我们的主角<code>Ant</code>了。每个<code>Ant</code>都有且只能有一个<code>project</code>，多个<code>target</code>(可理解为任务块)，<code>depends=\"compile\"</code>指必须名字为compile的target先执行，他们存在依赖关系。其他的就不解释了。</p>\n\n<h2 id=\"ant\">Ant和前端。</h2>\n\n<h3 id=\"js\">合并js</h3>\n\n<p>在test目录里面建四个js文件内容依次为<code>console.log(\"hello, i am from 1/2/3/4\");</code>然后建立build.xml内容为：</p>\n\n<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;project name=\"concat\" default=\"build\"&gt;\n    &lt;property name=\"concat.note\" value=\"//合并js\" /&gt;\n    &lt;target name=\"build\"&gt;\n        &lt;echo&gt;生成src目录&lt;/echo&gt;\n        &lt;mkdir dir=\"src\"/&gt;\n        &lt;echo&gt;开始合并文件&lt;/echo&gt;\n        &lt;concat destfile=\"src/fs.js\"&gt;\n        &lt;header trimleading=\"yes\"&gt;${concat.note}\n        &lt;/header&gt;\n        &lt;path path=\"1.js\"/&gt;\n        &lt;path path=\"2.js\"/&gt;\n        &lt;path path=\"3.js\"/&gt;\n        &lt;path path=\"4.js\"/&gt;\n    &lt;/concat&gt;\n    &lt;/target&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>CMD切换到test目录，执行ant。输出</p>\n\n<p><img src=\"/content/images/2016/07/ant2.png\" alt=\"\" /></p>\n\n<p>在src里面多了fs.js文件，内容为：</p>\n\n<p><img src=\"/content/images/2016/07/concat.png\" alt=\"\" /></p>\n\n<p>现在解释上面的build.xml。property定义一个名为concat.note的变量，内容为<code>\"//合并js\"</code>，下面会用${concat.note}引用。header是给fs.js最上面加一行。下面的合并就那样，都看得懂，记住格式就好了。提示一点是header那里有换行，如果不换，自己试试后果，呵呵。</p>\n\n<p>有些童鞋就在想了，要是我有20个js，是不是要写20个path呢？当然不是！为了解决这个问题，我们的dadaType标签就闪亮登场啦~</p>\n\n<p>把path变成</p>\n\n<pre><code>&lt;pre class=\"brush:xml\"&gt;\n    &lt;fileset dir = \"./\" includes = \"**/*.js\"&gt;\n&lt;/pre&gt;\n</code></pre>\n\n<p>就可以代替20个path！dataType常用除了我们见过的fileset/path，还有我们在压缩和生成文档要用的argument。fileset还有一个常用的语句，如下：</p>\n\n<pre><code>&lt;fileset dir = \"./\"&gt;\n    &lt;include name = \"**/*.js\" if = \"test\"&gt;\n    &lt;exclude name = \"my.js\" unless = \"my\"&gt;\n&lt;/fileset&gt;\n</code></pre>\n\n<p>如果设置了test属性，读取所有js，如果没有设置my属性，则排除my.js</p>\n\n<h3 id=\"js\">压缩js</h3>\n\n<p>先下载<a href=\"http://vdisk.weibo.com/s/AjhVv\">YUICompressor</a></p>\n\n<p>运行解压过后的install.cmd。(用管理员身份运行，否则会出错哦)</p>\n\n<p>然后随便右键一个文件就就会多一个Process with YUICompressor了。</p>\n\n<p>把刚才解压的YUICompressor放到test目录中，新建一个min文件夹。把build.xml改成如下：</p>\n\n<pre><code>    &lt;?xml version=\"1.0\"?&gt;\n    &lt;project name=\"refund\" default=\"build\"&gt;\n        &lt;dirname property=\"current.dir\" file=\"${ant.file.uploader}\"/&gt;\n        &lt;property name=\"src.dir\" location=\"${current.dir}/src/\"/&gt;\n        &lt;property name=\"yuicompressor.path\" location=\"${current.dir}/yuicompressor/yuicompressor.jar\"/&gt;\n        &lt;target name=\"build\"&gt;\n            &lt;apply executable=\"java\" dest=\"${current.dir}/min\"&gt;\n            &lt;fileset dir=\"${src.dir}\" includes=\"*.js\"/&gt;\n            &lt;arg line=\"-jar\"/&gt;\n            &lt;arg path=\"${yuicompressor.path}\"/&gt;\n            &lt;arg value=\"-o\"/&gt;\n            &lt;targetfile/&gt;\n            &lt;mapper type=\"glob\" from=\"*.js\" to=\"*-min.js\"/&gt;\n            &lt;/apply&gt;\n        &lt;/target&gt;\n    &lt;/project&gt;\n</code></pre>\n\n<p>然后运行ant命令。在min文件夹里面就会出现：</p>\n\n<p><img src=\"/content/images/2016/07/min.png\" alt=\"\" /></p>\n\n<p>解释上面的build.xml.dirname用来获取文件的目录路径。注意到里面有个变量指向yuicompressor.jar，这样才能用YUICompressor。这里的arg提供给apply一些参数。-jar为YUICompressor中的.jar路径，就是刚才提到的那个变量。mapper定义源文件和目标文件的关联方式，这里是把.js变成-min.js。</p>\n\n<p>生成文档的方式和压缩差不多，用的是jsdoc toolkit。偷下懒，这里就不演示了。</p>\n\n<p>对于我们来说，如果压缩的文件就那么两个，手动就好了。如果多了，就要用Ant了。合并的时候要注意我们的js的顺序，比如jquery一定要在bootstrap.js的前面，注意他们的依赖关系。</p>\n\n<p>本文的参考文章:</p>\n\n<ul>\n<li><a href=\"http://book.36ria.com/ant/index.html#index\">明河的电子书</a></li>\n<li><a href=\"http://ant.apache.org/manual\">Apache Ant手册</a></li>\n<li><a href=\"http://www.onjava.com/pub/a/onjava/2003/12/17/ant_bestpractices.html\">Top 15 Ant Best Practices</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 08:54:29","created_by":1,"updated_at":"2016-07-19 14:10:46","updated_by":1,"published_at":"2013-05-06 08:54:00","published_by":1},{"id":109,"uuid":"18e4c0cb-28af-48b7-b36a-996e1330cf81","title":"从其他网站抓数据","slug":"grab-data-from-website-2","markdown":"## 缘由\n\n吃饭的时候和朋友聊天，谈到他上一个项目，他去抓其他网站的数据，然后用canvas画出走势图。吸引我的是前面的抓数据，以前从来没有尝试过，一定会很有意思了！\n\n## 开始\n\n听他讲大致就是用jsonp去请求，然后读取json吧。感觉这种方式不太好，因为只有目标网站提供了相应接口，才能去请求，然后解析收到的数据。\n自己尝试用jsonp去请求一些数据，于是找数据接口，不过好少。目前找到的下面几个：\n（浏览器中打开的json格式不太好看，请读者朋友把下面的json拷到\n\n[http://jsonformatter.curiousconcept.com](http://jsonformatter.curiousconcept.com)\n\n朋友项目中用到的[http://jry.baidao.com/api/hq/npdata.do](http://jry.baidao.com/api/hq/npdata.do)\n\n天气：\n\n[http://www.weather.com.cn/data/sk/101281601.html](http://www.weather.com.cn/data/sk/101281601.html)\n\n[http://www.weather.com.cn/data/cityinfo/101281601.html](http://www.weather.com.cn/data/cityinfo/101281601.html)\n\n[http://m.weather.com.cn/data/101281601.html](http://m.weather.com.cn/data/101281601.html) \n\n新浪：\n\n[https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522)  //获取公共微博注意.最后为你的appkey。\n\n[https://api.weibo.com/2/account/get_uid.json?source=1105337522](https://api.weibo.com/2/account/get_uid.json?source=1105337522) //获取授权用户UID.\n\n[https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522) //获取当前登录用户及其所关注用户的最新微博\n\n[https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522](https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522) //获取用户最新的微博\n\n豆瓣：\n\n[http://api.douban.com/v2/user/freestyle21](http://api.douban.com/v2/user/freestyle21) //获取用户信息\n\n[http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21](http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21) //获取用户时间线\n\n在用jsonp请求数据的时候，只需要把url换成上面的就可以了，然后在回调函数里面处理返回的json数据就好了。\n\n文章的标题叫做抓数据，但是到此为止好像只有请求数据，没有抓。。\n\n##然后\n\n尽管上面找的那些链接能够完成很多事情，但是，让我不爽的是提供接口的网站并不多。要是我想要虎扑上的比赛数据呢？要是我想要河畔最新的贴子呢？\n\n于是，又开始在网上找可以抓取任意网站数据的方法。在一篇文章中看到了火车头采集器，去下载了。把它的论坛上三个视频看了，感觉这个只是适合站长，不太适合普通开发者。不过功能真的是比较强大。这里不讲了，有兴趣的可以从[这里](http://bbs.locoy.com/spider-132850-1-1.html)去看下。\n\n然后接着查询。。印象中python和java比较适合干这样的事，但是对这两门语言都不太熟悉，故还是想从熟悉的东西着手。咨询几个朋友，原来php也可以抓取数据～～\n\n查看了几个例子，自己实验了一番，总结如下。\n\n## 通过fopen来读取要抓取的网页\n\n下面的例子来抓取我博客的title：\n\n      <php\n        $file = fopen (\"http://qubaoming.me/\", \"r\"); \n        if (!$file) { \n            echo \"&lt;font color=red>Unable to open remote file.&lt;/font>\\n\"; \n            exit; \n        } \n        while (!feof ($file)) { \n            $line = fgets ($file, 1024); \n            if (eregi (\"&lt;title>(.*)&lt;/title>\", $line, $out)) { \n                $title = $out[1]; \n                echo \"\".$title.\"\"; \n                break; \n            } \n        } \n        fclose($file); \n    ?>\n\n获取我博客所有代码：\n\n    <php\n        $fp = fsockopen(\"freestyle21.cn\", 80, $errno, $errstr, 30); \n        if (!$fp) { \n           echo \"$errstr ($errno)&lt;br/>\\n\"; \n        } else { \n           $out = \"GET / HTTP/1.1\\r\\n\"; \n           $out .= \"Host: freestyle21.cn \\r\\n\"; \n           $out .= \"Connection: Close \\r\\n\\r\\n\"; \n           fputs($fp, $out); \n           while (!feof($fp)) { \n             echo fgets($fp, 128); \n           } \n           fclose($fp); \n        }\n    ?>\n\n或者\n\n    <php\n        $urlstr = file_get_contents(\"http://qubaoming.me\");\n        $urlstr = htmlspecialchars($urlstr);\n        print_r($urlstr);\n    ?>\n\n## 通过curl／DOMDocument／DOMXpath抓取数据\n\n上面的那种方式或许还不能叫抓数据。因为对返回的HTML处理不够。\n然后，我们知道在php中curl可以抓取下载html（也可以模拟登录，伪装客户端等），DOMDocument可以刚刚下载的HTML加载成DOM，DOMXPath则可以使用XPath语法进行数据的定位和采集。幸运的是，对于前端来说，三个都比较熟悉，所以就比较简单了。\n\n### 抓博客中所有的链接url\n\n\t<php\n        $target_url = \"http://qubaoming.me\";\n        $ch = curl_init();\n        //执行之前，设置一些参数\n        curl_setopt($ch, CURLOPT_URL,$target_url);\n        curl_setopt($ch, CURLOPT_FAILONERROR, true);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);\n        curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n        $html = curl_exec($ch);\n        if (!$html) {\n            echo \"&lt;br />cURL error number:\" .curl_errno($ch);\n            echo \"&lt;br />cURL error:\" . curl_error($ch);\n            exit;\n        }\n        //创建一个DomDocument对象，用于处理一个HTML\n        $dom = new DOMDocument();\n        //从一个字符串加载HTML\n        @$dom->loadHTML($html);\n        //使该HTML规范化\n        $dom->normalize();\n        //用DOMXpath加载DOM，用于查询\n        $xpath = new DOMXPath($dom);\n        //获取所有的a标签的地址\n        $hrefs = $xpath->evaluate(\"/html/body//a//@href\");\n        for ($i = 0; $i &lt; $hrefs->length; $i++) {\n            $href = $hrefs->item($i);\n            $linktext = $href->nodeValue;\n            echo $linktex;\n            echo \"&lt;BR>\";\n        }\n    ?>\n\n结果如下；\n\n![](/content/images/2016/07/grab_link.png)\n\n如果想要抓取博客中的“这里记载着帅气的博主的技术成长过程，也会时而发下生活的牢骚”，这几个字，把xpath改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//h2\");\n\n如果想要抓取\"freestyle21\"几个字母，改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//a//h1\");\n\n如果想要抓去最下面的描述“一个老男人,今年22岁.一枚程序员，Web前端！一只科蜜，季后赛！”，改成：\n\n\t$hrefs = $xpath->evaluate(\"/html/body//div//ul//li\");\n\n到此，要抓取给定网页的任意数据就比较简单了，最终任务转换到解析DOM。而这，又是没有前端都擅长的～\n\n## 总结\n\n总的来说，用这篇文章中的方法抓取数据都不是最科学的，因为我们必须要读取所以的HTML，这样效率肯定比较低。最科学的方式还是不用下到本地服务器，直接读取。以后有需求了，还是学下Python和Java的抓取方式～～","mobiledoc":null,"html":"<h2 id=\"\">缘由</h2>\n\n<p>吃饭的时候和朋友聊天，谈到他上一个项目，他去抓其他网站的数据，然后用canvas画出走势图。吸引我的是前面的抓数据，以前从来没有尝试过，一定会很有意思了！</p>\n\n<h2 id=\"\">开始</h2>\n\n<p>听他讲大致就是用jsonp去请求，然后读取json吧。感觉这种方式不太好，因为只有目标网站提供了相应接口，才能去请求，然后解析收到的数据。\n自己尝试用jsonp去请求一些数据，于是找数据接口，不过好少。目前找到的下面几个：\n（浏览器中打开的json格式不太好看，请读者朋友把下面的json拷到</p>\n\n<p><a href=\"http://jsonformatter.curiousconcept.com\">http://jsonformatter.curiousconcept.com</a></p>\n\n<p>朋友项目中用到的<a href=\"http://jry.baidao.com/api/hq/npdata.do\">http://jry.baidao.com/api/hq/npdata.do</a></p>\n\n<p>天气：</p>\n\n<p><a href=\"http://www.weather.com.cn/data/sk/101281601.html\">http://www.weather.com.cn/data/sk/101281601.html</a></p>\n\n<p><a href=\"http://www.weather.com.cn/data/cityinfo/101281601.html\">http://www.weather.com.cn/data/cityinfo/101281601.html</a></p>\n\n<p><a href=\"http://m.weather.com.cn/data/101281601.html\">http://m.weather.com.cn/data/101281601.html</a> </p>\n\n<p>新浪：</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/public_timeline.json?source=1105337522</a>  //获取公共微博注意.最后为你的appkey。</p>\n\n<p><a href=\"https://api.weibo.com/2/account/get_uid.json?source=1105337522\">https://api.weibo.com/2/account/get_uid.json?source=1105337522</a> //获取授权用户UID.</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/friends_timeline.json?source=1105337522</a> //获取当前登录用户及其所关注用户的最新微博</p>\n\n<p><a href=\"https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522\">https://api.weibo.com/2/statuses/user_timeline.json?source=1105337522</a> //获取用户最新的微博</p>\n\n<p>豆瓣：</p>\n\n<p><a href=\"http://api.douban.com/v2/user/freestyle21\">http://api.douban.com/v2/user/freestyle21</a> //获取用户信息</p>\n\n<p><a href=\"http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21\">http://api.douban.com/shuo/v2/statuses/user_timeline/freestyle21</a> //获取用户时间线</p>\n\n<p>在用jsonp请求数据的时候，只需要把url换成上面的就可以了，然后在回调函数里面处理返回的json数据就好了。</p>\n\n<p>文章的标题叫做抓数据，但是到此为止好像只有请求数据，没有抓。。</p>\n\n<h2 id=\"\">然后</h2>\n\n<p>尽管上面找的那些链接能够完成很多事情，但是，让我不爽的是提供接口的网站并不多。要是我想要虎扑上的比赛数据呢？要是我想要河畔最新的贴子呢？</p>\n\n<p>于是，又开始在网上找可以抓取任意网站数据的方法。在一篇文章中看到了火车头采集器，去下载了。把它的论坛上三个视频看了，感觉这个只是适合站长，不太适合普通开发者。不过功能真的是比较强大。这里不讲了，有兴趣的可以从<a href=\"http://bbs.locoy.com/spider-132850-1-1.html\">这里</a>去看下。</p>\n\n<p>然后接着查询。。印象中python和java比较适合干这样的事，但是对这两门语言都不太熟悉，故还是想从熟悉的东西着手。咨询几个朋友，原来php也可以抓取数据～～</p>\n\n<p>查看了几个例子，自己实验了一番，总结如下。</p>\n\n<h2 id=\"fopen\">通过fopen来读取要抓取的网页</h2>\n\n<p>下面的例子来抓取我博客的title：</p>\n\n<pre><code>  &lt;php\n    $file = fopen (\"http://qubaoming.me/\", \"r\"); \n    if (!$file) { \n        echo \"&amp;lt;font color=red&gt;Unable to open remote file.&amp;lt;/font&gt;\\n\"; \n        exit; \n    } \n    while (!feof ($file)) { \n        $line = fgets ($file, 1024); \n        if (eregi (\"&amp;lt;title&gt;(.*)&amp;lt;/title&gt;\", $line, $out)) { \n            $title = $out[1]; \n            echo \"\".$title.\"\"; \n            break; \n        } \n    } \n    fclose($file); \n?&gt;\n</code></pre>\n\n<p>获取我博客所有代码：</p>\n\n<pre><code>&lt;php\n    $fp = fsockopen(\"freestyle21.cn\", 80, $errno, $errstr, 30); \n    if (!$fp) { \n       echo \"$errstr ($errno)&amp;lt;br/&gt;\\n\"; \n    } else { \n       $out = \"GET / HTTP/1.1\\r\\n\"; \n       $out .= \"Host: freestyle21.cn \\r\\n\"; \n       $out .= \"Connection: Close \\r\\n\\r\\n\"; \n       fputs($fp, $out); \n       while (!feof($fp)) { \n         echo fgets($fp, 128); \n       } \n       fclose($fp); \n    }\n?&gt;\n</code></pre>\n\n<p>或者</p>\n\n<pre><code>&lt;php\n    $urlstr = file_get_contents(\"http://qubaoming.me\");\n    $urlstr = htmlspecialchars($urlstr);\n    print_r($urlstr);\n?&gt;\n</code></pre>\n\n<h2 id=\"curldomdocumentdomxpath\">通过curl／DOMDocument／DOMXpath抓取数据</h2>\n\n<p>上面的那种方式或许还不能叫抓数据。因为对返回的HTML处理不够。\n然后，我们知道在php中curl可以抓取下载html（也可以模拟登录，伪装客户端等），DOMDocument可以刚刚下载的HTML加载成DOM，DOMXPath则可以使用XPath语法进行数据的定位和采集。幸运的是，对于前端来说，三个都比较熟悉，所以就比较简单了。</p>\n\n<h3 id=\"url\">抓博客中所有的链接url</h3>\n\n<pre><code>&lt;php\n    $target_url = \"http://qubaoming.me\";\n    $ch = curl_init();\n    //执行之前，设置一些参数\n    curl_setopt($ch, CURLOPT_URL,$target_url);\n    curl_setopt($ch, CURLOPT_FAILONERROR, true);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_AUTOREFERER, true);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);\n    curl_setopt($ch, CURLOPT_TIMEOUT, 10);\n    $html = curl_exec($ch);\n    if (!$html) {\n        echo \"&amp;lt;br /&gt;cURL error number:\" .curl_errno($ch);\n        echo \"&amp;lt;br /&gt;cURL error:\" . curl_error($ch);\n        exit;\n    }\n    //创建一个DomDocument对象，用于处理一个HTML\n    $dom = new DOMDocument();\n    //从一个字符串加载HTML\n    @$dom-&gt;loadHTML($html);\n    //使该HTML规范化\n    $dom-&gt;normalize();\n    //用DOMXpath加载DOM，用于查询\n    $xpath = new DOMXPath($dom);\n    //获取所有的a标签的地址\n    $hrefs = $xpath-&gt;evaluate(\"/html/body//a//@href\");\n    for ($i = 0; $i &amp;lt; $hrefs-&gt;length; $i++) {\n        $href = $hrefs-&gt;item($i);\n        $linktext = $href-&gt;nodeValue;\n        echo $linktex;\n        echo \"&amp;lt;BR&gt;\";\n    }\n?&gt;\n</code></pre>\n\n<p>结果如下；</p>\n\n<p><img src=\"/content/images/2016/07/grab_link.png\" alt=\"\" /></p>\n\n<p>如果想要抓取博客中的“这里记载着帅气的博主的技术成长过程，也会时而发下生活的牢骚”，这几个字，把xpath改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//h2\");\n</code></pre>\n\n<p>如果想要抓取\"freestyle21\"几个字母，改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//a//h1\");\n</code></pre>\n\n<p>如果想要抓去最下面的描述“一个老男人,今年22岁.一枚程序员，Web前端！一只科蜜，季后赛！”，改成：</p>\n\n<pre><code>$hrefs = $xpath-&gt;evaluate(\"/html/body//div//ul//li\");\n</code></pre>\n\n<p>到此，要抓取给定网页的任意数据就比较简单了，最终任务转换到解析DOM。而这，又是没有前端都擅长的～</p>\n\n<h2 id=\"\">总结</h2>\n\n<p>总的来说，用这篇文章中的方法抓取数据都不是最科学的，因为我们必须要读取所以的HTML，这样效率肯定比较低。最科学的方式还是不用下到本地服务器，直接读取。以后有需求了，还是学下Python和Java的抓取方式～～</p>","image":"/content/images/2016/07/aa-2.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 14:19:55","created_by":1,"updated_at":"2016-07-19 14:11:19","updated_by":1,"published_at":"2013-05-04 14:19:00","published_by":1},{"id":110,"uuid":"8d653c85-9128-4f78-897d-64df8ace5df8","title":"路","slug":"road-2","markdown":"最近周围各种浮躁。\n\n工作、考研、出国，三择一，似乎每个大三的都要经历。虽然很早就决定了要工作，做喜欢的事，但也不免被这种世风所打扰。考研的寝室静不下，白天补习班，晚上继续游戏。工作的找实习，重拾基础，笔试题做到晚，简历投起。每天忙到晚，最后都不明白自己到底做了什么，曾经的那个梦哪去了？\n\n在夜深的时候，总是空虚的在想，自己到底在干什么，离自己的梦，是越近，还是越远？\n\n在迷茫的时候，总要停顿下来，思考自己所处的位置。\n\n升高中，老师说哪好，就去哪。大学，那个心碎的暑假，好像是老妈，决定了现在这个学校，至于专业更是由分数决定，甚至连是干嘛的都不知道。大一，周围的人都学技术，就跟风的和百川一起开始用DW拖页面，然后写android。一路走来，貌似都是由环境决定自己的路，呵呵，真悲剧。\n\n所幸，嫁对郎。\n\n进了梦飞，才真正认识了前端。很久以前，也和所有人一样，觉得前端就是一堆HTML和CSS、加点脚本的组合体，呵呵。有次和学长聊天，问我以后准备做什么，我说web前端。现在都还能想起他那复杂的表情，甚至有立马把我收入门下，做嵌入式的感觉。我只能呵呵，无力吐槽。不深入了解，就妄做判断的，都是对自己的不负责任。\n\n对于前端，只有深入了解，才能感受她的魅力。她交织着感性与理性，蕴含着广度和深度。要了解她，你必须有细腻的情感，有扎实的基础知识，有不定时发作的强迫症，有非常的逻辑思维，有迷恋新技术的固执，有源源不断的激情。试问，有几个人能做到？\n\n一入前端深似海。当你学习了html、css、js，你会发现还有jQuery、backbone、Bootstrap框架等方便一些，学了框架你会发现还有性能、可维护等比较难办，考虑了这些后你发现模块化、异步I/O等才是真正吸引你的....最后你发现这些离你想要的，所心动的还是那么远，又继续出发。所以，前端是一个你懂的越多，不懂的就越多的行业！\n\n前两天，爸妈和老姐也在询问以后的打算。因为一个亲戚儿子烟酒僧进国企，逆袭为省城人。还有也不知道谁和谁，给他们说考研怎么样怎么样，小本出去一无是处。接着他们便是轮流的教育，外面的世界不是想象的那么简单，继续读研去国企，才有保障。但是，不想和他们解释，这一次，我要自己做决定。\n\n最喜欢高三时不晓得哪个班的横幅：既然选择了远方，便只顾风雨兼程。\n\n回想一路走来，那么多人相伴。微博上Avenir、cohlint、Steve...。UESTC前端群里面一群文艺基情水人，前端乱炖里f2er的千姿百态，dreamfly的基羊、kerry、harold、Eddie、sumous、lmh3、wxp、unasm。还有颖姐，小马。或许10年以后，不会记得名字，但能相识已经满足。\n\n啰嗦了这么多，平静多了。\n\n工作之前，要多看点博客、好的文章，上课看经典的cs、js书，空了多研究点新的东西，有想法了把博客做好看点。","mobiledoc":null,"html":"<p>最近周围各种浮躁。</p>\n\n<p>工作、考研、出国，三择一，似乎每个大三的都要经历。虽然很早就决定了要工作，做喜欢的事，但也不免被这种世风所打扰。考研的寝室静不下，白天补习班，晚上继续游戏。工作的找实习，重拾基础，笔试题做到晚，简历投起。每天忙到晚，最后都不明白自己到底做了什么，曾经的那个梦哪去了？</p>\n\n<p>在夜深的时候，总是空虚的在想，自己到底在干什么，离自己的梦，是越近，还是越远？</p>\n\n<p>在迷茫的时候，总要停顿下来，思考自己所处的位置。</p>\n\n<p>升高中，老师说哪好，就去哪。大学，那个心碎的暑假，好像是老妈，决定了现在这个学校，至于专业更是由分数决定，甚至连是干嘛的都不知道。大一，周围的人都学技术，就跟风的和百川一起开始用DW拖页面，然后写android。一路走来，貌似都是由环境决定自己的路，呵呵，真悲剧。</p>\n\n<p>所幸，嫁对郎。</p>\n\n<p>进了梦飞，才真正认识了前端。很久以前，也和所有人一样，觉得前端就是一堆HTML和CSS、加点脚本的组合体，呵呵。有次和学长聊天，问我以后准备做什么，我说web前端。现在都还能想起他那复杂的表情，甚至有立马把我收入门下，做嵌入式的感觉。我只能呵呵，无力吐槽。不深入了解，就妄做判断的，都是对自己的不负责任。</p>\n\n<p>对于前端，只有深入了解，才能感受她的魅力。她交织着感性与理性，蕴含着广度和深度。要了解她，你必须有细腻的情感，有扎实的基础知识，有不定时发作的强迫症，有非常的逻辑思维，有迷恋新技术的固执，有源源不断的激情。试问，有几个人能做到？</p>\n\n<p>一入前端深似海。当你学习了html、css、js，你会发现还有jQuery、backbone、Bootstrap框架等方便一些，学了框架你会发现还有性能、可维护等比较难办，考虑了这些后你发现模块化、异步I/O等才是真正吸引你的....最后你发现这些离你想要的，所心动的还是那么远，又继续出发。所以，前端是一个你懂的越多，不懂的就越多的行业！</p>\n\n<p>前两天，爸妈和老姐也在询问以后的打算。因为一个亲戚儿子烟酒僧进国企，逆袭为省城人。还有也不知道谁和谁，给他们说考研怎么样怎么样，小本出去一无是处。接着他们便是轮流的教育，外面的世界不是想象的那么简单，继续读研去国企，才有保障。但是，不想和他们解释，这一次，我要自己做决定。</p>\n\n<p>最喜欢高三时不晓得哪个班的横幅：既然选择了远方，便只顾风雨兼程。</p>\n\n<p>回想一路走来，那么多人相伴。微博上Avenir、cohlint、Steve...。UESTC前端群里面一群文艺基情水人，前端乱炖里f2er的千姿百态，dreamfly的基羊、kerry、harold、Eddie、sumous、lmh3、wxp、unasm。还有颖姐，小马。或许10年以后，不会记得名字，但能相识已经满足。</p>\n\n<p>啰嗦了这么多，平静多了。</p>\n\n<p>工作之前，要多看点博客、好的文章，上课看经典的cs、js书，空了多研究点新的东西，有想法了把博客做好看点。</p>","image":"/content/images/2016/07/e.jpg","featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-07-09 14:38:06","created_by":1,"updated_at":"2016-07-19 14:28:04","updated_by":1,"published_at":"2013-03-27 14:38:00","published_by":1}],"users":[{"id":1,"uuid":"94509a69-7a26-4bff-8673-9260b3cc8490","name":"qubaoming","slug":"qubaoming","password":"$2a$10$D3trxfnOS.jIxj3WZPH.NuffZn2Ut.vNw4LvvJQePpi8TtnoiDWbi","email":"675861708@qq.com","image":"/content/images/2016/07/1-pic_hd-copy.jpg","cover":null,"bio":null,"website":null,"location":null,"facebook":null,"twitter":null,"accessibility":null,"status":"active","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_login":"2016-07-21 13:35:22","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:22","updated_by":1}],"roles":[{"id":1,"uuid":"2b355a43-7e09-4aed-857e-0b8d7c06ad61","name":"Administrator","description":"Administrators","created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":2,"uuid":"7b9aa98c-ba7e-4fc0-9779-97ee146382de","name":"Editor","description":"Editors","created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":3,"uuid":"0ece7990-a821-4bb7-a3f0-5820b3091aa7","name":"Author","description":"Authors","created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":4,"uuid":"af3a5dea-3d7f-46aa-8f13-c14c61060206","name":"Owner","description":"Blog Owner","created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":1,"uuid":"fdd513c9-217f-40ec-a323-e71b00ae5c9f","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":2,"uuid":"0af3698c-95e1-4c04-8d6c-e7503c4092a3","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":3,"uuid":"fc8c634e-a0c4-4f39-903f-a94b2dc0eb87","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":4,"uuid":"a6e1bc98-3e0b-4434-8a53-d362f8e72531","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":5,"uuid":"384922fc-075d-4817-8bb6-bcc87a925ba6","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":6,"uuid":"9ea94d1c-ff97-41ec-b687-9f26b8c6fe37","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":7,"uuid":"5dd51e48-c69f-440d-a573-30b7b7012d03","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":8,"uuid":"3fc8d226-f734-4d61-a1fc-2e4450e75fff","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":9,"uuid":"ab252761-eaef-44b3-9b4e-c543715d8173","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":10,"uuid":"1562824b-8d52-4061-8c36-74da2eab6e47","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":11,"uuid":"f63f6af9-81bb-4064-a9c9-521cbfa8b5db","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":12,"uuid":"0d9f736a-9e93-4dc8-9552-498c2ab78e3f","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:00","created_by":1,"updated_at":"2016-07-11 03:49:00","updated_by":1},{"id":13,"uuid":"abc39882-c06c-43d6-95d7-acbc06e6d25b","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":14,"uuid":"60929174-90a5-4bb9-a199-c8f55a60ab99","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":15,"uuid":"407aa062-0bec-4423-95df-a4dda1163698","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":16,"uuid":"6138c2db-b5ba-4fd4-80a3-9b6201d0bb4b","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":17,"uuid":"acefa48c-7317-4ef2-ad8c-b1efef33475c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":18,"uuid":"9abe5f6e-ba87-447a-a13c-e1e8c45ffbae","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":19,"uuid":"585779e8-fe76-44cb-9f49-5bac20ead998","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":20,"uuid":"1638ce67-6394-43c1-8e4c-701f1c8bf5ac","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":21,"uuid":"3795fa0e-9846-4f57-81ca-60c3c41b83f5","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":22,"uuid":"01247d48-5b87-4995-b558-f366ae218be9","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":23,"uuid":"84192060-1d73-4cbf-a860-055904f51f30","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":24,"uuid":"4c9a63f9-0527-4134-aaea-c44894df4746","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":25,"uuid":"b219336f-a85a-4435-8cc8-8f8f058762f4","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":26,"uuid":"13ce07a3-19cf-4439-9de3-d783e4fd1205","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":27,"uuid":"cd259d88-e06d-441d-bbfb-b62d9d512bd1","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":28,"uuid":"69605bf2-da1e-4ed1-bb48-a7e8e651f7a6","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":29,"uuid":"acdd762f-f6eb-484c-bd28-88ac86e54423","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":30,"uuid":"928a876a-5b9a-492a-b829-d5e9af46e5cb","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":31,"uuid":"4def5280-faeb-4b4e-8062-04be854a7de2","name":"Browse clients","object_type":"client","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":32,"uuid":"ff8ae776-21b2-4873-9546-41c553621f3f","name":"Read clients","object_type":"client","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":33,"uuid":"facdbd49-e303-4536-90b1-036c40bbbb42","name":"Edit clients","object_type":"client","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":34,"uuid":"f7d2b819-48f2-4c2d-8c2a-2ba66b66001d","name":"Add clients","object_type":"client","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":35,"uuid":"93f9bdf0-a115-4a87-8da9-fe236835ddf4","name":"Delete clients","object_type":"client","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":36,"uuid":"04be71f2-6bfb-4cf2-9335-d2c14f0e2035","name":"Browse subscribers","object_type":"subscriber","action_type":"browse","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":37,"uuid":"3f0c5384-c23a-4eee-92ab-53621a305fbb","name":"Read subscribers","object_type":"subscriber","action_type":"read","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":38,"uuid":"bc9b9b09-275c-4314-ab85-9531425c65c5","name":"Edit subscribers","object_type":"subscriber","action_type":"edit","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":39,"uuid":"dcd3867c-8507-4ae9-9097-bd0aa38f3f04","name":"Add subscribers","object_type":"subscriber","action_type":"add","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1},{"id":40,"uuid":"d679a821-4f7c-4443-a3c2-a45c1c8f3d3f","name":"Delete subscribers","object_type":"subscriber","action_type":"destroy","object_id":null,"created_at":"2016-07-11 03:49:01","created_by":1,"updated_at":"2016-07-11 03:49:01","updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":1,"permission_id":31},{"id":32,"role_id":1,"permission_id":32},{"id":33,"role_id":1,"permission_id":33},{"id":34,"role_id":1,"permission_id":34},{"id":35,"role_id":1,"permission_id":35},{"id":36,"role_id":1,"permission_id":36},{"id":37,"role_id":1,"permission_id":37},{"id":38,"role_id":1,"permission_id":38},{"id":39,"role_id":1,"permission_id":39},{"id":40,"role_id":1,"permission_id":40},{"id":41,"role_id":2,"permission_id":8},{"id":42,"role_id":2,"permission_id":9},{"id":43,"role_id":2,"permission_id":10},{"id":44,"role_id":2,"permission_id":11},{"id":45,"role_id":2,"permission_id":12},{"id":46,"role_id":2,"permission_id":13},{"id":47,"role_id":2,"permission_id":14},{"id":48,"role_id":2,"permission_id":16},{"id":49,"role_id":2,"permission_id":17},{"id":50,"role_id":2,"permission_id":18},{"id":51,"role_id":2,"permission_id":19},{"id":52,"role_id":2,"permission_id":20},{"id":53,"role_id":2,"permission_id":21},{"id":54,"role_id":2,"permission_id":24},{"id":55,"role_id":2,"permission_id":25},{"id":56,"role_id":2,"permission_id":26},{"id":57,"role_id":2,"permission_id":27},{"id":58,"role_id":2,"permission_id":28},{"id":59,"role_id":2,"permission_id":29},{"id":60,"role_id":2,"permission_id":30},{"id":61,"role_id":2,"permission_id":31},{"id":62,"role_id":2,"permission_id":32},{"id":63,"role_id":2,"permission_id":33},{"id":64,"role_id":2,"permission_id":34},{"id":65,"role_id":2,"permission_id":35},{"id":66,"role_id":2,"permission_id":39},{"id":67,"role_id":3,"permission_id":8},{"id":68,"role_id":3,"permission_id":9},{"id":69,"role_id":3,"permission_id":11},{"id":70,"role_id":3,"permission_id":13},{"id":71,"role_id":3,"permission_id":14},{"id":72,"role_id":3,"permission_id":16},{"id":73,"role_id":3,"permission_id":17},{"id":74,"role_id":3,"permission_id":18},{"id":75,"role_id":3,"permission_id":20},{"id":76,"role_id":3,"permission_id":24},{"id":77,"role_id":3,"permission_id":25},{"id":78,"role_id":3,"permission_id":30},{"id":79,"role_id":3,"permission_id":31},{"id":80,"role_id":3,"permission_id":32},{"id":81,"role_id":3,"permission_id":33},{"id":82,"role_id":3,"permission_id":34},{"id":83,"role_id":3,"permission_id":35},{"id":84,"role_id":3,"permission_id":39}],"permissions_apps":[],"settings":[{"id":1,"uuid":"4bda31ba-109e-4117-aefd-fb8fba5d644c","key":"databaseVersion","value":"006","type":"core","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-11 03:49:03","updated_by":1},{"id":2,"uuid":"7b8f1469-5095-4fe4-972a-03589227b07a","key":"dbHash","value":"ae9fc4e7-9ea9-4550-ab57-b7d07c913106","type":"core","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-11 03:49:04","updated_by":1},{"id":3,"uuid":"f34538fb-27ad-4b2e-9c77-8fcd0f5a8b0a","key":"nextUpdateCheck","value":"1469194362","type":"core","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:32:41","updated_by":1},{"id":4,"uuid":"c176fdb4-895e-4867-8f42-20aefb0c8966","key":"displayUpdateNotification","value":"0.8.0","type":"core","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:32:41","updated_by":1},{"id":5,"uuid":"b8f2161c-6d12-40ab-9f2f-f2d07e690197","key":"migrations","value":"{}","type":"core","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-11 03:49:03","updated_by":1},{"id":6,"uuid":"110f2fb5-bc7e-44b3-b45d-874bd2df1acf","key":"title","value":"qubaoming's home","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":7,"uuid":"2f00247f-256d-4580-8bee-69db4ae46eff","key":"description","value":"The Road To Modern F2eer.","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":8,"uuid":"d89c4ea5-a62b-49c6-9fbc-beece9d7fccb","key":"logo","value":"/content/images/2016/07/aa.png","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":9,"uuid":"25bbd572-5cf4-4910-8bdd-884d5e3f9a10","key":"cover","value":"/content/images/2016/06/c9e42240-1.jpg","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":10,"uuid":"d8665cdb-408b-4ea3-b329-32859f1cd0b4","key":"defaultLang","value":"en_US","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":11,"uuid":"cd003c90-2ed6-49a9-bff0-a3fa957359bd","key":"postsPerPage","value":"5","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":12,"uuid":"3d03b4fa-7041-41ed-913c-bad19f391427","key":"activeTimezone","value":"Etc/UTC","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":13,"uuid":"f552bf66-7458-4bea-9265-573f6b7da509","key":"forceI18n","value":"true","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":14,"uuid":"5389d933-e0a9-4913-b0b4-1241797d9159","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":15,"uuid":"7806941b-d909-4dd6-84c2-cde86fbfb96e","key":"ghost_head","value":"","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":16,"uuid":"b2fb4f01-040b-4c88-be2d-2dfddbf58fe1","key":"ghost_foot","value":"","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":17,"uuid":"7ccf3a70-ed4b-41dd-8f01-f95b2c151707","key":"facebook","value":"","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":18,"uuid":"3bea7eb6-fb05-4b24-b8a6-3a862cdb07eb","key":"twitter","value":"","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":19,"uuid":"d2a3ba3d-3c29-4c53-883e-010c6e1ed344","key":"labs","value":"{}","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":20,"uuid":"8cfad5f9-d536-422e-afc7-703c3e7a03c0","key":"navigation","value":"[{\"label\":\"主页\",\"url\":\"/\"},{\"label\":\"前端\",\"url\":\"/tag/javascript/\"},{\"label\":\"拳击\",\"url\":\"/tag/boxing/\"},{\"label\":\"篮球\",\"url\":\"/tag/basekebal/\"},{\"label\":\"生活\",\"url\":\"http://local.xiaojukeji.com/tag/life\"},{\"label\":\"关于\",\"url\":\"/about/\"}]","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":21,"uuid":"e5b8b66b-9438-450b-88fe-b5f58a9a8b8d","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":22,"uuid":"37d3803b-4a3d-46e4-b4ed-e8b047d4b2a6","key":"activeApps","value":"[]","type":"app","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":23,"uuid":"92f115d3-91bb-4be2-8bfd-7298f3aeccbc","key":"installedApps","value":"[]","type":"app","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":24,"uuid":"c1811913-6906-4b15-b0bb-5ff9e288abbe","key":"isPrivate","value":"false","type":"private","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":25,"uuid":"4f46d3af-2016-4b77-a2ef-43fe7d37b592","key":"password","value":"","type":"private","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-21 13:35:52","updated_by":1},{"id":26,"uuid":"a44a2d5c-bc67-4289-ae2a-fc7aeaab883a","key":"activeTheme","value":"andydoyle","type":"theme","created_at":"2016-07-11 03:49:03","created_by":1,"updated_at":"2016-07-12 00:36:37","updated_by":1}],"tags":[{"id":35,"uuid":"362d6852-deda-4c00-841e-a8dc50745e2f","name":"Getting Started","slug":"getting-started","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":36,"uuid":"02b7b00f-e80b-44c7-ac8b-48583ca53b94","name":"javascript","slug":"javascript","description":"","image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":37,"uuid":"da71ee96-646f-487b-877d-4a88edaf18e3","name":"css","slug":"css","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":38,"uuid":"ddd31265-1098-43e8-8406-720113887d2f","name":"jquery","slug":"jquery","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":39,"uuid":"0741f2fb-ad46-4388-9d78-0f3d7ecf9752","name":"jekyll","slug":"jekyll","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":40,"uuid":"7ef8ee8d-f6d2-4155-b754-27f4974e462f","name":"chrome","slug":"chrome","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":41,"uuid":"2320fb9b-c5c7-4098-89a2-4030dddc5091","name":"weixin","slug":"weixin","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":42,"uuid":"b66ab905-3843-4460-ab03-57f37486ac42","name":"性能优化","slug":"xing-neng-you-hua","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":43,"uuid":"961628ef-468c-4f54-a3b1-28cd146b06ef","name":"f2e","slug":"f2e","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":44,"uuid":"b0284e20-2d49-4bf9-950e-e7c75d153743","name":"framework","slug":"framework","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":45,"uuid":"4c62529a-4142-4466-88c0-ea36f94980fc","name":"screenshot","slug":"screenshot","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":46,"uuid":"5cba870c-715e-4823-bff4-48aa0cdb903c","name":"山顶角","slug":"shan-ding-jiao","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":47,"uuid":"2036bab6-cf4a-4ba6-adb2-5877ec181125","name":"auth","slug":"auth","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":48,"uuid":"53844ba8-0a65-4c1e-b837-98406c07773a","name":"react","slug":"react","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":49,"uuid":"c3733484-71ce-4ac5-8f00-ed5c2b578d94","name":"magicline-nav","slug":"magicline-nav","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":50,"uuid":"eab21bce-4876-4980-a28c-719c39b2a0ec","name":"tinymce","slug":"tinymce","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":51,"uuid":"ffd3b58c-3fc9-4a75-b1e5-53dc3730293e","name":"css-component","slug":"css-component","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":52,"uuid":"6af0383a-3f49-4551-b507-0194b31a2a48","name":"process","slug":"process","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":53,"uuid":"9148edc5-803d-452f-87dc-34c091c6ad90","name":"algorithm","slug":"algorithm","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":54,"uuid":"389d1045-89d1-4c64-b7a9-447a6ac37815","name":"macos","slug":"macos","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":55,"uuid":"3685cb56-d2ff-41d1-b798-25c7a6e83199","name":"life","slug":"life","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":56,"uuid":"53afff22-231b-4f5f-84ef-b3250db441c2","name":"backbone","slug":"backbone","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":57,"uuid":"920aec9f-fce5-4895-8eda-076916c348c9","name":"cocos2d","slug":"cocos2d","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":58,"uuid":"8d93eba0-0be7-4920-a7df-6831e8e28f18","name":"weinre","slug":"weinre","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":59,"uuid":"884fdbb3-dd13-4c92-a73a-ea84c5c8bf11","name":"adb","slug":"adb","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":60,"uuid":"0678e4ae-5c58-4668-8309-58b5474561ae","name":"grunt","slug":"grunt","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":61,"uuid":"051d2d0b-f12d-4d34-9555-9fd26666eac6","name":"grunt-2x","slug":"grunt-2x","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":62,"uuid":"0813b9d2-5193-46c5-b226-28987c3013ba","name":"居中","slug":"ju-zhong","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":63,"uuid":"8f39aff7-a5bb-41e5-ab35-53c4b6f9ae29","name":"canvas","slug":"canvas","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":64,"uuid":"b1142455-6bdd-4c88-8d63-526958a4ea4d","name":"animation","slug":"animation","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":65,"uuid":"593cde30-8393-49ef-bc16-90595c512559","name":"upload","slug":"upload","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":66,"uuid":"98ff4e73-bc54-4bc3-853c-a0b03d03cc69","name":"cross-origin","slug":"cross-origin","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":67,"uuid":"7d30d148-6590-4c62-8771-cb6db70b1621","name":"ant","slug":"ant","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":68,"uuid":"79b3e8c3-c2f6-4248-9cb4-b2096adc45aa","name":"f2e-build","slug":"f2e-build","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":69,"uuid":"1dedeb56-1eae-4648-87c5-56dff2642e62","name":"seajs","slug":"seajs","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-17 08:38:52","created_by":1,"updated_at":"2016-07-17 08:38:52","updated_by":1},{"id":70,"uuid":"7fbf2867-a36a-4b9a-81cb-eade69de7bea","name":"前端","slug":"qian-duan","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-21 13:35:50","created_by":1,"updated_at":"2016-07-21 13:35:50","updated_by":1},{"id":71,"uuid":"37d6749f-b0c8-4d7a-bd5a-798484fb43ee","name":"生活","slug":"sheng-huo","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-21 13:35:50","created_by":1,"updated_at":"2016-07-21 13:35:50","updated_by":1},{"id":72,"uuid":"6745ffc0-651c-4164-b74e-889b12d15f0c","name":"about","slug":"about","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2016-07-21 13:35:50","created_by":1,"updated_at":"2016-07-21 13:35:50","updated_by":1}],"posts_tags":[{"id":49,"post_id":38,"tag_id":36,"sort_order":0},{"id":50,"post_id":39,"tag_id":40,"sort_order":0},{"id":51,"post_id":41,"tag_id":39,"sort_order":0},{"id":52,"post_id":42,"tag_id":36,"sort_order":0},{"id":53,"post_id":43,"tag_id":36,"sort_order":0},{"id":54,"post_id":44,"tag_id":36,"sort_order":0},{"id":55,"post_id":45,"tag_id":37,"sort_order":0},{"id":56,"post_id":46,"tag_id":36,"sort_order":0},{"id":57,"post_id":47,"tag_id":42,"sort_order":0},{"id":58,"post_id":48,"tag_id":44,"sort_order":0},{"id":59,"post_id":49,"tag_id":45,"sort_order":0},{"id":60,"post_id":50,"tag_id":37,"sort_order":0},{"id":61,"post_id":51,"tag_id":36,"sort_order":0},{"id":62,"post_id":52,"tag_id":48,"sort_order":0},{"id":63,"post_id":53,"tag_id":37,"sort_order":0},{"id":64,"post_id":54,"tag_id":50,"sort_order":0},{"id":65,"post_id":55,"tag_id":51,"sort_order":0},{"id":66,"post_id":56,"tag_id":53,"sort_order":0},{"id":67,"post_id":57,"tag_id":54,"sort_order":0},{"id":68,"post_id":58,"tag_id":55,"sort_order":0},{"id":69,"post_id":59,"tag_id":55,"sort_order":0},{"id":70,"post_id":60,"tag_id":36,"sort_order":0},{"id":71,"post_id":61,"tag_id":69,"sort_order":0},{"id":72,"post_id":63,"tag_id":57,"sort_order":0},{"id":73,"post_id":64,"tag_id":58,"sort_order":0},{"id":74,"post_id":65,"tag_id":60,"sort_order":0},{"id":75,"post_id":66,"tag_id":37,"sort_order":0},{"id":76,"post_id":67,"tag_id":55,"sort_order":0},{"id":77,"post_id":68,"tag_id":63,"sort_order":0},{"id":78,"post_id":69,"tag_id":65,"sort_order":0},{"id":79,"post_id":70,"tag_id":36,"sort_order":0},{"id":80,"post_id":71,"tag_id":67,"sort_order":0},{"id":81,"post_id":72,"tag_id":36,"sort_order":0},{"id":82,"post_id":73,"tag_id":55,"sort_order":0},{"id":83,"post_id":42,"tag_id":38,"sort_order":1},{"id":84,"post_id":46,"tag_id":41,"sort_order":1},{"id":85,"post_id":47,"tag_id":43,"sort_order":1},{"id":86,"post_id":50,"tag_id":46,"sort_order":1},{"id":87,"post_id":51,"tag_id":47,"sort_order":1},{"id":88,"post_id":53,"tag_id":49,"sort_order":1},{"id":89,"post_id":55,"tag_id":52,"sort_order":1},{"id":90,"post_id":60,"tag_id":56,"sort_order":1},{"id":91,"post_id":64,"tag_id":59,"sort_order":1},{"id":92,"post_id":65,"tag_id":61,"sort_order":1},{"id":93,"post_id":66,"tag_id":62,"sort_order":1},{"id":94,"post_id":68,"tag_id":64,"sort_order":1},{"id":95,"post_id":70,"tag_id":66,"sort_order":1},{"id":96,"post_id":71,"tag_id":68,"sort_order":1},{"id":97,"post_id":74,"tag_id":72,"sort_order":0},{"id":98,"post_id":75,"tag_id":36,"sort_order":0},{"id":99,"post_id":76,"tag_id":40,"sort_order":0},{"id":100,"post_id":77,"tag_id":70,"sort_order":0},{"id":101,"post_id":78,"tag_id":39,"sort_order":0},{"id":102,"post_id":79,"tag_id":36,"sort_order":0},{"id":103,"post_id":80,"tag_id":36,"sort_order":0},{"id":104,"post_id":81,"tag_id":36,"sort_order":0},{"id":105,"post_id":82,"tag_id":37,"sort_order":0},{"id":106,"post_id":83,"tag_id":36,"sort_order":0},{"id":107,"post_id":84,"tag_id":42,"sort_order":0},{"id":108,"post_id":85,"tag_id":44,"sort_order":0},{"id":109,"post_id":86,"tag_id":45,"sort_order":0},{"id":110,"post_id":87,"tag_id":37,"sort_order":0},{"id":111,"post_id":88,"tag_id":36,"sort_order":0},{"id":112,"post_id":89,"tag_id":48,"sort_order":0},{"id":113,"post_id":90,"tag_id":37,"sort_order":0},{"id":114,"post_id":91,"tag_id":50,"sort_order":0},{"id":115,"post_id":92,"tag_id":51,"sort_order":0},{"id":116,"post_id":93,"tag_id":53,"sort_order":0},{"id":117,"post_id":94,"tag_id":54,"sort_order":0},{"id":118,"post_id":95,"tag_id":55,"sort_order":0},{"id":119,"post_id":96,"tag_id":55,"sort_order":0},{"id":120,"post_id":97,"tag_id":36,"sort_order":0},{"id":121,"post_id":98,"tag_id":69,"sort_order":0},{"id":122,"post_id":99,"tag_id":55,"sort_order":0},{"id":123,"post_id":100,"tag_id":57,"sort_order":0},{"id":124,"post_id":101,"tag_id":58,"sort_order":0},{"id":125,"post_id":102,"tag_id":60,"sort_order":0},{"id":126,"post_id":103,"tag_id":37,"sort_order":0},{"id":127,"post_id":104,"tag_id":55,"sort_order":0},{"id":128,"post_id":105,"tag_id":63,"sort_order":0},{"id":129,"post_id":106,"tag_id":65,"sort_order":0},{"id":130,"post_id":107,"tag_id":36,"sort_order":0},{"id":131,"post_id":108,"tag_id":67,"sort_order":0},{"id":132,"post_id":109,"tag_id":36,"sort_order":0},{"id":133,"post_id":110,"tag_id":55,"sort_order":0},{"id":134,"post_id":75,"tag_id":70,"sort_order":1},{"id":135,"post_id":76,"tag_id":70,"sort_order":1},{"id":136,"post_id":78,"tag_id":70,"sort_order":1},{"id":137,"post_id":79,"tag_id":38,"sort_order":1},{"id":138,"post_id":80,"tag_id":70,"sort_order":1},{"id":139,"post_id":81,"tag_id":70,"sort_order":1},{"id":140,"post_id":82,"tag_id":70,"sort_order":1},{"id":141,"post_id":83,"tag_id":41,"sort_order":1},{"id":142,"post_id":84,"tag_id":70,"sort_order":1},{"id":143,"post_id":85,"tag_id":70,"sort_order":1},{"id":144,"post_id":86,"tag_id":70,"sort_order":1},{"id":145,"post_id":87,"tag_id":46,"sort_order":1},{"id":146,"post_id":88,"tag_id":47,"sort_order":1},{"id":147,"post_id":89,"tag_id":70,"sort_order":1},{"id":148,"post_id":90,"tag_id":49,"sort_order":1},{"id":149,"post_id":91,"tag_id":70,"sort_order":1},{"id":150,"post_id":92,"tag_id":52,"sort_order":1},{"id":151,"post_id":93,"tag_id":70,"sort_order":1},{"id":152,"post_id":94,"tag_id":55,"sort_order":1},{"id":153,"post_id":96,"tag_id":70,"sort_order":1},{"id":154,"post_id":97,"tag_id":56,"sort_order":1},{"id":155,"post_id":98,"tag_id":70,"sort_order":1},{"id":156,"post_id":100,"tag_id":70,"sort_order":1},{"id":157,"post_id":101,"tag_id":59,"sort_order":1},{"id":158,"post_id":102,"tag_id":61,"sort_order":1},{"id":159,"post_id":103,"tag_id":62,"sort_order":1},{"id":160,"post_id":105,"tag_id":64,"sort_order":1},{"id":161,"post_id":106,"tag_id":70,"sort_order":1},{"id":162,"post_id":107,"tag_id":66,"sort_order":1},{"id":163,"post_id":108,"tag_id":68,"sort_order":1},{"id":164,"post_id":109,"tag_id":70,"sort_order":1},{"id":165,"post_id":79,"tag_id":70,"sort_order":2},{"id":166,"post_id":83,"tag_id":70,"sort_order":2},{"id":167,"post_id":87,"tag_id":70,"sort_order":2},{"id":168,"post_id":88,"tag_id":70,"sort_order":2},{"id":169,"post_id":90,"tag_id":70,"sort_order":2},{"id":170,"post_id":92,"tag_id":70,"sort_order":2},{"id":171,"post_id":97,"tag_id":70,"sort_order":2},{"id":172,"post_id":101,"tag_id":70,"sort_order":2},{"id":173,"post_id":102,"tag_id":70,"sort_order":2},{"id":174,"post_id":103,"tag_id":70,"sort_order":2},{"id":175,"post_id":105,"tag_id":70,"sort_order":2},{"id":176,"post_id":107,"tag_id":70,"sort_order":2},{"id":177,"post_id":108,"tag_id":70,"sort_order":2}],"apps":[],"app_settings":[],"app_fields":[],"subscribers":[]}}